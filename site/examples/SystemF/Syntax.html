<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>Syntax.v</title>
<link rel="stylesheet" href="../alectryon.css" type="text/css" />
<link rel="stylesheet" href="../docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="../pygments.css" type="text/css" />
<script type="text/javascript" src="../alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Export</span>
  Functors.List
  Categories.TypeFamilies
  Classes.Kleisli.Decorated.Monad <span class="c">(* preincr *)</span>
  Multisorted.Classes.DTM.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves.Backends.LN <span class="kn">Require Import</span>
  Atom AtomSet AssocList Multisorted.LN.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> AtomSet.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Tealeaves.Classes.Monoid.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Tealeaves.Data.Product.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Tealeaves.Classes.Applicative.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Multisorted.Classes.DTM.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> List.ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable Variables</span> <span class="nf">F</span> G A B C œï.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * The index [K] *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">K2</span> : <span class="kt">Type</span> := KType | KTerm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk0">#[export] <span class="kn">Instance</span> <span class="nf">Keq</span> : EqDec K2 eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">EqDec K2 eq</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">EqDec K2 eq</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2"><span class="nb">change</span> (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : K2, {x = y} + {x &lt;&gt; y}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : K2, {x = y} + {x &lt;&gt; y}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">decide equality</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">I2</span> : Index := {| K := K2 |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * System F syntax and typeclass instances *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">base_typ</span> : <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">syntax</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    {<span class="nv">V</span> : <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">typ</span> : <span class="kt">Type</span> :=
  | ty_c : base_typ -&gt; typ
  | ty_v : V -&gt; typ
  | ty_ar : typ -&gt; typ -&gt; typ
  | ty_univ : typ -&gt; typ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">term</span> : <span class="kt">Type</span> :=
  | tm_var : V -&gt; term
  | tm_abs : typ -&gt; term -&gt; term
  | tm_app : term -&gt; term -&gt; term
  | tm_tab : term -&gt; term
  | tm_tap : term -&gt; typ -&gt; term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">syntax</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Clear the implicit arguments to the type constructors. This keeps &lt;&lt;V&gt;&gt;</span>
<span class="sd">    implicit for the constructors. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> typ V : <span class="kn">clear implicits</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> term V : <span class="kn">clear implicits</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">SystemF</span> (<span class="nv">k</span> : K) (<span class="nv">v</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> :=
  <span class="kr">match</span> k <span class="kr">with</span>
  | KType =&gt; typ v
  | KTerm =&gt; term v
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Notations *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Notations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> SystemF_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Notations for type expressions *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A ‚üπ B&quot;</span> := (ty_ar A B) (<span class="kn">at level</span> <span class="mi">51</span>, <span class="kn">right associativity</span>) : SystemF_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;‚àÄ œÑ&quot;</span> := (ty_univ œÑ) (<span class="kn">at level</span> <span class="mi">60</span>) : SystemF_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Notations for term expressions *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;Œª&#39; X ‚ãÖ body&quot;</span> := (tm_abs X body) (<span class="kn">at level</span> <span class="mi">45</span>) : SystemF_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;t1 @ t2&quot;</span> := (tm_app t1 t2) (<span class="kn">at level</span> <span class="mi">40</span>) : SystemF_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;Œõ&#39; body&quot;</span> := (tm_tab body) (<span class="kn">at level</span> <span class="mi">45</span>) : SystemF_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;t1 @@ t2&quot;</span> := (tm_tap t1 t2) (<span class="kn">at level</span> <span class="mi">40</span>) : SystemF_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Coercions from variables to leaves *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">Fr</span> : atom &gt;-&gt; LN.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">Bd</span> : nat &gt;-&gt; LN.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Coercions from leaves to term expressions *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">tm_var_</span> : LN -&gt; term LN := @tm_var LN.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">tm_var_</span> : LN &gt;-&gt; term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Coercions from leaves to type expressions *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c_base_type</span>: base_typ -&gt; typ LN := @ty_c LN.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c_LN_type</span> : LN -&gt; typ LN := @ty_v LN.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">c_base_type</span> : base_typ &gt;-&gt; typ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">c_LN_type</span> : LN &gt;-&gt; typ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Notations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> SystemF_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Example expressions *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">examples</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : atom)
    (<span class="nv">c1</span> <span class="nv">c2</span> <span class="nv">c3</span> : base_typ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Raw abstract syntax *)</span>
  <span class="sd">(** Abstract syntax trees without notations or coercions *)</span>
  <span class="sd">(******************************************************************************)</span>

  <span class="sd">(** *** Constants and variables *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_1</span> : typ LN := ty_v (Fr x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_2</span> : typ LN := ty_v (Fr y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_3</span> : typ LN := ty_v (Fr z).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_4</span> : typ LN := ty_v (Bd <span class="mi">0</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_5</span> : typ LN := ty_v (Bd <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_6</span> : typ LN := ty_v (Bd <span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_7</span> : typ LN := ty_c c1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_8</span> : typ LN := ty_c c2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Simple types *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_9</span>  : typ LN := ty_ar (ty_v (Fr x))
                                     (ty_v (Fr x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_10</span> : typ LN := ty_ar (ty_v (Fr x))
                                     (ty_v (Fr y)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_11</span> : typ LN := ty_ar (ty_v (Fr x))
                                     (ty_v (Bd <span class="mi">1</span>)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_12</span> : typ LN := ty_ar (ty_v (Bd <span class="mi">1</span>))
                                     (ty_c c1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_13</span> : typ LN := ty_ar (ty_ar (ty_v (Bd <span class="mi">0</span>))
                                            (ty_v (Fr x)))
                                     (ty_v (Bd <span class="mi">1</span>)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_14</span> : typ LN := ty_ar (ty_c c2)
                                     (ty_ar (ty_v (Fr x))
                                            (ty_v (Bd <span class="mi">1</span>))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_15</span> : typ LN := ty_ar (ty_ar (ty_v (Bd <span class="mi">2</span>))
                                            (ty_c c1))
                                     (ty_ar (ty_v (Fr y))
                                            (ty_v (Fr x))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_16</span> : typ LN := ty_ar (ty_ar (ty_v (Bd <span class="mi">2</span>))
                                            (ty_v (Bd <span class="mi">1</span>)))
                                     (ty_ar (ty_v (Fr y))
                                            (ty_v (Fr x))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Universal types *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_17</span> : typ LN := ty_univ (ty_ar (ty_v (Bd <span class="mi">0</span>))
                                              (ty_v (Bd <span class="mi">0</span>))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_18</span> : typ LN := ty_univ (ty_ar (ty_ar (ty_v (Bd <span class="mi">2</span>))
                                                     (ty_v (Bd <span class="mi">1</span>)))
                                              (ty_ar (ty_v (Fr y))
                                                     (ty_v (Fr x)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Printy printed syntax *)</span>
  <span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">pretty</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Open Scope</span> SystemF_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3"><span class="kn">Compute</span> (<span class="mi">0</span> : typ LN).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= ty_v <span class="mi">0</span>
: typ LN</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk4"><span class="kn">Compute</span> (x : typ LN).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= ty_v x
: typ LN</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5"><span class="kn">Compute</span> (c1 : typ LN).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= ty_c c1
: typ LN</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Constants and variables *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_1</span> : typ LN := x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_2</span> : typ LN := y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_3</span> : typ LN := Fr z.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_4</span> : typ LN := <span class="mi">0</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_5</span> : typ LN := Bd <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_6</span> : typ LN := <span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_7</span> : typ LN := c1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_8</span> : typ LN := c2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Simple types *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_9</span>  : typ LN := x ‚üπ x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_10</span> : typ LN := x ‚üπ y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6"><span class="kn">Goal</span> ((x ‚üπ x : typ LN) = Fr x ‚üπ Fr x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(x ‚üπ x : typ LN) = x ‚üπ x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7"><span class="kn">Goal</span> ((x ‚üπ <span class="mi">1</span> : typ LN) = Fr x ‚üπ Bd <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(x ‚üπ <span class="mi">1</span> : typ LN) = x ‚üπ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_11</span> : typ LN := x ‚üπ <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_12</span> : typ LN := x ‚üπ c1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_13</span> : typ LN := (x ‚üπ <span class="mi">0</span>) ‚üπ <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_14</span> : typ LN := c2 ‚üπ (x ‚üπ <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8"><span class="kn">Goal</span> c2 ‚üπ x ‚üπ <span class="mi">1</span> = c2 ‚üπ (x ‚üπ <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">c2 ‚üπ x ‚üπ <span class="mi">1</span> = c2 ‚üπ x ‚üπ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_15</span> : typ LN := (<span class="mi">2</span> ‚üπ c1) ‚üπ (y ‚üπ x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_16</span> : typ LN := (<span class="mi">2</span> ‚üπ <span class="mi">1</span>) ‚üπ (y ‚üπ x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Universal types *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_17</span> : typ LN := <span class="kr">‚àÄ</span> (<span class="mi">0</span> ‚üπ <span class="mi">0</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9"><span class="kn">Goal</span> <span class="kr">‚àÄ</span> (<span class="mi">0</span> ‚üπ <span class="mi">0</span>) = <span class="kr">‚àÄ</span> <span class="mi">0</span> ‚üπ <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="mi">0</span> ‚üπ <span class="mi">0</span> = <span class="kr">‚àÄ</span> <span class="mi">0</span> ‚üπ <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_18</span> : typ LN := <span class="kr">‚àÄ</span> (<span class="mi">2</span> ‚üπ <span class="mi">1</span>) ‚üπ (y ‚üπ x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka"><span class="kn">Goal</span> <span class="kr">‚àÄ</span> (<span class="mi">2</span> ‚üπ <span class="mi">1</span>) ‚üπ (y ‚üπ x) = <span class="kr">‚àÄ</span> ((<span class="mi">2</span> ‚üπ <span class="mi">1</span>) ‚üπ (y ‚üπ x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="mi">2</span> ‚üπ <span class="mi">1</span>) ‚üπ y ‚üπ x = <span class="kr">‚àÄ</span> (<span class="mi">2</span> ‚üπ <span class="mi">1</span>) ‚üπ y ‚üπ x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_19</span> : typ LN := (<span class="kr">‚àÄ</span> <span class="mi">2</span> ‚üπ <span class="mi">1</span>) ‚üπ (y ‚üπ x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_20</span> : typ LN := (<span class="mi">2</span> ‚üπ <span class="mi">1</span>) ‚üπ <span class="kr">‚àÄ</span> <span class="nv">y</span> ‚üπ x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">pretty</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">term_1</span> : term LN := tm_var (Fr x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">term_2</span> : term LN := tm_var (Bd <span class="mi">0</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">term_3</span> : term LN := tm_app term_1 term_2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">term_4</span> : term LN := tm_app term_3 term_3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Identity function on type [c1]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">term_5</span> : term LN := tm_abs (ty_c c1) (tm_var (Bd <span class="mi">0</span>)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">term_6</span> : term LN := tm_app term_5 term_3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Polymorphic identity function. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">term_7</span> : term LN := tm_tab (tm_abs (ty_v (Bd <span class="mi">0</span>))(tm_var (Bd <span class="mi">0</span>))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Instantiate identity at &lt;&lt;c1&gt;&gt; *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">term_8</span> : term LN := tm_tap term_7 c1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Open Scope</span> SystemF_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">term_9</span> : term LN := (Œõ <span class="kr">Œª</span> <span class="mi">0</span> ‚ãÖ <span class="mi">0</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">examples</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;binddt&gt;&gt; operations *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">operations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Applicative F}
    {A B : <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">bind_type</span> (<span class="nv">f</span> : <span class="kr">forall</span> (<span class="nv">k</span> : K), list K2 * A -&gt; F (SystemF k B)) (<span class="nv">t</span> : typ A) : F (typ B) :=
    <span class="kr">match</span> t <span class="kr">with</span>
    | ty_c t =&gt;
      pure F (ty_c t)
    | ty_v a =&gt;
      f KType (nil, a)
    | ty_ar t1 t2 =&gt;
      pure F (ty_ar) &lt;‚ãÜ&gt; (bind_type f t1) &lt;‚ãÜ&gt; (bind_type f t2)
    | ty_univ body =&gt;
      pure F (ty_univ) &lt;‚ãÜ&gt; (bind_type (<span class="kr">fun</span> <span class="nv">k</span> =&gt; preincr [KType] (f k)) body)
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">bind_term</span> (<span class="nv">f</span> : <span class="kr">forall</span> (<span class="nv">k</span> : K), list K2 * A -&gt; F (SystemF k B)) (<span class="nv">t</span> : term A) : F (term B) :=
    <span class="kr">match</span> t <span class="kr">with</span>
    | tm_var a =&gt;
      f KTerm (nil, a)
    | tm_abs ty body =&gt;
      pure F (tm_abs)
           &lt;‚ãÜ&gt; bind_type (<span class="kr">fun</span> <span class="nv">k</span> =&gt; f k) ty
           &lt;‚ãÜ&gt; bind_term (<span class="kr">fun</span> <span class="nv">k</span> =&gt; f k ‚àò incr [KTerm]) body
    | tm_app t1 t2 =&gt;
      pure F tm_app &lt;‚ãÜ&gt; bind_term f t1 &lt;‚ãÜ&gt; bind_term f t2
    | tm_tab body =&gt;
      pure F tm_tab &lt;‚ãÜ&gt; (bind_term (<span class="kr">fun</span> <span class="nv">k</span> =&gt; f k ‚àò incr [KType]) body)
    | tm_tap t1 ty =&gt;
      pure F tm_tap &lt;‚ãÜ&gt; bind_term f t1 &lt;‚ãÜ&gt; bind_type f ty
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">operations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">MReturn_SystemF</span> : MReturn SystemF :=
  <span class="kr">fun</span> <span class="nv">A</span> <span class="nv">k</span> =&gt; <span class="kr">match</span> k <span class="kr">with</span>
          | KType =&gt; ty_v
          | KTerm =&gt; tm_var
          <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">MBind_type</span> : MBind (list K2) SystemF typ := @bind_type.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">MBind_term</span> : MBind (list K2) SystemF term := @bind_term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">MBind_SystemF</span> : <span class="kr">forall</span> <span class="nv">k</span>, MBind (list K2) SystemF (SystemF k) :=
  <span class="kp">ltac</span>:(<span class="nb">intros</span> [|]; <span class="nb">typeclasses eauto</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Example computations *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">example_computations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> SystemF_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : atom)
    (<span class="nv">c1</span> <span class="nv">c2</span> <span class="nv">c3</span> : base_typ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Demo of opening operation *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb"><span class="kn">Goal</span> open (T := SystemF) typ KType (Fr x) (Bd <span class="mi">0</span>) = Fr x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>c1, c2, c3</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">open typ KType x <span class="mi">0</span> = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc"><span class="kn">Goal</span> open typ KType (Fr x) (Bd <span class="mi">1</span>) = Bd <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>c1, c2, c3</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">open typ KType x <span class="mi">1</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd"><span class="kn">Goal</span> open typ KType (Fr x) (Fr x) = Fr x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>c1, c2, c3</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">open typ KType x x = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke"><span class="kn">Goal</span> open typ KType (Fr x) (Fr y) = Fr y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>c1, c2, c3</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">open typ KType x y = y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf"><span class="kn">Goal</span> open typ KType (Fr y) (Fr x) = Fr x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>c1, c2, c3</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">open typ KType y x = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk10"><span class="kn">Goal</span> open typ KType (Fr y) (Fr y) = Fr y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>c1, c2, c3</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">open typ KType y y = y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk11"><span class="kn">Goal</span> open typ KType (Fr x) (<span class="kr">‚àÄ</span> <span class="nv">Bd</span> <span class="mi">0</span>) = (<span class="kr">‚àÄ</span> (<span class="nv">Bd</span> <span class="mi">0</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>c1, c2, c3</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">open typ KType x (<span class="kr">‚àÄ</span> <span class="mi">0</span>) = <span class="kr">‚àÄ</span> <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk12"><span class="kn">Goal</span> open typ KType (Fr x) (<span class="kr">‚àÄ</span> <span class="nv">Bd</span> <span class="mi">1</span>) = (<span class="kr">‚àÄ</span> (<span class="nv">Fr</span> <span class="nv">x</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>c1, c2, c3</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">open typ KType x (<span class="kr">‚àÄ</span> <span class="mi">1</span>) = <span class="kr">‚àÄ</span> <span class="nv">x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk13"><span class="kn">Goal</span> open typ KType (Fr x) (<span class="kr">‚àÄ</span> (<span class="nv">Bd</span> <span class="mi">1</span> ‚üπ Bd <span class="mi">0</span>)) = (<span class="kr">‚àÄ</span> <span class="nv">Fr</span> <span class="nv">x</span> ‚üπ Bd <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>c1, c2, c3</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">open typ KType x (<span class="kr">‚àÄ</span> <span class="mi">1</span> ‚üπ <span class="mi">0</span>) = <span class="kr">‚àÄ</span> <span class="nv">x</span> ‚üπ <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk14"><span class="kn">Goal</span> open typ KType (Fr x) (<span class="kr">‚àÄ</span> <span class="nv">Bd</span> <span class="mi">1</span> ‚üπ Bd <span class="mi">2</span>) = (<span class="kr">‚àÄ</span> <span class="nv">Fr</span> <span class="nv">x</span> ‚üπ Bd <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>c1, c2, c3</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">open typ KType x (<span class="kr">‚àÄ</span> <span class="mi">1</span> ‚üπ <span class="mi">2</span>) = <span class="kr">‚àÄ</span> <span class="nv">x</span> ‚üπ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">example_computations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Proofs of the DTM axioms *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="sd">(** ** Helper lemmas for proving DTM axioms *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">DTM_instance_lemmas</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">W</span> : <span class="kt">Type</span>)
    (<span class="nv">S</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    (<span class="nv">T</span> : K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{! MReturn T}
    `{! MBind W T S}
    `{! <span class="kr">forall</span> <span class="nv">k</span>, MBind W T (T k)}
    {mn_op : Monoid_op W}
    {mn_unit : Monoid_unit W}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk15"><span class="kn">Lemma</span> <span class="nf">mbinddt_inst_law1_case1</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : S A) (<span class="nv">w</span> : W),
      (mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) (<span class="kr">fun</span> <span class="nv">k</span> =&gt; mret T k ‚àò extract (W √ó)) t = t) -&gt;
      (mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) (<span class="kr">fun</span> <span class="nv">k</span> =&gt; mret T k ‚àò extract (W √ó) ‚àò incr w) t = t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : S A) (<span class="nv">w</span> : W),
mbinddt S (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract (prod W)) t = t -&gt;
mbinddt S (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract (prod W) ‚àò incr w)
  t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk16"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : S A) (<span class="nv">w</span> : W),
mbinddt S (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract (prod W)) t = t -&gt;
mbinddt S (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract (prod W) ‚àò incr w)
  t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk17">introv IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>S A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract (prod W)) t =
t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract (prod W) ‚àò incr w)
  t = t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk18"><span class="nb">rewrite</span> &lt;- IH <span class="nb">at</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>S A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract (prod W)) t =
t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract (prod W) ‚àò incr w)
  t =
mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract (prod W)) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk19">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>S A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract (prod W)) t =
t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract (prod W) ‚àò incr w) =
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract (prod W))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1a">ext k [w&#39; a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>S A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract (prod W)) t =
t</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>w'</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(mret T k ‚àò extract (prod W) ‚àò incr w) (w&#39;, a) =
(mret T k ‚àò extract (prod W)) (w&#39;, a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1b"><span class="kn">Lemma</span> <span class="nf">mbinddt_inst_law1_case12</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">w</span> : W),
      mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) (<span class="kr">fun</span> <span class="nv">k</span> =&gt; mret T k ‚àò extract (W √ó)) (A := A) =
      mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) (<span class="kr">fun</span> <span class="nv">k</span> =&gt; mret T k ‚àò extract (W √ó) ‚àò incr w).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">w</span> : W),
mbinddt S (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract (prod W)) =
mbinddt S (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract (prod W) ‚àò incr w)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">w</span> : W),
mbinddt S (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract (prod W)) =
mbinddt S (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract (prod W) ‚àò incr w)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1d">introv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract (prod W)) =
mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract (prod W) ‚àò incr w)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1e">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract (prod W)) =
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract (prod W) ‚àò incr w)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> ext k [w&#39; a].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Applicative G}
    `{Applicative F}
    `{! Monoid W}
    {A B C : <span class="kt">Type</span>}
    (g : <span class="kr">forall</span> <span class="nv">k</span>, W * B -&gt; G (T k C))
    (f : <span class="kr">forall</span> <span class="nv">k</span>, W * A -&gt; F (T k B)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* for Var case *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1f"><span class="kn">Lemma</span> <span class="nf">mbinddt_inst_law2_case2</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">k</span> : K),
    fmap F (mbinddt (T k) G g) (f k (∆µ, a)) =
    fmap F (mbinddt (T k) G (<span class="kr">fun</span> <span class="nv">k</span> =&gt; g k ‚àò const (incr ∆µ) k)) (f k (∆µ, a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">k</span> : K),
fmap F (mbinddt (T k) G g) (f k (∆µ, a)) =
fmap F
  (mbinddt (T k) G
     (<span class="kr">fun</span> <span class="nv">k0</span> : K =&gt; g k0 ‚àò const (incr ∆µ) k0))
  (f k (∆µ, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk20"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">k</span> : K),
fmap F (mbinddt (T k) G g) (f k (∆µ, a)) =
fmap F
  (mbinddt (T k) G
     (<span class="kr">fun</span> <span class="nv">k0</span> : K =&gt; g k0 ‚àò const (incr ∆µ) k0))
  (f k (∆µ, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk21"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt (T k) G g) (f k (∆µ, a)) =
fmap F
  (mbinddt (T k) G
     (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò const (incr ∆µ) k))
  (f k (∆µ, a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk22"><span class="kp">repeat</span> fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g = (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò const (incr ∆µ) k)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk23">ext k&#39; [w b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g k&#39; (w, b) = (g k&#39; ‚àò const (incr ∆µ) k&#39;) (w, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk24"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g k&#39; (w, b) = g k&#39; (const (incr ∆µ) k&#39; (w, b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk25"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g k&#39; (w, b) = g k&#39; (∆µ ‚óè w, b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> simpl_monoid.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk26"><span class="kn">Lemma</span> <span class="nf">compose_dtm_incr</span> : <span class="kr">forall</span> (<span class="nv">w</span> : W),
      (<span class="kr">fun</span> <span class="nv">k</span> =&gt; (g ‚ãÜdtm f) k ‚àò incr w) =
      ((<span class="kr">fun</span> <span class="nv">k</span> =&gt; g k ‚àò incr w) ‚ãÜdtm (<span class="kr">fun</span> <span class="nv">k</span> =&gt; f k ‚àò incr w)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">w</span> : W,
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; (g ‚ãÜdtm f) k ‚àò incr w) =
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr w)
‚ãÜdtm (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr w)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk27"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">w</span> : W,
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; (g ‚ãÜdtm f) k ‚àò incr w) =
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr w)
‚ãÜdtm (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr w)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk28"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; (g ‚ãÜdtm f) k ‚àò incr w) =
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr w)
‚ãÜdtm (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr w)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk29">ext k [w&#39; a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>w'</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((g ‚ãÜdtm f) k ‚àò incr w) (w&#39;, a) =
((<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr w)
 ‚ãÜdtm (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr w)) k (w&#39;, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2a"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>w'</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F
  (mbinddt (T k) G
     (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; g k ‚àò const (incr (w ‚óè w&#39;)) k))
  (f k (w ‚óè w&#39;, a)) =
fmap F
  (mbinddt (T k) G
     (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; g k ‚àò incr w ‚àò const (incr w&#39;) k))
  ((f k ‚àò incr w) (w&#39;, a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2b"><span class="kp">do</span> <span class="mi">2</span> fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>w'</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; g k ‚àò const (incr (w ‚óè w&#39;)) k) =
(<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; g k ‚àò incr w ‚àò const (incr w&#39;) k)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2c">ext j [w&#39;&#39; b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>w'</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>w''</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g j ‚àò const (incr (w ‚óè w&#39;)) j) (w&#39;&#39;, b) =
(g j ‚àò incr w ‚àò const (incr w&#39;) j) (w&#39;&#39;, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2d"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>w'</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>w''</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g j (const (incr (w ‚óè w&#39;)) j (w&#39;&#39;, b)) =
g j (incr w (const (incr w&#39;) j (w&#39;&#39;, b)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2e"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>w'</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>w''</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g j ((w ‚óè w&#39;) ‚óè w&#39;&#39;, b) = g j (w ‚óè (w&#39; ‚óè w&#39;&#39;), b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2f">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>w'</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>w''</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((w ‚óè w&#39;) ‚óè w&#39;&#39;, b) = (w ‚óè (w&#39; ‚óè w&#39;&#39;), b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> monoid_assoc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">DTM_instance_lemmas</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> compose_dtm_incr {W}%type_scope {T}%function_scope {H}%function_scope {mn_op mn_unit}
  {G}%function_scope {H0 H1 H2} {F}%function_scope {H4 H5 H6 Monoid0} {A B C}%type_scope (_
  _)%function_scope _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;mbinddt_mret&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk30"><span class="kn">Lemma</span> <span class="nf">mbinddt_mret_typ</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>),
    mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) (<span class="kr">fun</span> <span class="nv">k</span> =&gt; mret SystemF k ‚àò extract (list K2 √ó)) = @id (typ A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
mbinddt typ (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk31"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
mbinddt typ (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk32"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk33">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t = 
id t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk34"><span class="nb">unfold</span> id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t = t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk35"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) (ty_c b) =
ty_c b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk36" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk36"><hr></label><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) (ty_v v) =
ty_v v</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk37" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t2 = t2</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk37"><hr></label><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  (t1 ‚üπ t2) = t1 ‚üπ t2</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk38" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t =
t</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk38"><hr></label><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) 
  (<span class="kr">‚àÄ</span> <span class="nv">t</span>) = <span class="kr">‚àÄ</span> <span class="nv">t</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk39">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) (ty_c b) =
ty_c b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3a"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (ty_c b) = ty_c b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) (ty_v v) =
ty_v v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3c"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ty_v v = ty_v v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  (t1 ‚üπ t2) = t1 ‚üπ t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3e"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) ty_ar
  (mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
     (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
      mret SystemF k ‚àò extract (prod (list K2))) t1)
  (mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
     (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
      mret SystemF k ‚àò extract (prod (list K2))) t2) =
t1 ‚üπ t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3f">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t1 = t1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk40" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t2 = t2</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk40"><hr></label><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t2 = t2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk41">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t1 = t1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHt1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk42">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t2 = t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHt2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk43">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) (<span class="kr">‚àÄ</span> <span class="nv">t</span>) =
<span class="kr">‚àÄ</span> <span class="nv">t</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk44"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) ty_univ
  (mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
     (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
      preincr [KType]
        (mret SystemF k ‚àò extract (prod (list K2)))) t) =
<span class="kr">‚àÄ</span> <span class="nv">t</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk45">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
   preincr [KType]
     (mret SystemF k ‚àò extract (prod (list K2)))) t =
t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk46"><span class="nb">unfold</span> preincr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
   mret SystemF k ‚àò extract (prod (list K2))
   ‚àò incr [KType]) t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk47"><span class="nb">rewrite</span> &lt;- mbinddt_inst_law1_case12.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk48"><span class="kn">Lemma</span> <span class="nf">mbinddt_mret_term</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>),
    mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) (<span class="kr">fun</span> <span class="nv">k</span> =&gt; mret SystemF k ‚àò extract (list K2 √ó)) = @id (term A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
mbinddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk49"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
mbinddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk4a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk4b">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t = 
id t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk4c"><span class="nb">unfold</span> id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t = t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk4d"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  (tm_var v) = tm_var v</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk4e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t0 = t0</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk4e"><hr></label><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  (<span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0) = <span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk4f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t2 = t2</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk4f"><hr></label><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  (t1 @ t2) = t1 @ t2</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk50" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t =
t</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk50"><hr></label><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) 
  (Œõ t) = Œõ t</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk51" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t =
t</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk51"><hr></label><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  (t @@ t0) = t @@ t0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk52">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  (tm_var v) = tm_var v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk53">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t0 = t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  (<span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0) = <span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk54"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t0 = t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) tm_abs
  (bind_type (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
     (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
      mret SystemF k ‚àò extract (prod (list K2))) t)
  (mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
     (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
      mret SystemF k ‚àò extract (prod (list K2))
      ‚àò incr [KTerm]) t0) = <span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk55">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t0 = t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind_type (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t = t</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk56" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t0 = t0</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk56"><hr></label><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
   mret SystemF k ‚àò extract (prod (list K2))
   ‚àò incr [KTerm]) t0 = t0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk57">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t0 = t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind_type (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t = t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk58"><span class="nb">change</span> (bind_type <span class="nl">?F</span> <span class="nl">?f</span>) <span class="kr">with</span> (mbinddt typ F f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t0 = t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> mbinddt_mret_typ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk59">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t0 = t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
   mret SystemF k ‚àò extract (prod (list K2))
   ‚àò incr [KTerm]) t0 = t0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5a"><span class="nb">rewrite</span> &lt;- mbinddt_inst_law1_case12.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t0 = t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t0 = t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  (t1 @ t2) = t1 @ t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5c"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) tm_app
  (mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
     (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
      mret SystemF k ‚àò extract (prod (list K2))) t1)
  (mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
     (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
      mret SystemF k ‚àò extract (prod (list K2))) t2) =
t1 @ t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5d">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t1 = t1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk5e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t2 = t2</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk5e"><hr></label><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t2 = t2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t1 = t1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHt1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk60">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t2 = t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHt2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk61">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) (Œõ t) =
Œõ t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk62"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) tm_tab
  (mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
     (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
      mret SystemF k ‚àò extract (prod (list K2))
      ‚àò incr [KType]) t) = Œõ t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk63">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
   mret SystemF k ‚àò extract (prod (list K2))
   ‚àò incr [KType]) t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk64"><span class="nb">rewrite</span> &lt;- mbinddt_inst_law1_case12.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk65">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt;
   mret SystemF k ‚àò extract (prod (list K2)))
  (t @@ t0) = t @@ t0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk66"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) tm_tap
  (mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
     (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
      mret SystemF k ‚àò extract (prod (list K2))) t)
  (bind_type (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
     (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
      mret SystemF k ‚àò extract (prod (list K2))) t0) =
t @@ t0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk67">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t = t</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk68" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t = t</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk68"><hr></label><div class="goal-conclusion">bind_type (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t0 = t0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk69">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t = t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret SystemF k ‚àò extract (prod (list K2))) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind_type (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
   mret SystemF k ‚àò extract (prod (list K2))) t0 = t0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> mbinddt_mret_typ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;mbinddt_mbinddt&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6b"><span class="kn">Lemma</span> <span class="nf">mbinddt_mbinddt_typ</span> :
  <span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Applicative F}
    `{Applicative G}
    `(g : <span class="kr">forall</span> <span class="nv">k</span>, list K2 * B -&gt; G (SystemF k C))
    `(f : <span class="kr">forall</span> <span class="nv">k</span>, list K2 * A -&gt; F (SystemF k B)),
    fmap F (mbinddt typ G g) ‚àò mbinddt typ F f =
    mbinddt typ (F ‚àò G) (g ‚ãÜdtm f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> <span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">H3</span> : Fmap G) (<span class="nv">H4</span> : Pure G) (<span class="nv">H5</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>)
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">A</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) ‚àò mbinddt typ F f =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> <span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">H3</span> : Fmap G) (<span class="nv">H4</span> : Pure G) (<span class="nv">H5</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>)
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">A</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) ‚àò mbinddt typ F f =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6d"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g) ‚àò mbinddt typ F f =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6e">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap F (mbinddt typ G g) ‚àò mbinddt typ F f) t =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6f"><span class="nb">generalize dependent</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
(fmap F (mbinddt typ G g) ‚àò mbinddt typ F f) t =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk70"><span class="nb">generalize dependent</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
(fmap F (mbinddt typ G g) ‚àò mbinddt typ F f) t =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk71"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk72"><span class="nb">induction</span> t; <span class="nb">intros</span> g f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g) (mbinddt typ F f (ty_c b)) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) (ty_c b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk73" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk73"><hr></label><div class="goal-conclusion">fmap F (mbinddt typ G g) (mbinddt typ F f (ty_v v)) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) (ty_v v)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk74" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk74"><hr></label><div class="goal-conclusion">fmap F (mbinddt typ G g) (mbinddt typ F f (t1 ‚üπ t2)) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) (t1 ‚üπ t2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk75" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk75"><hr></label><div class="goal-conclusion">fmap F (mbinddt typ G g) (mbinddt typ F f (<span class="kr">‚àÄ</span> <span class="nv">t</span>)) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) (<span class="kr">‚àÄ</span> <span class="nv">t</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk76">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g) (mbinddt typ F f (ty_c b)) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) (ty_c b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk77"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g) (pure F (ty_c b)) =
pure (F ‚àò G) (ty_c b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk78"><span class="nb">rewrite</span> (app_pure_natural F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure F (mbinddt typ G g (ty_c b)) =
pure (F ‚àò G) (ty_c b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk79">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g) (mbinddt typ F f (ty_v v)) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) (ty_v v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7a"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g) (f KType ([], v)) =
fmap F
  (MBind_type G H3 H4 H5 B C
     (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; g k ‚àò const (incr []) k))
  (f KType ([], v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7b"><span class="nb">change</span> (MBind_type <span class="nl">?G</span> H3 H4 H5 <span class="nl">?A</span> <span class="nl">?B</span>) <span class="kr">with</span> (mbinddt typ G (A := A) (B := B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g) (f KType ([], v)) =
fmap F
  (mbinddt typ G
     (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; g k ‚àò const (incr []) k))
  (f KType ([], v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7c"><span class="nb">change</span> [] <span class="kr">with</span> (∆µ : list K2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g) (f KType (∆µ : list K2, v)) =
fmap F
  (mbinddt typ G
     (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; g k ‚àò const (incr (∆µ : list K2)) k))
  (f KType (∆µ : list K2, v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7d"><span class="nb">change</span> typ <span class="kr">with</span> (SystemF KType).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt (SystemF KType) G g)
  (f KType (∆µ : list K2, v)) =
fmap F
  (mbinddt (SystemF KType) G
     (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; g k ‚àò const (incr (∆µ : list K2)) k))
  (f KType (∆µ : list K2, v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7e"><span class="nb">rewrite</span> &lt;- (mbinddt_inst_law2_case2 (list K2) SystemF (H := MBind_SystemF )).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt (SystemF KType) G g) (f KType (∆µ, v)) =
fmap F (mbinddt (SystemF KType) G g) (f KType (∆µ, v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g) (mbinddt typ F f (t1 ‚üπ t2)) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) (t1 ‚üπ t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk80"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g)
  (pure F ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
   mbinddt typ F f t2) =
pure (F ‚àò G) ty_ar &lt;‚ãÜ&gt;
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1 &lt;‚ãÜ&gt;
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk81"><span class="nb">rewrite</span> &lt;- IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g)
  (pure F ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
   mbinddt typ F f t2) =
pure (F ‚àò G) ty_ar &lt;‚ãÜ&gt;
fmap F (mbinddt typ G g) (mbinddt typ F f t1) &lt;‚ãÜ&gt;
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk82"><span class="nb">rewrite</span> &lt;- IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g)
  (pure F ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
   mbinddt typ F f t2) =
pure (F ‚àò G) ty_ar &lt;‚ãÜ&gt;
fmap F (mbinddt typ G g) (mbinddt typ F f t1) &lt;‚ãÜ&gt;
fmap F (mbinddt typ G g) (mbinddt typ F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk83"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> (ap_compose2 G F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g)
  (pure F ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
   mbinddt typ F f t2) =
fmap F (ap G)
  (fmap F (ap G) (pure (F ‚àò G) ty_ar) &lt;‚ãÜ&gt;
   fmap F (mbinddt typ G g) (mbinddt typ F f t1)) &lt;‚ãÜ&gt;
fmap F (mbinddt typ G g) (mbinddt typ F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk84"><span class="nb">rewrite</span> &lt;- (ap_fmap (G := F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g)
  (pure F ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
   mbinddt typ F f t2) =
fmap F (precompose (mbinddt typ G g))
  (fmap F (ap G)
     (fmap F (ap G) (pure (F ‚àò G) ty_ar) &lt;‚ãÜ&gt;
      fmap F (mbinddt typ G g) (mbinddt typ F f t1))) &lt;‚ãÜ&gt;
mbinddt typ F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk85"><span class="nb">rewrite</span> &lt;- (ap_fmap (G := F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g)
  (pure F ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
   mbinddt typ F f t2) =
fmap F (precompose (mbinddt typ G g))
  (fmap F (ap G)
     (fmap F (precompose (mbinddt typ G g))
        (fmap F (ap G) (pure (F ‚àò G) ty_ar)) &lt;‚ãÜ&gt;
      mbinddt typ F f t1)) &lt;‚ãÜ&gt; mbinddt typ F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk86"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> fmap_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt typ G g)))
  (pure F ty_ar) &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
mbinddt typ F f t2 =
fmap F (precompose (mbinddt typ G g))
  (fmap F (ap G)
     (fmap F (precompose (mbinddt typ G g))
        (fmap F (ap G) (pure (F ‚àò G) ty_ar)) &lt;‚ãÜ&gt;
      mbinddt typ F f t1)) &lt;‚ãÜ&gt; mbinddt typ F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk87"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> fmap_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt typ G g)))
  (pure F ty_ar) &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
mbinddt typ F f t2 =
fmap F (compose (precompose (mbinddt typ G g)))
  (fmap F (compose (ap G))
     (fmap F (precompose (mbinddt typ G g))
        (fmap F (ap G) (pure (F ‚àò G) ty_ar)))) &lt;‚ãÜ&gt;
mbinddt typ F f t1 &lt;‚ãÜ&gt; mbinddt typ F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk88"><span class="kp">do</span> <span class="mi">3</span> (compose near (pure (F ‚àò G) (ty_ar (V := C)));
          <span class="nb">rewrite</span> (fun_fmap_fmap F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt typ G g)))
  (pure F ty_ar) &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
mbinddt typ F f t2 =
fmap F
  (compose (precompose (mbinddt typ G g))
   ‚àò (compose (ap G)
      ‚àò (precompose (mbinddt typ G g) ‚àò ap G)))
  (pure (F ‚àò G) ty_ar) &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
mbinddt typ F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk89">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt typ G g)))
  (pure F ty_ar) &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
mbinddt typ F f t2 =
fmap F
  (compose (precompose (mbinddt typ G g))
   ‚àò (compose (ap G)
      ‚àò (precompose (mbinddt typ G g) ‚àò ap G)))
  (pure F (pure G ty_ar)) &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
mbinddt typ F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8a"><span class="nb">rewrite</span> (app_pure_natural F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure F (compose (mbinddt typ G g) ‚àò ty_ar) &lt;‚ãÜ&gt;
mbinddt typ F f t1 &lt;‚ãÜ&gt; mbinddt typ F f t2 =
fmap F
  (compose (precompose (mbinddt typ G g))
   ‚àò (compose (ap G)
      ‚àò (precompose (mbinddt typ G g) ‚àò ap G)))
  (pure F (pure G ty_ar)) &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
mbinddt typ F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8b"><span class="nb">rewrite</span> (app_pure_natural F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure F (compose (mbinddt typ G g) ‚àò ty_ar) &lt;‚ãÜ&gt;
mbinddt typ F f t1 &lt;‚ãÜ&gt; mbinddt typ F f t2 =
pure F
  ((compose (precompose (mbinddt typ G g))
    ‚àò (compose (ap G)
       ‚àò (precompose (mbinddt typ G g) ‚àò ap G)))
     (pure G ty_ar)) &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
mbinddt typ F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g) (mbinddt typ F f (<span class="kr">‚àÄ</span> <span class="nv">t</span>)) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) (<span class="kr">‚àÄ</span> <span class="nv">t</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8d"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g)
  (pure F ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; preincr [KType] (f k))
     t) =
pure (F ‚àò G) ty_univ &lt;‚ãÜ&gt;
mbinddt typ (F ‚àò G)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; preincr [KType] ((g ‚ãÜdtm f) k)) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8e"><span class="nb">setoid_rewrite</span> compose_dtm_incr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g)
  (pure F ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; preincr [KType] (f k))
     t) =
pure (F ‚àò G) ty_univ &lt;‚ãÜ&gt;
mbinddt typ (F ‚àò G)
  ((<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr [KType])
   ‚ãÜdtm (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr [KType])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8f"><span class="nb">rewrite</span> &lt;- IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g)
  (pure F ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; preincr [KType] (f k))
     t) =
pure (F ‚àò G) ty_univ &lt;‚ãÜ&gt;
fmap F
  (mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr [KType]))
  (mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr [KType]) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk90"><span class="nb">rewrite</span> (ap_compose2 G F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g)
  (pure F ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; preincr [KType] (f k))
     t) =
fmap F (ap G) (pure (F ‚àò G) ty_univ) &lt;‚ãÜ&gt;
fmap F
  (mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr [KType]))
  (mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr [KType]) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk91"><span class="nb">rewrite</span> &lt;- (ap_fmap (G := F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g)
  (pure F ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; preincr [KType] (f k))
     t) =
fmap F
  (precompose
     (mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr [KType])))
  (fmap F (ap G) (pure (F ‚àò G) ty_univ)) &lt;‚ãÜ&gt;
mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr [KType]) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk92">compose near (pure (F ‚àò G) (ty_univ (V := C))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g)
  (pure F ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; preincr [KType] (f k))
     t) =
(fmap F
   (precompose
      (mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr [KType])))
 ‚àò fmap F (ap G)) (pure (F ‚àò G) ty_univ) &lt;‚ãÜ&gt;
mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr [KType]) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk93"><span class="nb">rewrite</span> (fun_fmap_fmap F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g)
  (pure F ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; preincr [KType] (f k))
     t) =
fmap F
  (precompose
     (mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr [KType]))
   ‚àò ap G) (pure (F ‚àò G) ty_univ) &lt;‚ãÜ&gt;
mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr [KType]) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk94">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g)
  (pure F ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; preincr [KType] (f k))
     t) =
fmap F
  (precompose
     (mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr [KType]))
   ‚àò ap G) (pure F (pure G ty_univ)) &lt;‚ãÜ&gt;
mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr [KType]) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk95"><span class="nb">rewrite</span> (app_pure_natural F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt typ G g)
  (pure F ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; preincr [KType] (f k))
     t) =
pure F
  ((precompose
      (mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr [KType]))
    ‚àò ap G) (pure G ty_univ)) &lt;‚ãÜ&gt;
mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr [KType]) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk96"><span class="nb">rewrite</span> fmap_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (mbinddt typ G g)) (pure F ty_univ) &lt;‚ãÜ&gt;
mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; preincr [KType] (f k)) t =
pure F
  ((precompose
      (mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr [KType]))
    ‚àò ap G) (pure G ty_univ)) &lt;‚ãÜ&gt;
mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr [KType]) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk97"><span class="nb">rewrite</span> (app_pure_natural F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt typ G g) (mbinddt typ F f t) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure F (mbinddt typ G g ‚àò ty_univ) &lt;‚ãÜ&gt;
mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; preincr [KType] (f k)) t =
pure F
  ((precompose
      (mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr [KType]))
    ‚àò ap G) (pure G ty_univ)) &lt;‚ãÜ&gt;
mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr [KType]) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk98"><span class="kn">Lemma</span> <span class="nf">mbinddt_mbinddt_term</span> :
  <span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Applicative F}
    `{Applicative G}
    `(g : <span class="kr">forall</span> <span class="nv">k</span>, list K2 * B -&gt; G (SystemF k C))
    `(f : <span class="kr">forall</span> <span class="nv">k</span>, list K2 * A -&gt; F (SystemF k B)),
    fmap F (mbinddt term G g) ‚àò mbinddt term F f =
    mbinddt term (F ‚àò G) (g ‚ãÜdtm f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> <span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">H3</span> : Fmap G) (<span class="nv">H4</span> : Pure G) (<span class="nv">H5</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>)
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">A</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) ‚àò mbinddt term F f =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk99"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> <span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">H3</span> : Fmap G) (<span class="nv">H4</span> : Pure G) (<span class="nv">H5</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>)
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">A</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) ‚àò mbinddt term F f =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g) ‚àò mbinddt term F f =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9b">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap F (mbinddt term G g) ‚àò mbinddt term F f) t =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9c"><span class="nb">generalize dependent</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
(fmap F (mbinddt term G g) ‚àò mbinddt term F f) t =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9d"><span class="nb">generalize dependent</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
(fmap F (mbinddt term G g) ‚àò mbinddt term F f) t =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9e"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9f"><span class="nb">induction</span> t; <span class="nb">intros</span> g f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (mbinddt term F f (tm_var v)) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) (tm_var v)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chka0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chka0"><hr></label><div class="goal-conclusion">fmap F (mbinddt term G g)
  (mbinddt term F f (<span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0)) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) (<span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chka1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chka1"><hr></label><div class="goal-conclusion">fmap F (mbinddt term G g) (mbinddt term F f (t1 @ t2)) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) (t1 @ t2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chka2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chka2"><hr></label><div class="goal-conclusion">fmap F (mbinddt term G g) (mbinddt term F f (Œõ t)) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) (Œõ t)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chka3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chka3"><hr></label><div class="goal-conclusion">fmap F (mbinddt term G g) (mbinddt term F f (t @@ t0)) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) (t @@ t0)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (mbinddt term F f (tm_var v)) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) (tm_var v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka5"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g) (f KTerm ([], v)) =
fmap F
  (MBind_term G H3 H4 H5 B C
     (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; g k ‚àò const (incr []) k))
  (f KTerm ([], v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka6"><span class="nb">change</span> (MBind_term <span class="nl">?G</span> H3 H4 H5 <span class="nl">?A</span> <span class="nl">?B</span>) <span class="kr">with</span> (mbinddt term G (A := A) (B := B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g) (f KTerm ([], v)) =
fmap F
  (mbinddt term G
     (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; g k ‚àò const (incr []) k))
  (f KTerm ([], v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka7">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term G g =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; g k ‚àò const (incr []) k)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka8">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g = (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; g k ‚àò const (incr []) k)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> ext k [w a].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (mbinddt term F f (<span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0)) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) (<span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkaa"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_abs &lt;‚ãÜ&gt; bind_type F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k) t &lt;‚ãÜ&gt;
   mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KTerm])
     t0) =
pure (F ‚àò G) tm_abs &lt;‚ãÜ&gt;
bind_type (F ‚àò G) (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; (g ‚ãÜdtm f) k) t &lt;‚ãÜ&gt;
mbinddt term (F ‚àò G)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; (g ‚ãÜdtm f) k ‚àò incr [KTerm]) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkab"><span class="nb">change</span> (bind_type <span class="nl">?F</span> <span class="nl">?f</span>) <span class="kr">with</span> (mbinddt typ F f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_abs &lt;‚ãÜ&gt;
   mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k) t &lt;‚ãÜ&gt;
   mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KTerm])
     t0) =
pure (F ‚àò G) tm_abs &lt;‚ãÜ&gt;
mbinddt typ (F ‚àò G) (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; (g ‚ãÜdtm f) k) t &lt;‚ãÜ&gt;
mbinddt term (F ‚àò G)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; (g ‚ãÜdtm f) k ‚àò incr [KTerm]) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkac"><span class="nb">setoid_rewrite</span> compose_dtm_incr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_abs &lt;‚ãÜ&gt;
   mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k) t &lt;‚ãÜ&gt;
   mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KTerm])
     t0) =
pure (F ‚àò G) tm_abs &lt;‚ãÜ&gt;
mbinddt typ (F ‚àò G) (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; (g ‚ãÜdtm f) k) t &lt;‚ãÜ&gt;
mbinddt term (F ‚àò G)
  ((<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr [KTerm])
   ‚ãÜdtm (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr [KTerm])) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkad"><span class="nb">rewrite</span> &lt;- IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_abs &lt;‚ãÜ&gt;
   mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k) t &lt;‚ãÜ&gt;
   mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KTerm])
     t0) =
pure (F ‚àò G) tm_abs &lt;‚ãÜ&gt;
mbinddt typ (F ‚àò G) (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; (g ‚ãÜdtm f) k) t &lt;‚ãÜ&gt;
fmap F
  (mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr [KTerm]))
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr [KTerm]) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkae"><span class="nb">rewrite</span> &lt;- (mbinddt_mbinddt_typ F G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_abs &lt;‚ãÜ&gt;
   mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k) t &lt;‚ãÜ&gt;
   mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KTerm])
     t0) =
pure (F ‚àò G) tm_abs &lt;‚ãÜ&gt;
(fmap F (mbinddt typ G g) ‚àò mbinddt typ F f) t &lt;‚ãÜ&gt;
fmap F
  (mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr [KTerm]))
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr [KTerm]) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkaf"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">6</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_abs &lt;‚ãÜ&gt;
   mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k) t &lt;‚ãÜ&gt;
   mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KTerm])
     t0) =
pure (F ‚àò G) tm_abs &lt;‚ãÜ&gt;
(fmap F (mbinddt typ G g) ‚àò mbinddt typ F f) t &lt;‚ãÜ&gt;
fmap F
  (mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚óã incr [KTerm]))
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr [KTerm]) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb0"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> (ap_compose2 G F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_abs &lt;‚ãÜ&gt;
   mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k) t &lt;‚ãÜ&gt;
   mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KTerm])
     t0) =
fmap F (ap G)
  (fmap F (ap G) (pure (F ‚àò G) tm_abs) &lt;‚ãÜ&gt;
   (fmap F (mbinddt typ G g) ‚àò mbinddt typ F f) t) &lt;‚ãÜ&gt;
fmap F
  (mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚óã incr [KTerm]))
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr [KTerm]) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb1"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_abs &lt;‚ãÜ&gt;
   mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k) t &lt;‚ãÜ&gt;
   mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚óã incr [KTerm])
     t0) =
fmap F (ap G)
  (fmap F (ap G) (pure (F ‚óã G) tm_abs) &lt;‚ãÜ&gt;
   fmap F (mbinddt typ G g) (mbinddt typ F f t)) &lt;‚ãÜ&gt;
fmap F
  (mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚óã incr [KTerm]))
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KTerm]) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb2"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> &lt;- (ap_fmap (G := F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_abs &lt;‚ãÜ&gt;
   mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k) t &lt;‚ãÜ&gt;
   mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚óã incr [KTerm])
     t0) =
fmap F
  (precompose
     (mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚óã incr [KTerm])))
  (fmap F (ap G)
     (fmap F (precompose (mbinddt typ G g))
        (fmap F (ap G) (pure (F ‚óã G) tm_abs)) &lt;‚ãÜ&gt;
      mbinddt typ F f t)) &lt;‚ãÜ&gt;
mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KTerm]) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb3">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_abs &lt;‚ãÜ&gt;
   mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k) t &lt;‚ãÜ&gt;
   mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚óã incr [KTerm])
     t0) =
fmap F
  (precompose
     (mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚óã incr [KTerm])))
  (fmap F (ap G)
     (fmap F (precompose (mbinddt typ G g))
        (fmap F (ap G) (pure F (pure G tm_abs))) &lt;‚ãÜ&gt;
      mbinddt typ F f t)) &lt;‚ãÜ&gt;
mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KTerm]) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb4"><span class="nb">rewrite</span> (app_pure_natural F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_abs &lt;‚ãÜ&gt;
   mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k) t &lt;‚ãÜ&gt;
   mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚óã incr [KTerm])
     t0) =
fmap F
  (precompose
     (mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚óã incr [KTerm])))
  (fmap F (ap G)
     (fmap F (precompose (mbinddt typ G g))
        (pure F (ap G (pure G tm_abs))) &lt;‚ãÜ&gt;
      mbinddt typ F f t)) &lt;‚ãÜ&gt;
mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KTerm]) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb5"><span class="kp">do</span> <span class="mi">4</span> <span class="nb">rewrite</span> fmap_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt term G g)))
  (pure F tm_abs) &lt;‚ãÜ&gt;
mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k) t &lt;‚ãÜ&gt;
mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚óã incr [KTerm]) t0 =
fmap F
  (compose
     (precompose
        (mbinddt term G
           (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚óã incr [KTerm]))))
  (fmap F (compose (ap G))
     (fmap F (precompose (mbinddt typ G g))
        (pure F (ap G (pure G tm_abs))))) &lt;‚ãÜ&gt;
mbinddt typ F f t &lt;‚ãÜ&gt;
mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KTerm]) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb6">compose near ((pure F (ap G (pure G (@tm_abs C))))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt term G g)))
  (pure F tm_abs) &lt;‚ãÜ&gt;
mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k) t &lt;‚ãÜ&gt;
mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚óã incr [KTerm]) t0 =
fmap F
  (compose
     (precompose
        (mbinddt term G
           (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚óã incr [KTerm]))))
  ((fmap F (compose (ap G))
    ‚àò fmap F (precompose (mbinddt typ G g)))
     (pure F (ap G (pure G tm_abs)))) &lt;‚ãÜ&gt;
mbinddt typ F f t &lt;‚ãÜ&gt;
mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KTerm]) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb7"><span class="nb">rewrite</span> (fun_fmap_fmap F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt term G g)))
  (pure F tm_abs) &lt;‚ãÜ&gt;
mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k) t &lt;‚ãÜ&gt;
mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚óã incr [KTerm]) t0 =
fmap F
  (compose
     (precompose
        (mbinddt term G
           (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚óã incr [KTerm]))))
  (fmap F
     (compose (ap G) ‚àò precompose (mbinddt typ G g))
     (pure F (ap G (pure G tm_abs)))) &lt;‚ãÜ&gt;
mbinddt typ F f t &lt;‚ãÜ&gt;
mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KTerm]) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb8"><span class="kp">do</span> <span class="mi">3</span> <span class="nb">rewrite</span> (app_pure_natural F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure F (compose (mbinddt term G g) ‚àò tm_abs) &lt;‚ãÜ&gt;
mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k) t &lt;‚ãÜ&gt;
mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚óã incr [KTerm]) t0 =
pure F
  (precompose
     (mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚óã incr [KTerm]))
   ‚àò (compose (ap G) ‚àò precompose (mbinddt typ G g))
       (ap G (pure G tm_abs))) &lt;‚ãÜ&gt; mbinddt typ F f t &lt;‚ãÜ&gt;
mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KTerm]) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g) (mbinddt term F f (t1 @ t2)) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) (t1 @ t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkba"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_app &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
   mbinddt term F f t2) =
pure (F ‚àò G) tm_app &lt;‚ãÜ&gt;
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1 &lt;‚ãÜ&gt;
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkbb"><span class="nb">rewrite</span> &lt;- IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_app &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
   mbinddt term F f t2) =
pure (F ‚àò G) tm_app &lt;‚ãÜ&gt;
fmap F (mbinddt term G g) (mbinddt term F f t1) &lt;‚ãÜ&gt;
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkbc"><span class="nb">rewrite</span> &lt;- IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_app &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
   mbinddt term F f t2) =
pure (F ‚àò G) tm_app &lt;‚ãÜ&gt;
fmap F (mbinddt term G g) (mbinddt term F f t1) &lt;‚ãÜ&gt;
fmap F (mbinddt term G g) (mbinddt term F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkbd"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> (ap_compose2 G F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_app &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
   mbinddt term F f t2) =
fmap F (ap G)
  (fmap F (ap G) (pure (F ‚àò G) tm_app) &lt;‚ãÜ&gt;
   fmap F (mbinddt term G g) (mbinddt term F f t1)) &lt;‚ãÜ&gt;
fmap F (mbinddt term G g) (mbinddt term F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkbe"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> &lt;- (ap_fmap (G := F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_app &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
   mbinddt term F f t2) =
fmap F (precompose (mbinddt term G g))
  (fmap F (ap G)
     (fmap F (precompose (mbinddt term G g))
        (fmap F (ap G) (pure (F ‚àò G) tm_app)) &lt;‚ãÜ&gt;
      mbinddt term F f t1)) &lt;‚ãÜ&gt; mbinddt term F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkbf"><span class="kp">do</span> <span class="mi">4</span> <span class="nb">rewrite</span> fmap_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt term G g)))
  (pure F tm_app) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2 =
fmap F (compose (precompose (mbinddt term G g)))
  (fmap F (compose (ap G))
     (fmap F (precompose (mbinddt term G g))
        (fmap F (ap G) (pure (F ‚àò G) tm_app)))) &lt;‚ãÜ&gt;
mbinddt term F f t1 &lt;‚ãÜ&gt; mbinddt term F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc0">compose near (pure (F ‚àò G) (@tm_app C)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt term G g)))
  (pure F tm_app) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2 =
fmap F (compose (precompose (mbinddt term G g)))
  (fmap F (compose (ap G))
     ((fmap F (precompose (mbinddt term G g))
       ‚àò fmap F (ap G)) (pure (F ‚àò G) tm_app))) &lt;‚ãÜ&gt;
mbinddt term F f t1 &lt;‚ãÜ&gt; mbinddt term F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc1"><span class="nb">rewrite</span> (fun_fmap_fmap F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt term G g)))
  (pure F tm_app) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2 =
fmap F (compose (precompose (mbinddt term G g)))
  (fmap F (compose (ap G))
     (fmap F (precompose (mbinddt term G g) ‚àò ap G)
        (pure (F ‚àò G) tm_app))) &lt;‚ãÜ&gt;
mbinddt term F f t1 &lt;‚ãÜ&gt; mbinddt term F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc2">compose near (pure (F ‚àò G) (@tm_app C)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt term G g)))
  (pure F tm_app) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2 =
fmap F (compose (precompose (mbinddt term G g)))
  ((fmap F (compose (ap G))
    ‚àò fmap F (precompose (mbinddt term G g) ‚àò ap G))
     (pure (F ‚àò G) tm_app)) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc3"><span class="nb">rewrite</span> (fun_fmap_fmap F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt term G g)))
  (pure F tm_app) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2 =
fmap F (compose (precompose (mbinddt term G g)))
  (fmap F
     (compose (ap G)
      ‚àò (precompose (mbinddt term G g) ‚àò ap G))
     (pure (F ‚àò G) tm_app)) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc4">compose near (pure (F ‚àò G) (@tm_app C)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt term G g)))
  (pure F tm_app) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2 =
(fmap F (compose (precompose (mbinddt term G g)))
 ‚àò fmap F
     (compose (ap G)
      ‚àò (precompose (mbinddt term G g) ‚àò ap G)))
  (pure (F ‚àò G) tm_app) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc5"><span class="nb">rewrite</span> (fun_fmap_fmap F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt term G g)))
  (pure F tm_app) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2 =
fmap F
  (compose (precompose (mbinddt term G g))
   ‚àò (compose (ap G)
      ‚àò (precompose (mbinddt term G g) ‚àò ap G)))
  (pure (F ‚àò G) tm_app) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc6">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt term G g)))
  (pure F tm_app) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2 =
fmap F
  (compose (precompose (mbinddt term G g))
   ‚àò (compose (ap G)
      ‚àò (precompose (mbinddt term G g) ‚àò ap G)))
  (pure F (pure G tm_app)) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc7"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> (app_pure_natural F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure F (compose (mbinddt term G g) ‚àò tm_app) &lt;‚ãÜ&gt;
mbinddt term F f t1 &lt;‚ãÜ&gt; mbinddt term F f t2 =
pure F
  ((compose (precompose (mbinddt term G g))
    ‚àò (compose (ap G)
       ‚àò (precompose (mbinddt term G g) ‚àò ap G)))
     (pure G tm_app)) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g) (mbinddt term F f (Œõ t)) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) (Œõ t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc9"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_tab &lt;‚ãÜ&gt;
   mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KType]) t) =
pure (F ‚àò G) tm_tab &lt;‚ãÜ&gt;
mbinddt term (F ‚àò G)
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; (g ‚ãÜdtm f) k ‚àò incr [KType]) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkca"><span class="nb">setoid_rewrite</span> compose_dtm_incr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_tab &lt;‚ãÜ&gt;
   mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KType]) t) =
pure (F ‚àò G) tm_tab &lt;‚ãÜ&gt;
mbinddt term (F ‚àò G)
  ((<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr [KType])
   ‚ãÜdtm (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr [KType])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkcb"><span class="nb">rewrite</span> &lt;- IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_tab &lt;‚ãÜ&gt;
   mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KType]) t) =
pure (F ‚àò G) tm_tab &lt;‚ãÜ&gt;
fmap F
  (mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr [KType]))
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr [KType]) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkcc"><span class="nb">rewrite</span> (ap_compose2 G F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_tab &lt;‚ãÜ&gt;
   mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KType]) t) =
fmap F (ap G) (pure (F ‚àò G) tm_tab) &lt;‚ãÜ&gt;
fmap F
  (mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr [KType]))
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr [KType]) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkcd"><span class="nb">rewrite</span> &lt;- (ap_fmap (G := F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_tab &lt;‚ãÜ&gt;
   mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KType]) t) =
fmap F
  (precompose
     (mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr [KType])))
  (fmap F (ap G) (pure (F ‚àò G) tm_tab)) &lt;‚ãÜ&gt;
mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr [KType]) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkce"><span class="nb">rewrite</span> fmap_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (mbinddt term G g)) (pure F tm_tab) &lt;‚ãÜ&gt;
mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KType]) t =
fmap F
  (precompose
     (mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr [KType])))
  (fmap F (ap G) (pure (F ‚àò G) tm_tab)) &lt;‚ãÜ&gt;
mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr [KType]) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkcf">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (mbinddt term G g)) (pure F tm_tab) &lt;‚ãÜ&gt;
mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KType]) t =
fmap F
  (precompose
     (mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr [KType])))
  (fmap F (ap G) (pure F (pure G tm_tab))) &lt;‚ãÜ&gt;
mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr [KType]) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd0"><span class="kp">do</span> <span class="mi">3</span> <span class="nb">rewrite</span> (app_pure_natural F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure F (mbinddt term G g ‚àò tm_tab) &lt;‚ãÜ&gt;
mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KType]) t =
pure F
  (precompose
     (mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò incr [KType]))
     (ap G (pure G tm_tab))) &lt;‚ãÜ&gt;
mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚àò incr [KType]) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g) (mbinddt term F f (t @@ t0)) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) (t @@ t0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd2"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_tap &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
   bind_type F f t0) =
pure (F ‚àò G) tm_tap &lt;‚ãÜ&gt;
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t &lt;‚ãÜ&gt;
bind_type (F ‚àò G) (g ‚ãÜdtm f) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd3"><span class="nb">rewrite</span> &lt;- IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_tap &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
   bind_type F f t0) =
pure (F ‚àò G) tm_tap &lt;‚ãÜ&gt;
fmap F (mbinddt term G g) (mbinddt term F f t) &lt;‚ãÜ&gt;
bind_type (F ‚àò G) (g ‚ãÜdtm f) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd4"><span class="nb">rewrite</span> &lt;- (mbinddt_mbinddt_typ F G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_tap &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
   bind_type F f t0) =
pure (F ‚àò G) tm_tap &lt;‚ãÜ&gt;
fmap F (mbinddt term G g) (mbinddt term F f t) &lt;‚ãÜ&gt;
(fmap F (mbinddt typ G g) ‚àò mbinddt typ F f) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd5"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">4</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_tap &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
   bind_type F f t0) =
pure (F ‚àò G) tm_tap &lt;‚ãÜ&gt;
fmap F (mbinddt term G g) (mbinddt term F f t) &lt;‚ãÜ&gt;
fmap F (mbinddt typ G g) (mbinddt typ F f t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd6"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> (ap_compose2 G F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_tap &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
   bind_type F f t0) =
fmap F (ap G)
  (fmap F (ap G) (pure (F ‚àò G) tm_tap) &lt;‚ãÜ&gt;
   fmap F (mbinddt term G g) (mbinddt term F f t)) &lt;‚ãÜ&gt;
fmap F (mbinddt typ G g) (mbinddt typ F f t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd7"><span class="kp">repeat</span> <span class="nb">rewrite</span> &lt;- (ap_fmap (G := F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_tap &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
   bind_type F f t0) =
fmap F (precompose (mbinddt typ G g))
  (fmap F (ap G)
     (fmap F (precompose (mbinddt term G g))
        (fmap F (ap G) (pure (F ‚àò G) tm_tap)) &lt;‚ãÜ&gt;
      mbinddt term F f t)) &lt;‚ãÜ&gt; mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd8"><span class="nb">change</span> (bind_type <span class="nl">?F</span> <span class="nl">?f</span>) <span class="kr">with</span> (mbinddt typ F f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (mbinddt term G g)
  (pure F tm_tap &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
   mbinddt typ F f t0) =
fmap F (precompose (mbinddt typ G g))
  (fmap F (ap G)
     (fmap F (precompose (mbinddt term G g))
        (fmap F (ap G) (pure (F ‚àò G) tm_tap)) &lt;‚ãÜ&gt;
      mbinddt term F f t)) &lt;‚ãÜ&gt; mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd9"><span class="kp">do</span> <span class="mi">4</span> <span class="nb">rewrite</span> fmap_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt term G g)))
  (pure F tm_tap) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0 =
fmap F (compose (precompose (mbinddt typ G g)))
  (fmap F (compose (ap G))
     (fmap F (precompose (mbinddt term G g))
        (fmap F (ap G) (pure (F ‚àò G) tm_tap)))) &lt;‚ãÜ&gt;
mbinddt term F f t &lt;‚ãÜ&gt; mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkda">compose near (pure (F ‚àò G) (@tm_tap C)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt term G g)))
  (pure F tm_tap) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0 =
fmap F (compose (precompose (mbinddt typ G g)))
  (fmap F (compose (ap G))
     ((fmap F (precompose (mbinddt term G g))
       ‚àò fmap F (ap G)) (pure (F ‚àò G) tm_tap))) &lt;‚ãÜ&gt;
mbinddt term F f t &lt;‚ãÜ&gt; mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkdb"><span class="nb">rewrite</span> (fun_fmap_fmap F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt term G g)))
  (pure F tm_tap) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0 =
fmap F (compose (precompose (mbinddt typ G g)))
  (fmap F (compose (ap G))
     (fmap F (precompose (mbinddt term G g) ‚àò ap G)
        (pure (F ‚àò G) tm_tap))) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkdc">compose near (pure (F ‚àò G) (@tm_tap C)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt term G g)))
  (pure F tm_tap) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0 =
fmap F (compose (precompose (mbinddt typ G g)))
  ((fmap F (compose (ap G))
    ‚àò fmap F (precompose (mbinddt term G g) ‚àò ap G))
     (pure (F ‚àò G) tm_tap)) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkdd"><span class="nb">rewrite</span> (fun_fmap_fmap F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt term G g)))
  (pure F tm_tap) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0 =
fmap F (compose (precompose (mbinddt typ G g)))
  (fmap F
     (compose (ap G)
      ‚àò (precompose (mbinddt term G g) ‚àò ap G))
     (pure (F ‚àò G) tm_tap)) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkde">compose near (pure (F ‚àò G) (@tm_tap C)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt term G g)))
  (pure F tm_tap) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0 =
(fmap F (compose (precompose (mbinddt typ G g)))
 ‚àò fmap F
     (compose (ap G)
      ‚àò (precompose (mbinddt term G g) ‚àò ap G)))
  (pure (F ‚àò G) tm_tap) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkdf"><span class="nb">rewrite</span> (fun_fmap_fmap F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt term G g)))
  (pure F tm_tap) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0 =
fmap F
  (compose (precompose (mbinddt typ G g))
   ‚àò (compose (ap G)
      ‚àò (precompose (mbinddt term G g) ‚àò ap G)))
  (pure (F ‚àò G) tm_tap) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke0">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F (compose (compose (mbinddt term G g)))
  (pure F tm_tap) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0 =
fmap F
  (compose (precompose (mbinddt typ G g))
   ‚àò (compose (ap G)
      ‚àò (precompose (mbinddt term G g) ‚àò ap G)))
  (pure F (pure G tm_tap)) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke1"><span class="nb">rewrite</span> (app_pure_natural F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure F (compose (mbinddt term G g) ‚àò tm_tap) &lt;‚ãÜ&gt;
mbinddt term F f t &lt;‚ãÜ&gt; mbinddt typ F f t0 =
fmap F
  (compose (precompose (mbinddt typ G g))
   ‚àò (compose (ap G)
      ‚àò (precompose (mbinddt term G g) ‚àò ap G)))
  (pure F (pure G tm_tap)) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke2"><span class="nb">rewrite</span> (app_pure_natural F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
fmap F (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure F (compose (mbinddt term G g) ‚àò tm_tap) &lt;‚ãÜ&gt;
mbinddt term F f t &lt;‚ãÜ&gt; mbinddt typ F f t0 =
pure F
  ((compose (precompose (mbinddt typ G g))
    ‚àò (compose (ap G)
       ‚àò (precompose (mbinddt term G g) ‚àò ap G)))
     (pure G tm_tap)) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;mbinddt_morphism&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Set Keyed Unification</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke3"><span class="kn">Lemma</span> <span class="nf">mbinddt_morphism_typ</span> :
  <span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{ApplicativeMorphism F G œï}
    `(f : <span class="kr">forall</span> <span class="nv">k</span>, list K2 * A -&gt; F (SystemF k B)),
    œï (typ B) ‚àò mbinddt typ F f =
    mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> =&gt; œï (SystemF k B) ‚àò f k).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> <span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F) (<span class="nv">H3</span> : Fmap G) (<span class="nv">H4</span> : Pure G)
  (<span class="nv">H5</span> : Mult G) (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A),
ApplicativeMorphism F G œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
œï (typ B) ‚àò mbinddt typ F f =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> <span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F) (<span class="nv">H3</span> : Fmap G) (<span class="nv">H4</span> : Pure G)
  (<span class="nv">H5</span> : Mult G) (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A),
ApplicativeMorphism F G œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
œï (typ B) ‚àò mbinddt typ F f =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke5"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B) ‚àò mbinddt typ F f =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke6">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œï (typ B) ‚àò mbinddt typ F f) t =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke7"><span class="nb">generalize dependent</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
(œï (typ B) ‚àò mbinddt typ F f) t =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke8"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke9"><span class="nb">induction</span> t; <span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B) (mbinddt typ F f (ty_c b)) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (ty_c b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chkea" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chkea"><hr></label><div class="goal-conclusion">œï (typ B) (mbinddt typ F f (ty_v v)) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (ty_v v)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chkeb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t1) =
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t2) =
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chkeb"><hr></label><div class="goal-conclusion">œï (typ B) (mbinddt typ F f (t1 ‚üπ t2)) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (t1 ‚üπ t2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chkec" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t) =
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chkec"><hr></label><div class="goal-conclusion">œï (typ B) (mbinddt typ F f (<span class="kr">‚àÄ</span> <span class="nv">t</span>)) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (<span class="kr">‚àÄ</span> <span class="nv">t</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chked">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B) (mbinddt typ F f (ty_c b)) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (ty_c b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkee"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B) (pure F (ty_c b)) = pure G (ty_c b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkef"><span class="nb">rewrite</span> (appmor_pure F G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure G (ty_c b) = pure G (ty_c b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B) (mbinddt typ F f (ty_v v)) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (ty_v v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t1) =
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t2) =
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B) (mbinddt typ F f (t1 ‚üπ t2)) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (t1 ‚üπ t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf2"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t1) =
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t2) =
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B)
  (pure F ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
   mbinddt typ F f t2) =
pure G ty_ar &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t1 &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf3"><span class="nb">rewrite</span> &lt;- IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t1) =
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t2) =
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B)
  (pure F ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
   mbinddt typ F f t2) =
pure G ty_ar &lt;‚ãÜ&gt; œï (typ B) (mbinddt typ F f t1) &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf4"><span class="nb">clear</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t2) =
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B)
  (pure F ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
   mbinddt typ F f t2) =
pure G ty_ar &lt;‚ãÜ&gt; œï (typ B) (mbinddt typ F f t1) &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf5"><span class="nb">rewrite</span> &lt;- IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t2) =
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B)
  (pure F ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
   mbinddt typ F f t2) =
pure G ty_ar &lt;‚ãÜ&gt; œï (typ B) (mbinddt typ F f t1) &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf6"><span class="nb">clear</span> IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B)
  (pure F ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
   mbinddt typ F f t2) =
pure G ty_ar &lt;‚ãÜ&gt; œï (typ B) (mbinddt typ F f t1) &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf7"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B -&gt; typ B)
  (pure F ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1) &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F f t2) =
pure G ty_ar &lt;‚ãÜ&gt; œï (typ B) (mbinddt typ F f t1) &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf8"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B -&gt; typ B -&gt; typ B) (pure F ty_ar) &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F f t1) &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F f t2) =
pure G ty_ar &lt;‚ãÜ&gt; œï (typ B) (mbinddt typ F f t1) &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf9"><span class="nb">rewrite</span> (appmor_pure F G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure G ty_ar &lt;‚ãÜ&gt; œï (typ B) (mbinddt typ F f t1) &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F f t2) =
pure G ty_ar &lt;‚ãÜ&gt; œï (typ B) (mbinddt typ F f t1) &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkfa">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B) (mbinddt typ F f (<span class="kr">‚àÄ</span> <span class="nv">t</span>)) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (<span class="kr">‚àÄ</span> <span class="nv">t</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkfb"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B)
  (pure F ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; preincr [KType] (f k))
     t) =
pure G ty_univ &lt;‚ãÜ&gt;
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt;
   preincr [KType] (œï (SystemF k B) ‚óã f k)) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkfc"><span class="nb">rewrite</span> &lt;- IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B)
  (pure F ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; preincr [KType] (f k))
     t) =
pure G ty_univ &lt;‚ãÜ&gt;
œï (typ B)
  (mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KType]) t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkfd"><span class="nb">clear</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B)
  (pure F ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; preincr [KType] (f k))
     t) =
pure G ty_univ &lt;‚ãÜ&gt;
œï (typ B)
  (mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KType]) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkfe"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B -&gt; typ B) (pure F ty_univ) &lt;‚ãÜ&gt;
œï (typ B)
  (mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; preincr [KType] (f k))
     t) =
pure G ty_univ &lt;‚ãÜ&gt;
œï (typ B)
  (mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KType]) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkff"><span class="nb">rewrite</span> (appmor_pure F G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure G ty_univ &lt;‚ãÜ&gt;
œï (typ B)
  (mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; preincr [KType] (f k))
     t) =
pure G ty_univ &lt;‚ãÜ&gt;
œï (typ B)
  (mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KType]) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk100"><span class="kn">Lemma</span> <span class="nf">mbinddt_morphism_term</span> :
  <span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{ApplicativeMorphism F G œï}
    `(f : <span class="kr">forall</span> <span class="nv">k</span>, list K2 * A -&gt; F (SystemF k B)),
    œï (term B) ‚àò mbinddt term F f =
    mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> =&gt; œï (SystemF k B) ‚àò f k).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> <span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F) (<span class="nv">H3</span> : Fmap G) (<span class="nv">H4</span> : Pure G)
  (<span class="nv">H5</span> : Mult G) (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A),
ApplicativeMorphism F G œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
œï (term B) ‚àò mbinddt term F f =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk101"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> <span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F) (<span class="nv">H3</span> : Fmap G) (<span class="nv">H4</span> : Pure G)
  (<span class="nv">H5</span> : Mult G) (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A),
ApplicativeMorphism F G œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
œï (term B) ‚àò mbinddt term F f =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk102"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) ‚àò mbinddt term F f =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk103">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œï (term B) ‚àò mbinddt term F f) t =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk104"><span class="nb">generalize dependent</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
(œï (term B) ‚àò mbinddt term F f) t =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk105"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk106"><span class="nb">induction</span> t; <span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) (mbinddt term F f (tm_var v)) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (tm_var v)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk107" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t0) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk107"><hr></label><div class="goal-conclusion">œï (term B) (mbinddt term F f (<span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0)) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (<span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk108" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t1) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t2) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk108"><hr></label><div class="goal-conclusion">œï (term B) (mbinddt term F f (t1 @ t2)) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (t1 @ t2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk109" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk109"><hr></label><div class="goal-conclusion">œï (term B) (mbinddt term F f (Œõ t)) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (Œõ t)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk10a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk10a"><hr></label><div class="goal-conclusion">œï (term B) (mbinddt term F f (t @@ t0)) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (t @@ t0)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk10b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) (mbinddt term F f (tm_var v)) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (tm_var v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk10c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t0) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) (mbinddt term F f (<span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0)) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (<span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk10d"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t0) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure F tm_abs &lt;‚ãÜ&gt; bind_type F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k) t &lt;‚ãÜ&gt;
   mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KTerm])
     t0) =
pure G tm_abs &lt;‚ãÜ&gt;
bind_type G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t &lt;‚ãÜ&gt;
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k ‚àò incr [KTerm])
  t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk10e"><span class="nb">rewrite</span> &lt;- IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t0) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure F tm_abs &lt;‚ãÜ&gt; bind_type F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k) t &lt;‚ãÜ&gt;
   mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KTerm])
     t0) =
pure G tm_abs &lt;‚ãÜ&gt;
bind_type G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KTerm]) t0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk10f"><span class="nb">clear</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure F tm_abs &lt;‚ãÜ&gt; bind_type F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k) t &lt;‚ãÜ&gt;
   mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KTerm])
     t0) =
pure G tm_abs &lt;‚ãÜ&gt;
bind_type G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KTerm]) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk110"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B -&gt; term B -&gt; term B) (pure F tm_abs) &lt;‚ãÜ&gt;
œï (typ B) (bind_type F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k) t) &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KTerm])
     t0) =
pure G tm_abs &lt;‚ãÜ&gt;
bind_type G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KTerm]) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk111"><span class="nb">rewrite</span> (appmor_pure F G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure G tm_abs &lt;‚ãÜ&gt;
œï (typ B) (bind_type F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k) t) &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KTerm])
     t0) =
pure G tm_abs &lt;‚ãÜ&gt;
bind_type G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KTerm]) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk112"><span class="nb">change</span> (bind_type <span class="nl">?F</span> <span class="nl">?f</span>) <span class="kr">with</span> (mbinddt typ F f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure G tm_abs &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k) t) &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KTerm])
     t0) =
pure G tm_abs &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KTerm]) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk113">compose near t on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure G tm_abs &lt;‚ãÜ&gt;
(œï (typ B) ‚àò mbinddt typ F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k)) t &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KTerm])
     t0) =
pure G tm_abs &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KTerm]) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk114"><span class="nb">rewrite</span> (mbinddt_morphism_typ F G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure G tm_abs &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k) t &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KTerm])
     t0) =
pure G tm_abs &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KTerm]) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk115">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t1) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t2) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) (mbinddt term F f (t1 @ t2)) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (t1 @ t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk116"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t1) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t2) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure F tm_app &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
   mbinddt term F f t2) =
pure G tm_app &lt;‚ãÜ&gt;
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k)
  t1 &lt;‚ãÜ&gt;
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k)
  t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk117"><span class="nb">rewrite</span> &lt;- IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t1) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t2) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure F tm_app &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
   mbinddt term F f t2) =
pure G tm_app &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t1) &lt;‚ãÜ&gt;
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k)
  t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk118"><span class="nb">clear</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t2) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure F tm_app &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
   mbinddt term F f t2) =
pure G tm_app &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t1) &lt;‚ãÜ&gt;
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k)
  t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk119"><span class="nb">rewrite</span> &lt;- IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t2) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure F tm_app &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
   mbinddt term F f t2) =
pure G tm_app &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t1) &lt;‚ãÜ&gt;
œï (term B) (mbinddt term F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk11a"><span class="nb">clear</span> IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure F tm_app &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
   mbinddt term F f t2) =
pure G tm_app &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t1) &lt;‚ãÜ&gt;
œï (term B) (mbinddt term F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk11b"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B -&gt; term B)
  (pure F tm_app &lt;‚ãÜ&gt; mbinddt term F f t1) &lt;‚ãÜ&gt;
œï (term B) (mbinddt term F f t2) =
pure G tm_app &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t1) &lt;‚ãÜ&gt;
œï (term B) (mbinddt term F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk11c"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B -&gt; term B -&gt; term B) (pure F tm_app) &lt;‚ãÜ&gt;
œï (term B) (mbinddt term F f t1) &lt;‚ãÜ&gt;
œï (term B) (mbinddt term F f t2) =
pure G tm_app &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t1) &lt;‚ãÜ&gt;
œï (term B) (mbinddt term F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk11d"><span class="nb">rewrite</span> (appmor_pure F G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure G tm_app &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t1) &lt;‚ãÜ&gt;
œï (term B) (mbinddt term F f t2) =
pure G tm_app &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t1) &lt;‚ãÜ&gt;
œï (term B) (mbinddt term F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk11e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) (mbinddt term F f (Œõ t)) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (Œõ t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk11f"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure F tm_tab &lt;‚ãÜ&gt;
   mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KType]) t) =
pure G tm_tab &lt;‚ãÜ&gt;
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k ‚àò incr [KType])
  t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk120"><span class="nb">rewrite</span> &lt;- IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure F tm_tab &lt;‚ãÜ&gt;
   mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KType]) t) =
pure G tm_tab &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KType]) t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk121"><span class="nb">clear</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure F tm_tab &lt;‚ãÜ&gt;
   mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KType]) t) =
pure G tm_tab &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KType]) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk122"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B -&gt; term B) (pure F tm_tab) &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KType]) t) =
pure G tm_tab &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KType]) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk123"><span class="nb">rewrite</span> (appmor_pure F G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure G tm_tab &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; f k ‚àò incr [KType]) t) =
pure G tm_tab &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã incr [KType]) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk124">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) (mbinddt term F f (t @@ t0)) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (t @@ t0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk125"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure F tm_tap &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
   bind_type F f t0) =
pure G tm_tap &lt;‚ãÜ&gt;
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t &lt;‚ãÜ&gt;
bind_type G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk126"><span class="nb">rewrite</span> &lt;- IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure F tm_tap &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
   bind_type F f t0) =
pure G tm_tap &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
bind_type G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk127"><span class="nb">clear</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure F tm_tap &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
   bind_type F f t0) =
pure G tm_tap &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
bind_type G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk128"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B -&gt; typ B -&gt; term B) (pure F tm_tap) &lt;‚ãÜ&gt;
œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
œï (typ B) (bind_type F f t0) =
pure G tm_tap &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
bind_type G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk129"><span class="nb">rewrite</span> (appmor_pure F G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure G tm_tap &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
œï (typ B) (bind_type F f t0) =
pure G tm_tap &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
bind_type G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk12a"><span class="nb">change</span> (bind_type <span class="nl">?F</span> <span class="nl">?f</span>) <span class="kr">with</span> (mbinddt typ F f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure G tm_tap &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F f t0) =
pure G tm_tap &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk12b">compose near t0 on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure G tm_tap &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
(œï (typ B) ‚àò mbinddt typ F f) t0 =
pure G tm_tap &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk12c"><span class="nb">rewrite</span> (mbinddt_morphism_typ F G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure G tm_tap &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k) t0 =
pure G tm_tap &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Unset Keyed Unification</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;mbinddt_comp_mret&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk12d"><span class="kn">Lemma</span> <span class="nf">mbinddt_comp_mret_typ</span> :
  <span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Applicative F}
    `(f : <span class="kr">forall</span> <span class="nv">k</span>, list K2 * A -&gt; F (SystemF k B)),
    mbinddt typ F f ‚àò mret SystemF KType = f KType ‚àò pair nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
mbinddt typ F f ‚àò mret SystemF KType =
f KType ‚àò pair []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk12e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
mbinddt typ F f ‚àò mret SystemF KType =
f KType ‚àò pair []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk12f"><span class="kn">Lemma</span> <span class="nf">mbinddt_comp_mret_term</span> :
  <span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Applicative F}
    `(f : <span class="kr">forall</span> <span class="nv">k</span>, list K2 * A -&gt; F (SystemF k B)),
    mbinddt term F f ‚àò mret SystemF KTerm = f KTerm ‚àò pair nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
mbinddt term F f ‚àò mret SystemF KTerm =
f KTerm ‚àò pair []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk130"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
mbinddt term F f ‚àò mret SystemF KTerm =
f KTerm ‚àò pair []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk131"><span class="kn">Corollary</span> <span class="nf">mbinddt_comp_mret_F</span> :
  <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">F</span> `{Applicative F}
    `(f : <span class="kr">forall</span> <span class="nv">k</span>, (list K2) * A -&gt; F (SystemF k B)),
    mbinddt (W := list K2) (T := SystemF) (SystemF k) F f ‚àò mret SystemF k = (<span class="kr">fun</span> <span class="nv">a</span> =&gt; f k (∆µ, a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">k</span> : K) (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap F)
  (<span class="nv">H0</span> : Pure F) (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k0</span> : K, list K2 * A -&gt; F (SystemF k0 B)),
mbinddt (SystemF k) F f ‚àò mret SystemF k =
f k ‚óã pair ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk132"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">k</span> : K) (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap F)
  (<span class="nv">H0</span> : Pure F) (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k0</span> : K, list K2 * A -&gt; F (SystemF k0 B)),
mbinddt (SystemF k) F f ‚àò mret SystemF k =
f k ‚óã pair ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk133"><span class="nb">intro</span> k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
mbinddt (SystemF k) F f ‚àò mret SystemF k =
f k ‚óã pair ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk134"><span class="nb">destruct</span> k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
mbinddt (SystemF KType) F f ‚àò mret SystemF KType =
f KType ‚óã pair ∆µ</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
mbinddt (SystemF KTerm) F f ‚àò mret SystemF KTerm =
f KTerm ‚óã pair ∆µ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk135">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
mbinddt (SystemF KType) F f ‚àò mret SystemF KType =
f KType ‚óã pair ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> mbinddt_comp_mret_typ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk136">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
mbinddt (SystemF KTerm) F f ‚àò mret SystemF KTerm =
f KTerm ‚óã pair ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> mbinddt_comp_mret_term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;DTPreModule&gt;&gt; instances *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">DTP_typ</span>: DTPreModule (list K2) typ SystemF :=
  {| dtp_mbinddt_mret := @mbinddt_mret_typ;
     dtp_mbinddt_mbinddt := @mbinddt_mbinddt_typ;
     dtp_mbinddt_morphism := @mbinddt_morphism_typ;
  |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">DTP_term</span>: DTPreModule (list K2) term SystemF :=
  {| dtp_mbinddt_mret := @mbinddt_mret_term;
     dtp_mbinddt_mbinddt := @mbinddt_mbinddt_term;
     dtp_mbinddt_morphism := @mbinddt_morphism_term;
  |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span>: <span class="kr">forall</span> <span class="nv">k</span>, DTPreModule (list K2) (SystemF k) SystemF :=
  <span class="kr">fun</span> <span class="nv">k</span> =&gt; <span class="kr">match</span> k <span class="kr">with</span>
        | KType =&gt; DTP_typ
        | KTerm =&gt; DTP_term
        <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span>: DTM (list K2) SystemF :=
  {| dtm_mbinddt_comp_mret := mbinddt_comp_mret_F;
  |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * System F type system and operational rules *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;Œî ; Œì ‚ä¢ t : œÑ&quot;</span> (<span class="kn">at level</span> <span class="mi">90</span>, t <span class="kn">at level</span> <span class="mi">99</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Tealeaves.Classes.Setlike.Functor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> LN.AtomSet.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> LN.AssocList.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Contexts and well-formedness predicates *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="sd">(** *** Context of type variables *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">kind_ctx</span> := alist unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Context of term variables *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">type_ctx</span> := alist (typ LN).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Well-formedness for kinding contexts *)</span>
<span class="sd">(** A kinding context is well-formed when its keys, i.e. type</span>
<span class="sd">    variables, are unique. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ok_kind_ctx</span> : kind_ctx -&gt; <span class="kt">Prop</span> := uniq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Well-formedness of type expressions in a kinding context *)</span>
<span class="sd">(** A type is well-formed in a kinding context &lt;&lt;Œî&gt;&gt; when all of its</span>
<span class="sd">    type variables appear in Œî and the type is locally closed. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ok_type</span> : kind_ctx -&gt; typ LN -&gt; <span class="kt">Prop</span> :=
  <span class="kr">fun</span> <span class="nv">Œî</span> <span class="nv">œÑ</span> =&gt; scoped typ KType œÑ (domset Œî) /\ locally_closed typ KType œÑ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Well-formedness for typing contexts *)</span>
<span class="sd">(** A typing context &lt;&lt;Œì&gt;&gt; is well-formed in kinding context &lt;&lt;Œî&gt;&gt;</span>
<span class="sd">    when the keys of &lt;&lt;Œì&gt;&gt; (i.e. term variables) are unique, and each</span>
<span class="sd">    associated type is itself well-formed in context &lt;&lt;Œî&gt;&gt;. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ok_type_ctx</span> : kind_ctx -&gt; type_ctx -&gt; <span class="kt">Prop</span> :=
  <span class="kr">fun</span> <span class="nv">Œî</span> <span class="nv">Œì</span> =&gt; uniq Œì /\ <span class="kr">forall</span> <span class="nv">œÑ</span>, œÑ ‚àà range Œì -&gt; ok_type Œî œÑ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Well-formedness of term expressions in context *)</span>
<span class="sd">(** A term &lt;&lt;t&gt;&gt; is well-formed in contexts &lt;&lt;Œî&gt;&gt; and &lt;&lt;Œì&gt;&gt; when its</span>
<span class="sd">    type variables are declared in &lt;&lt;Œî&gt;&gt;, its term variables are</span>
<span class="sd">    declared in &lt;&lt;Œì&gt;&gt;, and it is locally closed with respect to both</span>
<span class="sd">    kinds of variables. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ok_term</span> : kind_ctx -&gt; type_ctx -&gt; term LN -&gt; <span class="kt">Prop</span> :=
  <span class="kr">fun</span> <span class="nv">Œî</span> <span class="nv">Œì</span> <span class="nv">t</span> =&gt; scoped term KType t (domset Œî) /\
            scoped term KTerm t (domset Œì) /\
            locally_closed term KTerm t /\
            locally_closed term KType t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Typing judgments *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> (<span class="nv">Œî</span> : kind_ctx) (<span class="nv">Œì</span> : type_ctx) (<span class="nv">œÑ</span> : typ LN).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Judgment</span> : kind_ctx -&gt; type_ctx -&gt; term LN -&gt; typ LN -&gt; <span class="kt">Prop</span> :=
| j_var :
    <span class="kr">forall</span> <span class="nv">Œî</span> <span class="nv">Œì</span> <span class="nv">x</span> <span class="nv">œÑ</span>,
      ok_kind_ctx Œî -&gt;
      ok_type_ctx Œî Œì -&gt;
      (x, œÑ) ‚àà (Œì : list (atom * typ LN)) -&gt;
      (Œî ; Œì ‚ä¢ tm_var (Fr x) : œÑ)
| j_abs :
    <span class="kr">forall</span> <span class="nv">Œî</span> <span class="nv">Œì</span> <span class="nv">L</span> <span class="nv">t</span> <span class="nv">œÑ1</span> <span class="nv">œÑ2</span>,
      (<span class="kr">forall</span> <span class="nv">x</span>, ~ x ‚àà@ L  -&gt;
            Œî ; Œì ++ x ~ œÑ1 ‚ä¢ open term KTerm (tm_var (Fr x)) t : œÑ2) -&gt;
      (Œî ; Œì ‚ä¢ tm_abs œÑ1 t : ty_ar œÑ1 œÑ2)
| j_app :
    <span class="kr">forall</span> <span class="nv">Œî</span> <span class="nv">Œì</span> <span class="nv">t1</span> <span class="nv">t2</span> <span class="nv">œÑ1</span> <span class="nv">œÑ2</span>,
      (Œî ; Œì ‚ä¢ t1 : ty_ar œÑ1 œÑ2) -&gt;
      (Œî ; Œì ‚ä¢ t2 : œÑ1) -&gt;
      (Œî ; Œì ‚ä¢ tm_app t1 t2 : œÑ2)
| j_univ :
    <span class="kr">forall</span> <span class="nv">Œî</span> <span class="nv">Œì</span> <span class="nv">L</span> <span class="nv">œÑ</span> <span class="nv">t</span>,
      (<span class="kr">forall</span> <span class="nv">x</span>, ~ x ‚àà@ L -&gt;
            Œî ++ x ~ tt ; Œì ‚ä¢ open term KType (ty_v (Fr x)) t
                          : open typ KType (ty_v (Fr x)) œÑ) -&gt;
      (Œî ; Œì ‚ä¢ tm_tab t : ty_univ œÑ)
| j_inst :
    <span class="kr">forall</span> <span class="nv">Œî</span> <span class="nv">Œì</span> <span class="nv">t</span> <span class="nv">œÑ1</span> <span class="nv">œÑ2</span>,
      ok_type Œî œÑ1 -&gt;
      (Œî ; Œì ‚ä¢ t : ty_univ œÑ2) -&gt;
      (Œî ; Œì ‚ä¢ tm_tap t œÑ1 : open typ KType œÑ1 œÑ2)
<span class="kn">where</span> <span class="s2">&quot;Œî ; Œì ‚ä¢ t : œÑ&quot;</span> := (Judgment Œî Œì t œÑ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Values and reduction rules *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">value</span> : term LN -&gt; <span class="kt">Prop</span> :=
| val_abs : <span class="kr">forall</span> <span class="nv">T</span> <span class="nv">t</span>, value (tm_abs T t)
| val_tab : <span class="kr">forall</span> <span class="nv">t</span>, value (tm_tab t).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">red</span> : term LN -&gt; term LN -&gt; <span class="kt">Prop</span> :=
| red_app_l : <span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t1&#39;</span> <span class="nv">t2</span>,
    <span class="nb">red</span> t1 t1&#39; -&gt;
    <span class="nb">red</span> (tm_app t1 t2) (tm_app t1&#39; t2)
| red_app_r : <span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> <span class="nv">t2&#39;</span>,
    value t1 -&gt;
    <span class="nb">red</span> t2 t2&#39; -&gt;
    <span class="nb">red</span> (tm_app t1 t2) (tm_app t1 t2&#39;)
| red_abs : <span class="kr">forall</span> <span class="nv">T</span> <span class="nv">t1</span> <span class="nv">t2</span>,
    value t2 -&gt;
    <span class="nb">red</span> (tm_app (tm_abs T t1) t2) (open term KTerm t2 t1)
| red_tapl : <span class="kr">forall</span> <span class="nv">t</span> <span class="nv">t&#39;</span> <span class="nv">T</span>,
    <span class="nb">red</span> t t&#39; -&gt;
    <span class="nb">red</span> (tm_tap t T) (tm_tap t&#39; T)
| red_tab : <span class="kr">forall</span> <span class="nv">T</span> <span class="nv">t</span>,
    <span class="nb">red</span> (tm_tap (tm_tab t) T) (open term KType T t).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">preservation</span> := <span class="kr">forall</span> <span class="nv">t</span> <span class="nv">t&#39;</span> <span class="nv">œÑ</span>,
    (nil ; nil ‚ä¢ t : œÑ) -&gt;
    <span class="nb">red</span> t t&#39; -&gt;
    (nil ; nil ‚ä¢ t&#39; : œÑ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">progress</span> := <span class="kr">forall</span> <span class="nv">t</span> <span class="nv">œÑ</span>,
    (nil ; nil ‚ä¢ t : œÑ) -&gt;
    value t \/ <span class="kr">exists</span> <span class="nv">t&#39;</span>, <span class="nb">red</span> t t&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(*</span>
<span class="c">(** ** Example: Typing the polymorphic identity *)</span>
<span class="c">(******************************************************************************)</span>
<span class="c">Example polymorphic_identity_function :</span>
<span class="c">  (nil ; nil ‚ä¢ (Œõ Œª 0 ‚ãÖ 0) : (‚àÄ 0 ‚üπ 0)).</span>
<span class="c">Proof.</span>
<span class="c">  apply j_univ with (L := ‚àÖ). introv _.</span>
<span class="c">  cbn. apply j_abs with (L := ‚àÖ).</span>
<span class="c">  - introv _. apply j_var.</span>
<span class="c">    + auto with sysf_ctx.</span>
<span class="c">    + simpl_alist. apply ok_tmv_tm_one.</span>
<span class="c">      unfold ok_type, scoped_env, scoped.</span>
<span class="c">      autorewrite with sysf_rw tea_rw_dom.</span>
<span class="c">      split; [fsetdec | apply lc_ty_ty_Fr].</span>
<span class="c">    + simpl_alist. now autorewrite with tea_list.</span>
<span class="c">Qed.</span>
<span class="c">*)</span></span></pre>
</div>
</div></body>
</html>
