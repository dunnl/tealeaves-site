<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>Formalizing STLC with Tealeaves</title>
<link rel="stylesheet" href="../alectryon.css" type="text/css" />
<link rel="stylesheet" href="../docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="../pygments.css" type="text/css" />
<script type="text/javascript" src="../alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="formalizing-stlc-with-tealeaves">
<h1 class="title">Formalizing STLC with Tealeaves</h1>
<h2 class="subtitle" id="kleisli-presentation">Kleisli presentation</h2>

<p>This file gives a tutorial on proving the decorated traversable monad
laws the for the syntax of the simply-typed lambda calculus (STLC).</p>
<div class="contents topic" id="table-of-contents">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#imports-and-setup" id="toc-entry-1">Imports and setup</a></li>
<li><a class="reference internal" href="#definition-of-binddt" id="toc-entry-2">Definition of binddt</a></li>
<li><a class="reference internal" href="#some-rewriting-principles-for-binddt" id="toc-entry-3">Some rewriting principles for binddt</a></li>
<li><a class="reference internal" href="#an-overview-of-the-dtm-axioms" id="toc-entry-4">An overview of the DTM axioms</a><ul>
<li><a class="reference internal" href="#composition-with-unit-left-unit-law" id="toc-entry-5">Composition with unit (left unit law)</a></li>
<li><a class="reference internal" href="#identity-law-right-unit-law" id="toc-entry-6">Identity law (right unit law)</a></li>
<li><a class="reference internal" href="#composition-law" id="toc-entry-7">Composition law</a></li>
<li><a class="reference internal" href="#applicative-homomorphism-law" id="toc-entry-8">Applicative homomorphism law</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="imports-and-setup">
<h1><a class="toc-backref" href="#toc-entry-1">Imports and setup</a></h1>
<p>Since we are using the Kleisli typeclass hierarchy, we import modules under
the namespaces <tt class="docutils literal">Classes.Kleisli</tt> and <tt class="docutils literal">Theory.Kleisli.</tt></p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Export</span>
  Backends.LN
  <span class="c">(* Locally nameless infrastructure *)</span>
  Classes.Kleisli.DT.Monad
  <span class="c">(* DTM definition *)</span>
  Data.Natural
  <span class="c">(* Monoid of natural numbers *)</span>
  Functors.List
  <span class="c">(* List functor *)</span>
  Classes.Kleisli.DT.Functor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* foldMapd operation *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> DT.Functor.Notations. <span class="c">(* ‚ààd *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Monoid.Notations. <span class="c">(* ∆µ and ‚óè *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> Classes.Kleisli.DT.Monad.Derived. <span class="c">(* DTM sub-instances *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> Applicative.Notations. <span class="c">(* &lt;‚ãÜ&gt; *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> DT.Monad.Notations. <span class="c">(* ‚ãÜdtm *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> List.ListNotations. <span class="c">(* [] :: *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> LN.Notations. <span class="c">(* operations *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> LN.AtomSet.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> LN.AssocList.Notations. <span class="c">(* one, ~ *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> Product.Notations. <span class="c">(* √ó *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> Setlike.Functor.Notations. <span class="c">(* ‚àà *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable Variables</span> <span class="nf">G</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Set Implicit Arguments</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Language definition *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">base_typ</span> : <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">typ</span> :=
| base : base_typ -&gt; typ
| arr : typ -&gt; typ -&gt; typ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">base</span> : base_typ &gt;-&gt; typ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">term</span> (<span class="nv">v</span> : <span class="kt">Type</span>) :=
| tvar : v -&gt; term v
| lam : typ -&gt; term v -&gt; term v
| app : term v -&gt; term v -&gt; term v.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Notations and automation *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Notations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;Œª&#39;&quot;</span> := (lam) (<span class="kn">at level</span> <span class="mi">45</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ t1 ]@[ t2 ]&quot;</span> := (app t1 t2) (<span class="kn">at level</span> <span class="mi">80</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A ‚üπ B&quot;</span> := (arr A B) (<span class="kn">at level</span> <span class="mi">40</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Notations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span>: Return term := tvar.</span></span></pre></div>
<div class="section" id="definition-of-binddt">
<h1><a class="toc-backref" href="#toc-entry-2">Definition of binddt</a></h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">binddt_term</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) `{Fmap G} `{Pure G} `{Mult G}
    {v1 v2 : <span class="kt">Type</span>} (f : nat * v1 -&gt; G (term v2)) (t : term v1) : G (term v2) :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | tvar v =&gt; f (<span class="mi">0</span>, v)
  | lam œÑ body =&gt; pure G (lam œÑ) &lt;‚ãÜ&gt; binddt_term (preincr <span class="mi">1</span> f) body
  | app t1 t2 =&gt; pure G (@app v2) &lt;‚ãÜ&gt; binddt_term f t1 &lt;‚ãÜ&gt; binddt_term f t2
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span>: Binddt nat term term := @binddt_term.</span></span></pre></div>
<div class="section" id="some-rewriting-principles-for-binddt">
<h1><a class="toc-backref" href="#toc-entry-3">Some rewriting principles for binddt</a></h1>
<p>These definitional equalities help prove the composition law later.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">binddt_helpers</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable Variable</span> <span class="nf">F</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Applicative F}
      {v1 v2 v3 : <span class="kt">Type</span>}
      (f : nat * v1 -&gt; F (term v2)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;P&#39;&quot;</span> := pure.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;BD&#39;&quot;</span> := (binddt term).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk0"><span class="kn">Lemma</span> <span class="nf">binddt_lam</span> :
    <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ), BD F f ‚àò (@lam v1 œÑ) = (precompose (BD F (preincr <span class="mi">1</span> f)) ‚àò ap F ‚àò P F) (@lam v2 œÑ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>v1, v2, v3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * v1 -&gt; F (term v2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">œÑ</span> : typ,
BD F f ‚àò (<span class="kr">Œª</span>) œÑ =
(precompose (BD F (preincr <span class="mi">1</span> f)) ‚àò ap F ‚àò P F) ((<span class="kr">Œª</span>) œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>v1, v2, v3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * v1 -&gt; F (term v2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">œÑ</span> : typ,
BD F f ‚àò (<span class="kr">Œª</span>) œÑ =
(precompose (BD F (preincr <span class="mi">1</span> f)) ‚àò ap F ‚àò P F) ((<span class="kr">Œª</span>) œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2"><span class="kn">Lemma</span> <span class="nf">binddt_app</span> :
      compose (BD F f) ‚àò @app v1 = (compose (precompose (BD F f) ‚àò ap F) ‚àò precompose (BD F f) ‚àò ap F ‚àò P F) (@app v2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>v1, v2, v3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * v1 -&gt; F (term v2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">compose (BD F f) ‚àò app (v:=v1) =
(compose (precompose (BD F f) ‚àò ap F)
 ‚àò precompose (BD F f) ‚àò ap F ‚àò P F) (app (v:=v2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>v1, v2, v3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * v1 -&gt; F (term v2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">compose (BD F f) ‚àò app (v:=v1) =
(compose (precompose (BD F f) ‚àò ap F)
 ‚àò precompose (BD F f) ‚àò ap F ‚àò P F) (app (v:=v2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">binddt_helpers</span>.</span></span></pre></div>
<div class="section" id="an-overview-of-the-dtm-axioms">
<h1><a class="toc-backref" href="#toc-entry-4">An overview of the DTM axioms</a></h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">laws</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* Generalize over (Coq) variables used for object-level variables</span>
<span class="c">   and symbols for applicative homomorphisms. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable Variables</span> <span class="nf">v</span> œï.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">rewrite_with_bind_hyp</span> :=
    <span class="kr">match goal with</span>
    | H : <span class="kp">context</span>[binddt] |- _ =&gt; <span class="nb">rewrite</span> H
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">induction_on_term</span> :=
    <span class="kr">match goal with</span>
    | t : term <span class="nl">?v</span> |- _ =&gt; <span class="nb">induction</span> t
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">dtm_setup</span> :=
    <span class="nb">intros</span>; ext t; <span class="nb">unfold</span> id; induction_on_term; <span class="nb">cbn</span>.</span></span></pre><div class="section" id="composition-with-unit-left-unit-law">
<h2><a class="toc-backref" href="#toc-entry-5">Composition with unit (left unit law)</a></h2>
<p>The &quot;composition with unit&quot; law (or left unit law) establishes that
the atomic expression <code class="highlight coq"><span class="n">ret</span> <span class="n">term</span> <span class="n">v</span></code></p>
<ol class="arabic simple">
<li>consists just of variable <code class="highlight coq"><span class="n">v</span></code></li>
<li>inside an empty binding context</li>
</ol>
<p>In this law, <code class="highlight coq"><span class="n">ret</span> <span class="o">(</span><span class="n">list</span> <span class="n">Œ≤</span> <span class="o">√ó)</span></code> is the operation which lifts any <code class="highlight coq"><span class="n">v</span></code>
into an empty binding context to get <code class="highlight coq"><span class="o">([],</span> <span class="n">v</span><span class="o">)</span></code>. A simpler way of
writing the left unit law is then</p>
<p><code class="highlight coq"><span class="n">binddt</span> <span class="n">f</span> <span class="o">(</span><span class="n">ret</span> <span class="n">term</span> <span class="n">v</span><span class="o">)</span> <span class="o">=</span> <span class="n">f</span> <span class="o">([],</span> <span class="n">v</span><span class="o">)</span></code></p>
<p>The proof of this rule ought to follow merely from the definitions of
<code class="highlight coq"><span class="n">binddt</span></code> and <code class="highlight coq"><span class="n">ret</span></code>.  In the course of proofs about <code class="highlight coq"><span class="n">binddt</span> <span class="n">f</span> <span class="n">t</span></code> by
induction of the syntax of expression <code class="highlight coq"><span class="n">t</span></code>, the left unit law acts as
a base case.</p>
<pre class="alectryon-io highlight" id="dtm1"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">solve_dtm1</span> :=
    <span class="nb">intros</span>; <span class="bp">now</span> <span class="kp">try</span> ext var.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk4"><span class="kn">Theorem</span> <span class="nf">dtm1_stlc</span>:
    <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H1</span> : Fmap G) (<span class="nv">H2</span> : Pure G) (<span class="nv">H3</span> : Mult G), Applicative G -&gt;
       <span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G (term B),
         binddt term G f ‚àò ret term = f ‚àò ret (prod nat).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H1</span> : Fmap G)
  (<span class="nv">H2</span> : Pure G) (<span class="nv">H3</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G (term B),
binddt term G f ‚àò ret term = f ‚àò ret (prod nat)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H1</span> : Fmap G)
  (<span class="nv">H2</span> : Pure G) (<span class="nv">H3</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G (term B),
binddt term G f ‚àò ret term = f ‚àò ret (prod nat)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="identity-law-right-unit-law">
<h2><a class="toc-backref" href="#toc-entry-6">Identity law (right unit law)</a></h2>
<p>The identity law (or right unit law) establishes that applying the
substitution rule</p>
<p><code class="highlight coq"><span class="n">pure</span> <span class="n">F</span> <span class="o">‚àò</span> <span class="n">ret</span> <span class="n">term</span> <span class="o">‚àò</span> <span class="n">extract</span> <span class="o">((</span><span class="n">list</span> <span class="n">Œ≤</span><span class="o">)</span> <span class="o">√ó)</span></code></p>
<p>to each of the variables in expression <code class="highlight coq"><span class="n">t</span></code> acts as the pure effect on
<code class="highlight coq"><span class="n">t</span></code>. The substitution rule is the one which at each variable</p>
<ol class="arabic simple">
<li>throws away the binding context: <code class="highlight coq"><span class="n">list</span> <span class="n">Œ≤</span> <span class="o">*</span> <span class="n">v</span> <span class="o">-&gt;</span> <span class="n">v</span></code></li>
<li>coerces the variable into an atomic expression: <code class="highlight coq"><span class="n">v</span> <span class="o">-&gt;</span> <span class="n">term</span> <span class="n">v</span></code></li>
<li>and lifts the result into <code class="highlight coq"><span class="n">F</span></code> with the <code class="highlight coq"><span class="n">pure</span></code> effect: <code class="highlight coq"><span class="n">term</span> <span class="n">v</span> <span class="o">-&gt;</span> <span class="n">F</span> <span class="o">(</span><span class="n">term</span> <span class="n">v</span><span class="o">)</span></code></li>
</ol>
<pre class="alectryon-io highlight" id="dtm2"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable All Variables</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6"><span class="kn">Lemma</span> <span class="nf">dtm2_helper</span> : <span class="kr">forall</span> `{Monoid M} (m : M) `(f : A -&gt; B), preincr m (f ‚àò extract (M √ó)) = f ‚àò extract (M √ó).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">M</span> : <span class="kt">Type</span>) (<span class="nv">op</span> : Monoid_op M)
  (<span class="nv">unit0</span> : Monoid_unit M),
Monoid M -&gt;
<span class="kr">forall</span> (<span class="nv">m</span> : M) (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
preincr m (f ‚àò extract (prod M)) =
f ‚àò extract (prod M)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">M</span> : <span class="kt">Type</span>) (<span class="nv">op</span> : Monoid_op M)
  (<span class="nv">unit0</span> : Monoid_unit M),
Monoid M -&gt;
<span class="kr">forall</span> (<span class="nv">m</span> : M) (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
preincr m (f ‚àò extract (prod M)) =
f ‚àò extract (prod M)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">preincr m (f ‚àò extract (prod M)) =
f ‚àò extract (prod M)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9"><span class="nb">unfold</span> preincr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ‚àò extract (prod M) ‚àò incr m = f ‚àò extract (prod M)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka">reassociate -&gt;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ‚àò (extract (prod M) ‚àò incr m) = f ‚àò extract (prod M)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> (extract_incr).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb"><span class="kn">Theorem</span> <span class="nf">dtm2_stlc</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) (ret term ‚àò extract (prod nat)) = @id (term A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (ret term ‚àò extract (prod nat)) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (ret term ‚àò extract (prod nat)) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (ret term ‚àò extract (prod nat)) = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (ret term ‚àò extract (prod nat)) t = id t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf"><span class="nb">unfold</span> id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (ret term ‚àò extract (prod nat)) t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk10"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (ret term ‚àò extract (prod nat)) (tvar v) = tvar v</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) (ret term ‚àò extract (prod nat)) t0 = t0</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk11"><hr></label><div class="goal-conclusion">binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (ret term ‚àò extract (prod nat)) ((<span class="kr">Œª</span>) t t0) =
(<span class="kr">Œª</span>) t t0</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk12" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (ret term ‚àò extract (prod nat)) t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (ret term ‚àò extract (prod nat)) t2 = t2</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk12"><hr></label><div class="goal-conclusion">binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (ret term ‚àò extract (prod nat)) ([t1 ]@[ t2]) =
([t1 ]@[ t2])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk13">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (ret term ‚àò extract (prod nat)) 
  (tvar v) = tvar v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk14"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ret term ‚àò extract (prod nat)) (<span class="mi">0</span>, v) = tvar v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">fequal.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk15">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (ret term ‚àò extract (prod nat)) t0 = t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (ret term ‚àò extract (prod nat)) 
  ((<span class="kr">Œª</span>) t t0) = (<span class="kr">Œª</span>) t t0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk16"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (ret term ‚àò extract (prod nat)) t0 = t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) 
  ((<span class="kr">Œª</span>) t)
  (binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
     (preincr <span class="mi">1</span> (ret term ‚àò extract (prod nat))) t0) =
(<span class="kr">Œª</span>) t t0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">fequal; (<span class="nb">rewrite</span> dtm2_helper; <span class="nb">auto</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk17">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (ret term ‚àò extract (prod nat)) t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (ret term ‚àò extract (prod nat)) t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (ret term ‚àò extract (prod nat)) 
  ([t1 ]@[ t2]) = ([t1 ]@[ t2])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk18"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (ret term ‚àò extract (prod nat)) t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (ret term ‚àò extract (prod nat)) t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) 
  (app (v:=A))
  (binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
     (ret term ‚àò extract (prod nat)) t1)
  (binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
     (ret term ‚àò extract (prod nat)) t2) =
([t1 ]@[ t2])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">fequal; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">solve_dtm2_case</span> :=
    fequal; <span class="kp">repeat</span> <span class="nb">rewrite</span> dtm2_helper; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk19"><span class="kn">Theorem</span> <span class="nf">dtm2_stlc_automated</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) (ret term ‚àò extract (prod nat)) = @id (term A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
binddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (ret term ‚àò extract (prod nat)) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">dtm_setup; solve_dtm2_case.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="composition-law">
<h2><a class="toc-backref" href="#toc-entry-7">Composition law</a></h2>
<p>The composition law states the following:</p>
<p><code class="highlight coq"><span class="n">fmap</span> <span class="n">F</span> <span class="o">(</span><span class="n">binddt</span> <span class="n">g</span><span class="o">)</span> <span class="o">‚àò</span> <span class="n">binddt</span> <span class="n">f</span> <span class="o">=</span> <span class="n">binddt</span> <span class="o">(</span><span class="n">g</span> <span class="o">‚ãÜ</span> <span class="n">f</span><span class="o">)</span></code></p>
<p>The right-hand side may be written more explicitly as</p>
<p><code class="highlight coq"><span class="n">binddt</span> <span class="o">(</span><span class="kr">fun</span> <span class="o">'(</span><span class="n">w</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">fmap</span> <span class="n">F</span> <span class="o">(</span><span class="n">binddt</span> <span class="o">(</span><span class="n">F</span> <span class="o">:=</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">‚àò</span> <span class="n">incr</span> <span class="n">w</span><span class="o">))</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">x</span><span class="o">))))</span></code></p>
<p>This law is an analogue of the ordinary monad composition law</p>
<p><code class="highlight coq"><span class="n">bind</span> <span class="n">g</span> <span class="o">‚àò</span> <span class="n">bind</span> <span class="n">f</span> <span class="o">=</span> <span class="n">bind</span> <span class="o">(</span><span class="n">bind</span> <span class="n">g</span> <span class="o">‚àò</span> <span class="n">f</span><span class="o">)</span></code>.</p>
<p>Both are loosely of the form</p>
<p><code class="highlight coq"><span class="n">bind</span> <span class="n">g</span> <span class="o">‚àò</span> <span class="n">bind</span> <span class="n">f</span> <span class="o">=</span> <span class="n">bind</span> <span class="o">(</span><span class="n">g</span> <span class="o">‚àó</span> <span class="n">f</span><span class="o">)</span></code></p>
<p>A close comparison shows the rules differ in two respects:</p>
<ol class="arabic simple">
<li>The call to <code class="highlight coq"><span class="n">g</span></code> in <code class="highlight coq"><span class="n">bind</span> <span class="n">g</span></code> is replaced with a call to <code class="highlight coq"><span class="o">(</span><span class="n">g</span> <span class="o">‚àò</span> <span class="n">incr</span>
<span class="n">w</span><span class="o">)</span></code> where <code class="highlight coq"><span class="n">w</span></code> is the context seen by the function <code class="highlight coq"><span class="n">f</span></code>.</li>
<li>The call to <code class="highlight coq"><span class="n">binddt</span> <span class="o">(</span><span class="n">g</span> <span class="o">‚àò</span> <span class="n">incr</span> <span class="n">w</span><span class="o">)</span></code> is wrapped in <code class="highlight coq"><span class="n">fmap</span> <span class="n">F</span></code>. This is
required to map over the applicative effect of type <code class="highlight coq"><span class="n">F</span></code> generated
by the application of <code class="highlight coq"><span class="n">f</span></code>.</li>
</ol>
<pre class="alectryon-io highlight" id="dtm3"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;P&#39;&quot;</span> := pure.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;F&#39;&quot;</span> := fmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;BD&#39;&quot;</span> := (binddt term).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">dtm3_lhs_step</span> G1 :=
    <span class="kp">repeat</span> <span class="nb">rewrite</span> fmap_ap; <span class="c">(* Bring LHS &lt;&lt;fmap&gt;&gt; up to the constructor *)</span>
    <span class="nb">rewrite</span> (app_pure_natural G1). <span class="c">(* Fuse &lt;&lt;fmap&gt;&gt; and the &lt;&lt;pure (constructor)&gt;&gt; *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">dtm3_rhs_step</span> G2 G1 :=
    (<span class="nb">rewrite_strat</span> innermost (terms (ap_compose2 G2 G1)));
    <span class="kp">repeat</span> <span class="nb">rewrite</span> fmap_ap;
    <span class="nb">rewrite</span> (app_pure_natural G1);
    <span class="nb">rewrite</span> &lt;- ap_fmap;
    <span class="kp">repeat</span> <span class="nb">rewrite</span> fmap_ap;
    <span class="nb">rewrite</span> (app_pure_natural G1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Keyed Unification</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1a"><span class="kn">Theorem</span> <span class="nf">dtm3_stlc</span> :
    <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H1</span> : Fmap G1) (<span class="nv">H2</span> : Pure G1) (<span class="nv">H3</span> : Mult G1),
      Applicative G1 -&gt;
      <span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H5</span> : Fmap G2) (<span class="nv">H6</span> : Pure G2) (<span class="nv">H7</span> : Mult G2),
        Applicative G2 -&gt;
        <span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 (term C)) (<span class="nv">f</span> : nat * A -&gt; G1 (term B)),
          fmap G1 (binddt term G2 g) ‚àò binddt term G1 f = binddt term (G1 ‚àò G2) (g ‚ãÜdtm f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
  (<span class="nv">H1</span> : Fmap G1) (<span class="nv">H2</span> : Pure G1) (<span class="nv">H3</span> : Mult G1),
Applicative G1 -&gt;
<span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H5</span> : Fmap G2)
  (<span class="nv">H6</span> : Pure G2) (<span class="nv">H7</span> : Mult G2),
Applicative G2 -&gt;
<span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 (term C))
  (<span class="nv">f</span> : nat * A -&gt; G1 (term B)),
F G1 (BD G2 g) ‚àò BD G1 f = BD (G1 ‚àò G2) (g ‚ãÜdtm f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
  (<span class="nv">H1</span> : Fmap G1) (<span class="nv">H2</span> : Pure G1) (<span class="nv">H3</span> : Mult G1),
Applicative G1 -&gt;
<span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H5</span> : Fmap G2)
  (<span class="nv">H6</span> : Pure G2) (<span class="nv">H7</span> : Mult G2),
Applicative G2 -&gt;
<span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 (term C))
  (<span class="nv">f</span> : nat * A -&gt; G1 (term B)),
F G1 (BD G2 g) ‚àò BD G1 f = BD (G1 ‚àò G2) (g ‚ãÜdtm f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1c"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g) ‚àò BD G1 f = BD (G1 ‚àò G2) (g ‚ãÜdtm f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1d">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(F G1 (BD G2 g) ‚àò BD G1 f) t =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1e"><span class="nb">generalize dependent</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : nat * B -&gt; G2 (term C),
(F G1 (BD G2 g) ‚àò BD G1 f) t =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1f"><span class="nb">generalize dependent</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
(F G1 (BD G2 g) ‚àò BD G1 f) t =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk20"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t) = BD (G1 ‚àò G2) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk21"><span class="nb">induction</span> t; <span class="nb">intros</span> f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g) (BD G1 f (tvar v)) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) (tvar v)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk22" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B)) (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t0) = BD (G1 ‚àò G2) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk22"><hr></label><div class="goal-conclusion">F G1 (BD G2 g) (BD G1 f ((<span class="kr">Œª</span>) t t0)) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) ((<span class="kr">Œª</span>) t t0)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk23" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk23"><hr></label><div class="goal-conclusion">F G1 (BD G2 g) (BD G1 f ([t1 ]@[ t2])) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) ([t1 ]@[ t2])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk24">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g) (BD G1 f (tvar v)) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) (tvar v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk25"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g) (f (<span class="mi">0</span>, v)) =
F G1 (BD G2 (preincr <span class="mi">0</span> g)) (f (<span class="mi">0</span>, v))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk26"><span class="nb">change</span> (preincr <span class="mi">0</span> g) <span class="kr">with</span> (preincr ∆µ g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g) (f (<span class="mi">0</span>, v)) =
F G1 (BD G2 (preincr ∆µ g)) (f (<span class="mi">0</span>, v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> Decorated.Monad.preincr_zero.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk27">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t0) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g) (BD G1 f ((<span class="kr">Œª</span>) t t0)) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) ((<span class="kr">Œª</span>) t t0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk28"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t0) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g)
  (P G1 ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G1 (preincr <span class="mi">1</span> f) t0) =
P (G1 ‚àò G2) ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt;
BD (G1 ‚àò G2) (preincr <span class="mi">1</span> (g ‚ãÜdtm f)) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk29"><span class="nb">rewrite</span> &lt;- (kcompose_dtm_preincr nat term).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t0) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g)
  (P G1 ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G1 (preincr <span class="mi">1</span> f) t0) =
P (G1 ‚àò G2) ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt;
BD (G1 ‚àò G2) (preincr <span class="mi">1</span> g ‚ãÜdtm preincr <span class="mi">1</span> f) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2a"><span class="nb">rewrite</span> &lt;- IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t0) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g)
  (P G1 ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G1 (preincr <span class="mi">1</span> f) t0) =
P (G1 ‚àò G2) ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt;
F G1 (BD G2 (preincr <span class="mi">1</span> g)) (BD G1 (preincr <span class="mi">1</span> f) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* left side *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2b"><span class="kp">repeat</span> <span class="nb">rewrite</span> fmap_ap. <span class="c">(* Bring LHS &lt;&lt;fmap&gt;&gt; up to the constructor *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t0) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (compose (BD G2 g)) (P G1 ((<span class="kr">Œª</span>) t)) &lt;‚ãÜ&gt;
BD G1 (preincr <span class="mi">1</span> f) t0 =
P (G1 ‚àò G2) ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt;
F G1 (BD G2 (preincr <span class="mi">1</span> g)) (BD G1 (preincr <span class="mi">1</span> f) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2c"><span class="nb">rewrite</span> (app_pure_natural G1). <span class="c">(* Fuse &lt;&lt;fmap&gt;&gt; and the &lt;&lt;pure (constructor)&gt;&gt; *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t0) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (BD G2 g ‚àò (<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G1 (preincr <span class="mi">1</span> f) t0 =
P (G1 ‚àò G2) ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt;
F G1 (BD G2 (preincr <span class="mi">1</span> g)) (BD G1 (preincr <span class="mi">1</span> f) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* right side, constructor *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2d">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t0) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (BD G2 g ‚àò (<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G1 (preincr <span class="mi">1</span> f) t0 =
P G1 (P G2 ((<span class="kr">Œª</span>) t)) &lt;‚ãÜ&gt;
F G1 (BD G2 (preincr <span class="mi">1</span> g)) (BD G1 (preincr <span class="mi">1</span> f) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* right side, first argument *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2e"><span class="nb">rewrite_strat</span> innermost (terms (ap_compose2 G2 G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t0) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (BD G2 g ‚àò (<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G1 (preincr <span class="mi">1</span> f) t0 =
F G1 (ap G2) (P G1 (P G2 ((<span class="kr">Œª</span>) t))) &lt;‚ãÜ&gt;
F G1 (BD G2 (preincr <span class="mi">1</span> g)) (BD G1 (preincr <span class="mi">1</span> f) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2f"><span class="nb">rewrite</span> (app_pure_natural G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t0) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (BD G2 g ‚àò (<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G1 (preincr <span class="mi">1</span> f) t0 =
P G1 (ap G2 (P G2 ((<span class="kr">Œª</span>) t))) &lt;‚ãÜ&gt;
F G1 (BD G2 (preincr <span class="mi">1</span> g)) (BD G1 (preincr <span class="mi">1</span> f) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk30"><span class="nb">rewrite</span> &lt;- ap_fmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t0) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (BD G2 g ‚àò (<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G1 (preincr <span class="mi">1</span> f) t0 =
F G1 (precompose (BD G2 (preincr <span class="mi">1</span> g)))
  (P G1 (ap G2 (P G2 ((<span class="kr">Œª</span>) t)))) &lt;‚ãÜ&gt;
BD G1 (preincr <span class="mi">1</span> f) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk31"><span class="nb">rewrite</span> (app_pure_natural G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t0) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (BD G2 g ‚àò (<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G1 (preincr <span class="mi">1</span> f) t0 =
P G1
  (precompose (BD G2 (preincr <span class="mi">1</span> g))
     (ap G2 (P G2 ((<span class="kr">Œª</span>) t)))) &lt;‚ãÜ&gt;
BD G1 (preincr <span class="mi">1</span> f) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk32">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g) (BD G1 f ([t1 ]@[ t2])) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) ([t1 ]@[ t2])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk33"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g)
  (P G1 (app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt; BD G1 f t2) =
P (G1 ‚àò G2) (app (v:=C)) &lt;‚ãÜ&gt;
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1 &lt;‚ãÜ&gt;
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk34"><span class="nb">rewrite</span> &lt;- IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g)
  (P G1 (app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt; BD G1 f t2) =
P (G1 ‚àò G2) (app (v:=C)) &lt;‚ãÜ&gt;
F G1 (BD G2 g) (BD G1 f t1) &lt;‚ãÜ&gt;
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk35"><span class="nb">rewrite</span> &lt;- IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g)
  (P G1 (app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt; BD G1 f t2) =
P (G1 ‚àò G2) (app (v:=C)) &lt;‚ãÜ&gt;
F G1 (BD G2 g) (BD G1 f t1) &lt;‚ãÜ&gt;
F G1 (BD G2 g) (BD G1 f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* left side *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk36"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> fmap_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (compose (compose (BD G2 g))) (P G1 (app (v:=B))) &lt;‚ãÜ&gt;
BD G1 f t1 &lt;‚ãÜ&gt; BD G1 f t2 =
P (G1 ‚àò G2) (app (v:=C)) &lt;‚ãÜ&gt;
F G1 (BD G2 g) (BD G1 f t1) &lt;‚ãÜ&gt;
F G1 (BD G2 g) (BD G1 f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk37"><span class="nb">rewrite</span> (app_pure_natural G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (compose (BD G2 g) ‚àò app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt;
BD G1 f t2 =
P (G1 ‚àò G2) (app (v:=C)) &lt;‚ãÜ&gt;
F G1 (BD G2 g) (BD G1 f t1) &lt;‚ãÜ&gt;
F G1 (BD G2 g) (BD G1 f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* right side *)</span>
      <span class="c">(* right side, constructor *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk38">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (compose (BD G2 g) ‚àò app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt;
BD G1 f t2 =
P G1 (P G2 (app (v:=C))) &lt;‚ãÜ&gt;
F G1 (BD G2 g) (BD G1 f t1) &lt;‚ãÜ&gt;
F G1 (BD G2 g) (BD G1 f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* right side, first argument *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk39"><span class="nb">rewrite_strat</span> innermost (terms (ap_compose2 G2 G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (compose (BD G2 g) ‚àò app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt;
BD G1 f t2 =
F G1 (ap G2) (P G1 (P G2 (app (v:=C)))) &lt;‚ãÜ&gt;
F G1 (BD G2 g) (BD G1 f t1) &lt;‚ãÜ&gt;
F G1 (BD G2 g) (BD G1 f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3a"><span class="kp">repeat</span> <span class="nb">rewrite</span> fmap_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (compose (BD G2 g) ‚àò app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt;
BD G1 f t2 =
F G1 (ap G2) (P G1 (P G2 (app (v:=C)))) &lt;‚ãÜ&gt;
F G1 (BD G2 g) (BD G1 f t1) &lt;‚ãÜ&gt;
F G1 (BD G2 g) (BD G1 f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3b"><span class="nb">rewrite</span> (app_pure_natural G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (compose (BD G2 g) ‚àò app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt;
BD G1 f t2 =
P G1 (ap G2 (P G2 (app (v:=C)))) &lt;‚ãÜ&gt;
F G1 (BD G2 g) (BD G1 f t1) &lt;‚ãÜ&gt;
F G1 (BD G2 g) (BD G1 f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3c"><span class="nb">rewrite</span> &lt;- ap_fmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (compose (BD G2 g) ‚àò app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt;
BD G1 f t2 =
F G1 (precompose (BD G2 g))
  (P G1 (ap G2 (P G2 (app (v:=C))))) &lt;‚ãÜ&gt; 
BD G1 f t1 &lt;‚ãÜ&gt; F G1 (BD G2 g) (BD G1 f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3d"><span class="kp">repeat</span> <span class="nb">rewrite</span> fmap_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (compose (BD G2 g) ‚àò app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt;
BD G1 f t2 =
F G1 (precompose (BD G2 g))
  (P G1 (ap G2 (P G2 (app (v:=C))))) &lt;‚ãÜ&gt; 
BD G1 f t1 &lt;‚ãÜ&gt; F G1 (BD G2 g) (BD G1 f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3e"><span class="nb">rewrite</span> (app_pure_natural G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (compose (BD G2 g) ‚àò app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt;
BD G1 f t2 =
P G1
  (precompose (BD G2 g) (ap G2 (P G2 (app (v:=C))))) &lt;‚ãÜ&gt;
BD G1 f t1 &lt;‚ãÜ&gt; F G1 (BD G2 g) (BD G1 f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* right side, second argument *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3f"><span class="nb">rewrite_strat</span> innermost (terms (ap_compose2 G2 G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (compose (BD G2 g) ‚àò app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt;
BD G1 f t2 =
F G1 (ap G2)
  (P G1
     (precompose (BD G2 g) (ap G2 (P G2 (app (v:=C))))) &lt;‚ãÜ&gt;
   BD G1 f t1) &lt;‚ãÜ&gt; F G1 (BD G2 g) (BD G1 f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk40"><span class="kp">repeat</span> <span class="nb">rewrite</span> fmap_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (compose (BD G2 g) ‚àò app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt;
BD G1 f t2 =
F G1 (compose (ap G2))
  (P G1
     (precompose (BD G2 g) (ap G2 (P G2 (app (v:=C)))))) &lt;‚ãÜ&gt;
BD G1 f t1 &lt;‚ãÜ&gt; F G1 (BD G2 g) (BD G1 f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk41"><span class="nb">rewrite</span> (app_pure_natural G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (compose (BD G2 g) ‚àò app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt;
BD G1 f t2 =
P G1
  (ap G2
   ‚àò precompose (BD G2 g) (ap G2 (P G2 (app (v:=C))))) &lt;‚ãÜ&gt;
BD G1 f t1 &lt;‚ãÜ&gt; F G1 (BD G2 g) (BD G1 f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk42"><span class="nb">rewrite</span> &lt;- ap_fmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (compose (BD G2 g) ‚àò app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt;
BD G1 f t2 =
F G1 (precompose (BD G2 g))
  (P G1
     (ap G2
      ‚àò precompose (BD G2 g)
          (ap G2 (P G2 (app (v:=C))))) &lt;‚ãÜ&gt; 
   BD G1 f t1) &lt;‚ãÜ&gt; BD G1 f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk43"><span class="kp">repeat</span> <span class="nb">rewrite</span> fmap_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (compose (BD G2 g) ‚àò app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt;
BD G1 f t2 =
F G1 (compose (precompose (BD G2 g)))
  (P G1
     (ap G2
      ‚àò precompose (BD G2 g)
          (ap G2 (P G2 (app (v:=C)))))) &lt;‚ãÜ&gt; 
BD G1 f t1 &lt;‚ãÜ&gt; BD G1 f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk44"><span class="nb">rewrite</span> (app_pure_natural G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (compose (BD G2 g) ‚àò app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt;
BD G1 f t2 =
P G1
  (precompose (BD G2 g)
   ‚àò (ap G2
      ‚àò precompose (BD G2 g)
          (ap G2 (P G2 (app (v:=C)))))) &lt;‚ãÜ&gt; 
BD G1 f t1 &lt;‚ãÜ&gt; BD G1 f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk45"><span class="kn">Theorem</span> <span class="nf">dtm3_stlc_automated</span> :
    <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H1</span> : Fmap G1) (<span class="nv">H2</span> : Pure G1) (<span class="nv">H3</span> : Mult G1),
      Applicative G1 -&gt;
      <span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H5</span> : Fmap G2) (<span class="nv">H6</span> : Pure G2) (<span class="nv">H7</span> : Mult G2),
        Applicative G2 -&gt;
        <span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 (term C)) (<span class="nv">f</span> : nat * A -&gt; G1 (term B)),
          fmap G1 (binddt term G2 g) ‚àò binddt term G1 f = binddt term (G1 ‚àò G2) (g ‚ãÜdtm f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
  (<span class="nv">H1</span> : Fmap G1) (<span class="nv">H2</span> : Pure G1) (<span class="nv">H3</span> : Mult G1),
Applicative G1 -&gt;
<span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H5</span> : Fmap G2)
  (<span class="nv">H6</span> : Pure G2) (<span class="nv">H7</span> : Mult G2),
Applicative G2 -&gt;
<span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 (term C))
  (<span class="nv">f</span> : nat * A -&gt; G1 (term B)),
F G1 (BD G2 g) ‚àò BD G1 f = BD (G1 ‚àò G2) (g ‚ãÜdtm f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk46"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
  (<span class="nv">H1</span> : Fmap G1) (<span class="nv">H2</span> : Pure G1) (<span class="nv">H3</span> : Mult G1),
Applicative G1 -&gt;
<span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H5</span> : Fmap G2)
  (<span class="nv">H6</span> : Pure G2) (<span class="nv">H7</span> : Mult G2),
Applicative G2 -&gt;
<span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 (term C))
  (<span class="nv">f</span> : nat * A -&gt; G1 (term B)),
F G1 (BD G2 g) ‚àò BD G1 f = BD (G1 ‚àò G2) (g ‚ãÜdtm f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk47"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g) ‚àò BD G1 f = BD (G1 ‚àò G2) (g ‚ãÜdtm f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk48">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(F G1 (BD G2 g) ‚àò BD G1 f) t =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk49"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g) (BD G1 f t) = BD (G1 ‚àò G2) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk4a"><span class="nb">generalize dependent</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : nat * B -&gt; G2 (term C),
F G1 (BD G2 g) (BD G1 f t) = BD (G1 ‚àò G2) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk4b"><span class="nb">generalize dependent</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t) = BD (G1 ‚àò G2) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk4c">induction_on_term; <span class="nb">intros</span> f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g) (BD G1 f (tvar v)) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) (tvar v)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk4d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B)) (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t0) = BD (G1 ‚àò G2) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk4d"><hr></label><div class="goal-conclusion">F G1 (BD G2 g) (BD G1 f ((<span class="kr">Œª</span>) t t0)) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) ((<span class="kr">Œª</span>) t t0)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk4e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk4e"><hr></label><div class="goal-conclusion">F G1 (BD G2 g) (BD G1 f ([t1 ]@[ t2])) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) ([t1 ]@[ t2])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk4f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g) (BD G1 f (tvar v)) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) (tvar v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk50"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g) (f (<span class="mi">0</span>, v)) =
F G1 (BD G2 (preincr <span class="mi">0</span> g)) (f (<span class="mi">0</span>, v))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk51"><span class="nb">change</span> (preincr <span class="mi">0</span> g) <span class="kr">with</span> (preincr ∆µ g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g) (f (<span class="mi">0</span>, v)) =
F G1 (BD G2 (preincr ∆µ g)) (f (<span class="mi">0</span>, v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> Decorated.Monad.preincr_zero.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk52">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t0) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g) (BD G1 f ((<span class="kr">Œª</span>) t t0)) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) ((<span class="kr">Œª</span>) t t0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk53"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t0) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g)
  (P G1 ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G1 (preincr <span class="mi">1</span> f) t0) =
P (G1 ‚àò G2) ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt;
BD (G1 ‚àò G2) (preincr <span class="mi">1</span> (g ‚ãÜdtm f)) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk54"><span class="nb">rewrite</span> &lt;- (kcompose_dtm_preincr nat term g f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t0) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g)
  (P G1 ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G1 (preincr <span class="mi">1</span> f) t0) =
P (G1 ‚àò G2) ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt;
BD (G1 ‚àò G2) (preincr <span class="mi">1</span> g ‚ãÜdtm preincr <span class="mi">1</span> f) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk55"><span class="nb">rewrite</span> &lt;- IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t0) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g)
  (P G1 ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G1 (preincr <span class="mi">1</span> f) t0) =
P (G1 ‚àò G2) ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt;
F G1 (BD G2 (preincr <span class="mi">1</span> g)) (BD G1 (preincr <span class="mi">1</span> f) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk56">dtm3_lhs_step G1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t0) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (BD G2 g ‚àò (<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G1 (preincr <span class="mi">1</span> f) t0 =
P (G1 ‚àò G2) ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt;
F G1 (BD G2 (preincr <span class="mi">1</span> g)) (BD G1 (preincr <span class="mi">1</span> f) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk57">dtm3_rhs_step G2 G1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t0) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (BD G2 g ‚àò (<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G1 (preincr <span class="mi">1</span> f) t0 =
P G1
  (precompose (BD G2 (preincr <span class="mi">1</span> g))
     (ap G2 (P G2 ((<span class="kr">Œª</span>) t)))) &lt;‚ãÜ&gt;
BD G1 (preincr <span class="mi">1</span> f) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk58">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g) (BD G1 f ([t1 ]@[ t2])) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) ([t1 ]@[ t2])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk59"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F G1 (BD G2 g)
  (P G1 (app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt; BD G1 f t2) =
P (G1 ‚àò G2) (app (v:=C)) &lt;‚ãÜ&gt;
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1 &lt;‚ãÜ&gt;
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5a">dtm3_lhs_step G1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (compose (BD G2 g) ‚àò app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt;
BD G1 f t2 =
P (G1 ‚àò G2) (app (v:=C)) &lt;‚ãÜ&gt;
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1 &lt;‚ãÜ&gt;
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5b"><span class="nb">rewrite</span> &lt;- IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (compose (BD G2 g) ‚àò app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt;
BD G1 f t2 =
P (G1 ‚àò G2) (app (v:=C)) &lt;‚ãÜ&gt;
F G1 (BD G2 g) (BD G1 f t1) &lt;‚ãÜ&gt;
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5c"><span class="nb">rewrite</span> &lt;- IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (compose (BD G2 g) ‚àò app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt;
BD G1 f t2 =
P (G1 ‚àò G2) (app (v:=C)) &lt;‚ãÜ&gt;
F G1 (BD G2 g) (BD G1 f t1) &lt;‚ãÜ&gt;
F G1 (BD G2 g) (BD G1 f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5d">dtm3_rhs_step G2 G1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (compose (BD G2 g) ‚àò app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt;
BD G1 f t2 =
P G1
  (precompose (BD G2 g) (ap G2 (P G2 (app (v:=C))))) &lt;‚ãÜ&gt;
BD G1 f t1 &lt;‚ãÜ&gt; F G1 (BD G2 g) (BD G1 f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5e">dtm3_rhs_step G2 G1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t1) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : nat * A -&gt; G1 (term B))
  (<span class="nv">g</span> : nat * B -&gt; G2 (term C)),
F G1 (BD G2 g) (BD G1 f t2) =
BD (G1 ‚àò G2) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 (term C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G1 (compose (BD G2 g) ‚àò app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt;
BD G1 f t2 =
P G1
  (precompose (BD G2 g)
   ‚àò (ap G2
      ‚àò precompose (BD G2 g)
          (ap G2 (P G2 (app (v:=C)))))) &lt;‚ãÜ&gt; 
BD G1 f t1 &lt;‚ãÜ&gt; BD G1 f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="applicative-homomorphism-law">
<h2><a class="toc-backref" href="#toc-entry-8">Applicative homomorphism law</a></h2>
<p>This law states that <code class="highlight coq"><span class="n">binddt</span></code> is parametric with respect to
applicative functors in the sense that it commutes with their
homomorphisms. It is (probably?) a free theorem, so it is not actually
a restriction on implementations of <code class="highlight coq"><span class="n">binddt</span></code> (cite Gibbons).</p>
<pre class="alectryon-io highlight" id="dtm4"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5f"><span class="kn">Theorem</span> <span class="nf">dtm4_stlc</span> :
    <span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H1</span> : Fmap G1) (<span class="nv">H2</span> : Pure G1) (<span class="nv">H3</span> : Mult G1) (<span class="nv">H4</span> : Fmap G2) (<span class="nv">H5</span> : Pure G2) (<span class="nv">H6</span> : Mult G2)
      (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A), ApplicativeMorphism G1 G2 œï -&gt;
      <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : nat * A -&gt; G1 (term B)),
        œï (term B) ‚àò binddt term G1 f = binddt term G2 (œï (term B) ‚àò f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H1</span> : Fmap G1)
  (<span class="nv">H2</span> : Pure G1) (<span class="nv">H3</span> : Mult G1) (<span class="nv">H4</span> : Fmap G2)
  (<span class="nv">H5</span> : Pure G2) (<span class="nv">H6</span> : Mult G2)
  (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : nat * A -&gt; G1 (term B)),
œï (term B) ‚àò BD G1 f = BD G2 (œï (term B) ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk60"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H1</span> : Fmap G1)
  (<span class="nv">H2</span> : Pure G1) (<span class="nv">H3</span> : Mult G1) (<span class="nv">H4</span> : Fmap G2)
  (<span class="nv">H5</span> : Pure G2) (<span class="nv">H6</span> : Mult G2)
  (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : nat * A -&gt; G1 (term B)),
œï (term B) ‚àò BD G1 f = BD G2 (œï (term B) ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk61"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) ‚àò BD G1 f = BD G2 (œï (term B) ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk62">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œï (term B) ‚àò BD G1 f) t = BD G2 (œï (term B) ‚àò f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk63"><span class="nb">inversion</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œï (term B) ‚àò BD G1 f) t = BD G2 (œï (term B) ‚àò f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk64"><span class="nb">generalize dependent</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
(œï (term B) ‚àò BD G1 f) t = BD G2 (œï (term B) ‚àò f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk65"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t) = BD G2 (œï (term B) ‚àò f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="syntax-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk66"><span class="nb">induction</span> t; <span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) (BD G1 f (tvar v)) =
BD G2 (œï (term B) ‚àò f) (tvar v)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk67" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t0) =
BD G2 (œï (term B) ‚àò f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk67"><hr></label><div class="goal-conclusion">œï (term B) (BD G1 f ((<span class="kr">Œª</span>) t t0)) =
BD G2 (œï (term B) ‚àò f) ((<span class="kr">Œª</span>) t t0)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk68" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t1) =
BD G2 (œï (term B) ‚àò f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t2) =
BD G2 (œï (term B) ‚àò f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk68"><hr></label><div class="goal-conclusion">œï (term B) (BD G1 f ([t1 ]@[ t2])) =
BD G2 (œï (term B) ‚àò f) ([t1 ]@[ t2])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk69">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) (BD G1 f (tvar v)) =
BD G2 (œï (term B) ‚àò f) (tvar v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t0) =
BD G2 (œï (term B) ‚àò f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) (BD G1 f ((<span class="kr">Œª</span>) t t0)) =
BD G2 (œï (term B) ‚àò f) ((<span class="kr">Œª</span>) t t0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6b"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t0) =
BD G2 (œï (term B) ‚àò f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) (P G1 ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G1 (preincr <span class="mi">1</span> f) t0) =
P G2 ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G2 (preincr <span class="mi">1</span> (œï (term B) ‚àò f)) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6c"><span class="kp">repeat</span> <span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t0) =
BD G2 (œï (term B) ‚àò f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B -&gt; term B) (P G1 ((<span class="kr">Œª</span>) t)) &lt;‚ãÜ&gt;
œï (term B) (BD G1 (preincr <span class="mi">1</span> f) t0) =
P G2 ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G2 (preincr <span class="mi">1</span> (œï (term B) ‚àò f)) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6d"><span class="nb">rewrite</span> appmor_pure.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t0) =
BD G2 (œï (term B) ‚àò f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G2 ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; œï (term B) (BD G1 (preincr <span class="mi">1</span> f) t0) =
P G2 ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G2 (preincr <span class="mi">1</span> (œï (term B) ‚àò f)) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6e"><span class="nb">rewrite</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t0) =
BD G2 (œï (term B) ‚àò f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G2 ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G2 (œï (term B) ‚àò preincr <span class="mi">1</span> f) t0 =
P G2 ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G2 (preincr <span class="mi">1</span> (œï (term B) ‚àò f)) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t1) =
BD G2 (œï (term B) ‚àò f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t2) =
BD G2 (œï (term B) ‚àò f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) (BD G1 f ([t1 ]@[ t2])) =
BD G2 (œï (term B) ‚àò f) ([t1 ]@[ t2])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk70"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t1) =
BD G2 (œï (term B) ‚àò f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t2) =
BD G2 (œï (term B) ‚àò f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (P G1 (app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt; BD G1 f t2) =
P G2 (app (v:=B)) &lt;‚ãÜ&gt; BD G2 (œï (term B) ‚àò f) t1 &lt;‚ãÜ&gt;
BD G2 (œï (term B) ‚àò f) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk71"><span class="kp">repeat</span> <span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t1) =
BD G2 (œï (term B) ‚àò f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t2) =
BD G2 (œï (term B) ‚àò f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B -&gt; term B -&gt; term B) (P G1 (app (v:=B))) &lt;‚ãÜ&gt;
œï (term B) (BD G1 f t1) &lt;‚ãÜ&gt; œï (term B) (BD G1 f t2) =
P G2 (app (v:=B)) &lt;‚ãÜ&gt; BD G2 (œï (term B) ‚àò f) t1 &lt;‚ãÜ&gt;
BD G2 (œï (term B) ‚àò f) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk72"><span class="nb">rewrite</span> appmor_pure.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t1) =
BD G2 (œï (term B) ‚àò f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t2) =
BD G2 (œï (term B) ‚àò f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G2 (app (v:=B)) &lt;‚ãÜ&gt; œï (term B) (BD G1 f t1) &lt;‚ãÜ&gt;
œï (term B) (BD G1 f t2) =
P G2 (app (v:=B)) &lt;‚ãÜ&gt; BD G2 (œï (term B) ‚àò f) t1 &lt;‚ãÜ&gt;
BD G2 (œï (term B) ‚àò f) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk73"><span class="nb">rewrite</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t1) =
BD G2 (œï (term B) ‚àò f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t2) =
BD G2 (œï (term B) ‚àò f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G2 (app (v:=B)) &lt;‚ãÜ&gt; BD G2 (œï (term B) ‚àò f) t1 &lt;‚ãÜ&gt;
œï (term B) (BD G1 f t2) =
P G2 (app (v:=B)) &lt;‚ãÜ&gt; BD G2 (œï (term B) ‚àò f) t1 &lt;‚ãÜ&gt;
BD G2 (œï (term B) ‚àò f) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk74"><span class="nb">rewrite</span> IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t1) =
BD G2 (œï (term B) ‚àò f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t2) =
BD G2 (œï (term B) ‚àò f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G2 (app (v:=B)) &lt;‚ãÜ&gt; BD G2 (œï (term B) ‚àò f) t1 &lt;‚ãÜ&gt;
BD G2 (œï (term B) ‚àò f) t2 =
P G2 (app (v:=B)) &lt;‚ãÜ&gt; BD G2 (œï (term B) ‚àò f) t1 &lt;‚ãÜ&gt;
BD G2 (œï (term B) ‚àò f) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk75"><span class="kn">Theorem</span> <span class="nf">dtm4_automated</span> :
    <span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H1</span> : Fmap G1) (<span class="nv">H2</span> : Pure G1) (<span class="nv">H3</span> : Mult G1) (<span class="nv">H4</span> : Fmap G2) (<span class="nv">H5</span> : Pure G2) (<span class="nv">H6</span> : Mult G2)
      (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
      ApplicativeMorphism G1 G2 œï -&gt;
      <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : nat * A -&gt; G1 (term B)),
        œï (term B) ‚àò binddt term G1 f = binddt term G2 (œï (term B) ‚àò f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H1</span> : Fmap G1)
  (<span class="nv">H2</span> : Pure G1) (<span class="nv">H3</span> : Mult G1) (<span class="nv">H4</span> : Fmap G2)
  (<span class="nv">H5</span> : Pure G2) (<span class="nv">H6</span> : Mult G2)
  (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : nat * A -&gt; G1 (term B)),
œï (term B) ‚àò BD G1 f = BD G2 (œï (term B) ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk76"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H1</span> : Fmap G1)
  (<span class="nv">H2</span> : Pure G1) (<span class="nv">H3</span> : Mult G1) (<span class="nv">H4</span> : Fmap G2)
  (<span class="nv">H5</span> : Pure G2) (<span class="nv">H6</span> : Mult G2)
  (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : nat * A -&gt; G1 (term B)),
œï (term B) ‚àò BD G1 f = BD G2 (œï (term B) ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk77"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) ‚àò BD G1 f = BD G2 (œï (term B) ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk78">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œï (term B) ‚àò BD G1 f) t = BD G2 (œï (term B) ‚àò f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk79"><span class="nb">inversion</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œï (term B) ‚àò BD G1 f) t = BD G2 (œï (term B) ‚àò f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7a"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) (BD G1 f t) = BD G2 (œï (term B) ‚àò f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7b"><span class="nb">generalize dependent</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t) = BD G2 (œï (term B) ‚àò f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7c"><span class="nb">induction</span> t; <span class="nb">intro</span> f; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) (f (<span class="mi">0</span>, v)) = (œï (term B) ‚àò f) (<span class="mi">0</span>, v)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk7d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t0) =
BD G2 (œï (term B) ‚àò f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk7d"><hr></label><div class="goal-conclusion">œï (term B) (P G1 ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G1 (preincr <span class="mi">1</span> f) t0) =
P G2 ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G2 (preincr <span class="mi">1</span> (œï (term B) ‚àò f)) t0</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk7e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t1) =
BD G2 (œï (term B) ‚àò f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t2) =
BD G2 (œï (term B) ‚àò f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk7e"><hr></label><div class="goal-conclusion">œï (term B)
  (P G1 (app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt; BD G1 f t2) =
P G2 (app (v:=B)) &lt;‚ãÜ&gt; BD G2 (œï (term B) ‚àò f) t1 &lt;‚ãÜ&gt;
BD G2 (œï (term B) ‚àò f) t2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) (f (<span class="mi">0</span>, v)) = (œï (term B) ‚àò f) (<span class="mi">0</span>, v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk80">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t0) =
BD G2 (œï (term B) ‚àò f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) (P G1 ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G1 (preincr <span class="mi">1</span> f) t0) =
P G2 ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G2 (preincr <span class="mi">1</span> (œï (term B) ‚àò f)) t0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk81"><span class="kp">repeat</span> <span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t0) =
BD G2 (œï (term B) ‚àò f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B -&gt; term B) (P G1 ((<span class="kr">Œª</span>) t)) &lt;‚ãÜ&gt;
œï (term B) (BD G1 (preincr <span class="mi">1</span> f) t0) =
P G2 ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G2 (preincr <span class="mi">1</span> (œï (term B) ‚àò f)) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk82"><span class="nb">rewrite</span> appmor_pure.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t0) =
BD G2 (œï (term B) ‚àò f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G2 ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; œï (term B) (BD G1 (preincr <span class="mi">1</span> f) t0) =
P G2 ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G2 (preincr <span class="mi">1</span> (œï (term B) ‚àò f)) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk83"><span class="nb">rewrite</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t0) =
BD G2 (œï (term B) ‚àò f) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G2 ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G2 (œï (term B) ‚àò preincr <span class="mi">1</span> f) t0 =
P G2 ((<span class="kr">Œª</span>) t) &lt;‚ãÜ&gt; BD G2 (preincr <span class="mi">1</span> (œï (term B) ‚àò f)) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk84">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t1) =
BD G2 (œï (term B) ‚àò f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t2) =
BD G2 (œï (term B) ‚àò f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (P G1 (app (v:=B)) &lt;‚ãÜ&gt; BD G1 f t1 &lt;‚ãÜ&gt; BD G1 f t2) =
P G2 (app (v:=B)) &lt;‚ãÜ&gt; BD G2 (œï (term B) ‚àò f) t1 &lt;‚ãÜ&gt;
BD G2 (œï (term B) ‚àò f) t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk85"><span class="kp">repeat</span> <span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t1) =
BD G2 (œï (term B) ‚àò f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t2) =
BD G2 (œï (term B) ‚àò f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B -&gt; term B -&gt; term B) (P G1 (app (v:=B))) &lt;‚ãÜ&gt;
œï (term B) (BD G1 f t1) &lt;‚ãÜ&gt; œï (term B) (BD G1 f t2) =
P G2 (app (v:=B)) &lt;‚ãÜ&gt; BD G2 (œï (term B) ‚àò f) t1 &lt;‚ãÜ&gt;
BD G2 (œï (term B) ‚àò f) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk86"><span class="nb">rewrite</span> appmor_pure.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t1) =
BD G2 (œï (term B) ‚àò f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t2) =
BD G2 (œï (term B) ‚àò f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G2 (app (v:=B)) &lt;‚ãÜ&gt; œï (term B) (BD G1 f t1) &lt;‚ãÜ&gt;
œï (term B) (BD G1 f t2) =
P G2 (app (v:=B)) &lt;‚ãÜ&gt; BD G2 (œï (term B) ‚àò f) t1 &lt;‚ãÜ&gt;
BD G2 (œï (term B) ‚àò f) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk87"><span class="nb">rewrite</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t1) =
BD G2 (œï (term B) ‚àò f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t2) =
BD G2 (œï (term B) ‚àò f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G2 (app (v:=B)) &lt;‚ãÜ&gt; BD G2 (œï (term B) ‚àò f) t1 &lt;‚ãÜ&gt;
œï (term B) (BD G1 f t2) =
P G2 (app (v:=B)) &lt;‚ãÜ&gt; BD G2 (œï (term B) ‚àò f) t1 &lt;‚ãÜ&gt;
BD G2 (œï (term B) ‚àò f) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk88"><span class="nb">rewrite</span> IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (F G1 f x) = F G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (P G1 a) = P G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t1) =
BD G2 (œï (term B) ‚àò f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 (term B),
œï (term B) (BD G1 f t2) =
BD G2 (œï (term B) ‚àò f) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 (term B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P G2 (app (v:=B)) &lt;‚ãÜ&gt; BD G2 (œï (term B) ‚àò f) t1 &lt;‚ãÜ&gt;
BD G2 (œï (term B) ‚àò f) t2 =
P G2 (app (v:=B)) &lt;‚ãÜ&gt; BD G2 (œï (term B) ‚àò f) t1 &lt;‚ãÜ&gt;
BD G2 (œï (term B) ‚àò f) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span>: DT.Monad.Monad nat term :=
    {| kdtm_binddt0 := dtm1_stlc;
       kdtm_binddt1 := dtm2_stlc;
       kdtm_binddt2 := dtm3_stlc;
       kdtm_morph := dtm4_stlc;
    |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">laws</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">test_notations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">Œ≤</span> : <span class="kt">Type</span>)
    (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : atom)
    (<span class="nv">b</span> : Œ≤) (<span class="nv">œÑ</span> : typ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk89"><span class="kn">Check</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">1</span>
     : nat</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8a"><span class="kn">Check</span> (<span class="kr">Œª</span> <span class="nv">œÑ</span> (<span class="nv">tvar</span> (Bd <span class="mi">1</span>))).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(<span class="kr">Œª</span>) œÑ (tvar (Bd <span class="mi">1</span>))
     : term LN</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8b"><span class="kn">Check</span> (<span class="kr">Œª</span> <span class="nv">œÑ</span> (<span class="nv">tvar</span> (Fr x))).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(<span class="kr">Œª</span>) œÑ (tvar (Fr x))
     : term LN</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8c"><span class="kn">Check</span> [<span class="kr">Œª</span> <span class="nv">œÑ</span> (<span class="nv">tvar</span> (Bd <span class="mi">1</span>))]@[tvar (Fr x)].</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[(<span class="kr">Œª</span>) œÑ (tvar (Bd <span class="mi">1</span>)) ]@[ tvar (Fr x)]
     : term LN</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8d"><span class="kn">Check</span> [<span class="kr">Œª</span> <span class="nv">œÑ</span> (<span class="nv">tvar</span> (Fr x))]@[tvar (Bd <span class="mi">0</span>)].</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[(<span class="kr">Œª</span>) œÑ (tvar (Fr x)) ]@[ tvar (Bd <span class="mi">0</span>)]
     : term LN</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8e"><span class="kn">Check</span> <span class="kr">Œª</span> <span class="nv">œÑ</span> ([(tvar (Bd <span class="mi">1</span>))]@[tvar (Fr x)]).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(<span class="kr">Œª</span>) œÑ ([tvar (Bd <span class="mi">1</span>) ]@[ tvar (Fr x)])
     : term LN</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8f"><span class="kn">Check</span> <span class="kr">Œª</span> <span class="nv">œÑ</span> ([(tvar (Fr x))]@[tvar (Bd <span class="mi">0</span>)]).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(<span class="kr">Œª</span>) œÑ ([tvar (Fr x) ]@[ tvar (Bd <span class="mi">0</span>)])
     : term LN</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">test_notations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ctx</span> := list (atom * typ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;Œì ‚ä¢ t : S&quot;</span> (<span class="kn">at level</span> <span class="mi">90</span>, t <span class="kn">at level</span> <span class="mi">99</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Judgment</span> : ctx -&gt; term LN -&gt; typ -&gt; <span class="kt">Prop</span> :=
| j_var :
    <span class="kr">forall</span> (<span class="nv">Œì</span> : ctx) (<span class="nv">x</span> : atom) (<span class="nv">A</span> : typ),
      uniq Œì -&gt;
      (x, A) ‚àà Œì -&gt;
      Œì ‚ä¢ tvar (Fr x) : A
| j_abs :
    <span class="kr">forall</span> (<span class="nv">L</span> : AtomSet.t) <span class="nv">Œì</span> (<span class="nv">œÑ1</span> <span class="nv">œÑ2</span> : typ) (<span class="nv">t</span> : term LN),
      (<span class="kr">forall</span> <span class="nv">x</span> : atom, ~ AtomSet.In x L -&gt; Œì ++ x ~ œÑ1 ‚ä¢ t &#39;(tvar (Fr x)) : œÑ2) -&gt;
      Œì ‚ä¢ <span class="kr">Œª</span> <span class="nv">œÑ1</span> <span class="nv">t</span> : œÑ1 ‚üπ œÑ2
| j_app :
    <span class="kr">forall</span> <span class="nv">Œì</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term LN) (<span class="nv">A</span> <span class="nv">B</span> : typ),
      Œì ‚ä¢ t1 : A ‚üπ B -&gt;
      Œì ‚ä¢ t2 : A -&gt;
      Œì ‚ä¢ [t1]@[t2] : B
<span class="kn">where</span> <span class="s2">&quot;Œì ‚ä¢ t : A&quot;</span> := (Judgment Œì t A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** * Rewriting lemmas for high-level operations *)</span>
<span class="sd">(******************************************************************************)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Export</span>
  Classes.Listable.Functor
  <span class="c">(* &lt;&lt;Tolist&gt;&gt; operation *)</span>
  Classes.Kleisli.Traversable.Functor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* &lt;&lt;Tolist&gt;&gt; instance for Traversable functors *)</span>



<span class="sd">(** ** Rewriting lemmas for &lt;&lt;tolist&gt;&gt;, &lt;&lt;toset&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">term_list_rewrite</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span>
    (<span class="nv">A</span> : <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">solve_in_term</span> :=
    unfold_ops @Pure_const;
    <span class="kp">repeat</span> <span class="nb">rewrite</span> (@fmap_const_spec (A -&gt; <span class="kt">Prop</span>) _ _ (ret term));
    simpl_monoid;
    <span class="kp">repeat</span> <span class="nb">rewrite</span> (dtm2_helper);
    <span class="kp">try</span> <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk90"><span class="kn">Lemma</span> <span class="nf">tolist_term_1</span> : <span class="kr">forall</span> (<span class="nv">x</span> : A),
    tolist term (tvar x) = [x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, tolist term (tvar x) = [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk91"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, tolist term (tvar x) = [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk92"><span class="kn">Lemma</span> <span class="nf">tolist_term_2</span> : <span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term A),
    tolist term (lam X t) = tolist term t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term A),
tolist term ((<span class="kr">Œª</span>) X t) = tolist term t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk93"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term A),
tolist term ((<span class="kr">Œª</span>) X t) = tolist term t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk94"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tolist term ((<span class="kr">Œª</span>) X t) = tolist term t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk95"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">binddt term (const (list A))
  (preincr <span class="mi">1</span>
     (fmap (const (list A)) (ret term) ‚àò one
      ‚àò extract (prod nat))) t = tolist term t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk96"><span class="nb">rewrite</span> dtm2_helper.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">binddt term (const (list A))
  (fmap (const (list A)) (ret term) ‚àò one
   ‚àò extract (prod nat)) t = tolist term t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk97"><span class="kn">Lemma</span> <span class="nf">tolist_term_3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A),
      tolist term (app t1 t2) = tolist term t1 ++ tolist term t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
tolist term ([t1 ]@[ t2]) =
tolist term t1 ++ tolist term t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk98"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
tolist term ([t1 ]@[ t2]) =
tolist term t1 ++ tolist term t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk99"><span class="kn">Lemma</span> <span class="nf">in_term_1</span> : <span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A),
      x ‚àà tvar y &lt;-&gt; x = y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, x ‚àà tvar y &lt;-&gt; x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, x ‚àà tvar y &lt;-&gt; x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àà tvar y &lt;-&gt; x = y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9c"><span class="nb">cbv</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(y = x -&gt; x = y) /\ (x = y -&gt; y = x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9d"><span class="kn">Lemma</span> <span class="nf">in_term_2</span> : <span class="kr">forall</span> (<span class="nv">y</span> : A) (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term A),
    y ‚àà (lam X t) &lt;-&gt; y ‚àà t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">y</span> : A) (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term A),
y ‚àà (<span class="kr">Œª</span>) X t &lt;-&gt; y ‚àà t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">y</span> : A) (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term A),
y ‚àà (<span class="kr">Œª</span>) X t &lt;-&gt; y ‚àà t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9f"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y ‚àà (<span class="kr">Œª</span>) X t &lt;-&gt; y ‚àà t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka0"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pure (const (A -&gt; <span class="kt">Prop</span>)) ((<span class="kr">Œª</span>) X)
 ‚óè binddt term (const (A -&gt; <span class="kt">Prop</span>))
     (preincr <span class="mi">1</span>
        (fmap (const (A -&gt; <span class="kt">Prop</span>)) (ret term)
         ‚àò ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)
         ‚àò extract (prod nat))) t) y &lt;-&gt; y ‚àà t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka1"><span class="nb">rewrite</span> dtm2_helper.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pure (const (A -&gt; <span class="kt">Prop</span>)) ((<span class="kr">Œª</span>) X)
 ‚óè binddt term (const (A -&gt; <span class="kt">Prop</span>))
     (fmap (const (A -&gt; <span class="kt">Prop</span>)) (ret term)
      ‚àò ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)
      ‚àò extract (prod nat)) t) y &lt;-&gt; y ‚àà t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka2">unfold_ops @Pure_const; simpl_monoid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">binddt term (const (A -&gt; <span class="kt">Prop</span>))
  (fmap (const (A -&gt; <span class="kt">Prop</span>)) (ret term)
   ‚àò ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)
   ‚àò extract (prod nat)) t y &lt;-&gt; y ‚àà t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka3"><span class="kn">Lemma</span> <span class="nf">in_term_3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A) (<span class="nv">y</span> : A),
      y ‚àà (app t1 t2) &lt;-&gt; y ‚àà t1 \/ y ‚àà t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A) (<span class="nv">y</span> : A),
y ‚àà ([t1 ]@[ t2]) &lt;-&gt; y ‚àà t1 \/ y ‚àà t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A) (<span class="nv">y</span> : A),
y ‚àà ([t1 ]@[ t2]) &lt;-&gt; y ‚àà t1 \/ y ‚àà t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka5"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y ‚àà ([t1 ]@[ t2]) &lt;-&gt; y ‚àà t1 \/ y ‚àà t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka6"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((pure (const (A -&gt; <span class="kt">Prop</span>)) (app (v:=<span class="kt">False</span>))
  ‚óè toset term t1) ‚óè toset term t2) y &lt;-&gt;
y ‚àà t1 \/ y ‚àà t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka7">unfold_ops @Pure_const; simpl_monoid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(toset term t1 ‚óè toset term t2) y &lt;-&gt; y ‚àà t1 \/ y ‚àà t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">term_list_rewrite</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Rewriting lemmas for &lt;&lt;free&gt;&gt;, &lt;&lt;freeset&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">term_free_rewrite</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> (<span class="nv">A</span> : <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka8"><span class="kn">Lemma</span> <span class="nf">term_free11</span> : <span class="kr">forall</span> (<span class="nv">b</span> : nat) (<span class="nv">x</span> : atom),
      x ‚àà free term (tvar (Bd b)) &lt;-&gt; <span class="kt">False</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> : nat) (<span class="nv">x</span> : atom),
x ‚àà free term (tvar (Bd b)) &lt;-&gt; <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> : nat) (<span class="nv">x</span> : atom),
x ‚àà free term (tvar (Bd b)) &lt;-&gt; <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkaa"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àà free term (tvar (Bd b)) &lt;-&gt; <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkab"><span class="kn">Lemma</span> <span class="nf">term_free12</span> : <span class="kr">forall</span> (<span class="nv">y</span> : atom) (<span class="nv">x</span> : atom),
      x ‚àà free term (tvar (Fr y)) &lt;-&gt; x = y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">x</span> : atom,
x ‚àà free term (tvar (Fr y)) &lt;-&gt; x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkac"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">x</span> : atom,
x ‚àà free term (tvar (Fr y)) &lt;-&gt; x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkad"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àà free term (tvar (Fr y)) &lt;-&gt; x = y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkae"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y = x \/ <span class="kt">False</span> &lt;-&gt; x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkaf"><span class="kn">Lemma</span> <span class="nf">term_free2</span> : <span class="kr">forall</span> (<span class="nv">x</span> : atom) (<span class="nv">t</span> : term LN) (<span class="nv">X</span> : typ),
      x ‚àà free term (lam X t) &lt;-&gt; x ‚àà free term t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : atom) (<span class="nv">t</span> : term LN) (<span class="nv">X</span> : typ),
x ‚àà free term ((<span class="kr">Œª</span>) X t) &lt;-&gt; x ‚àà free term t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : atom) (<span class="nv">t</span> : term LN) (<span class="nv">X</span> : typ),
x ‚àà free term ((<span class="kr">Œª</span>) X t) &lt;-&gt; x ‚àà free term t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb1"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àà free term ((<span class="kr">Œª</span>) X t) &lt;-&gt; x ‚àà free term t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb2"><span class="nb">rewrite</span> in_free_iff.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Fr x ‚àà (<span class="kr">Œª</span>) X t &lt;-&gt; x ‚àà free term t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb3"><span class="nb">rewrite</span> in_term_2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Fr x ‚àà t &lt;-&gt; x ‚àà free term t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> &lt;- in_free_iff.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb4"><span class="kn">Lemma</span> <span class="nf">term_free3</span> : <span class="kr">forall</span> (<span class="nv">x</span> : atom) (<span class="nv">t1</span> <span class="nv">t2</span> : term LN),
      x ‚àà free term (app t1 t2) &lt;-&gt; x ‚àà free term t1 \/ x ‚àà free term t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : atom) (<span class="nv">t1</span> <span class="nv">t2</span> : term LN),
x ‚àà free term ([t1 ]@[ t2]) &lt;-&gt;
x ‚àà free term t1 \/ x ‚àà free term t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : atom) (<span class="nv">t1</span> <span class="nv">t2</span> : term LN),
x ‚àà free term ([t1 ]@[ t2]) &lt;-&gt;
x ‚àà free term t1 \/ x ‚àà free term t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb6"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àà free term ([t1 ]@[ t2]) &lt;-&gt;
x ‚àà free term t1 \/ x ‚àà free term t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb7"><span class="nb">rewrite</span> in_free_iff.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Fr x ‚àà ([t1 ]@[ t2]) &lt;-&gt;
x ‚àà free term t1 \/ x ‚àà free term t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb8"><span class="nb">rewrite</span> in_term_3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Fr x ‚àà t1 \/ Fr x ‚àà t2 &lt;-&gt;
x ‚àà free term t1 \/ x ‚àà free term t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> &lt;- <span class="mi">2</span>(in_free_iff).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb9"><span class="kn">Lemma</span> <span class="nf">term_in_freeset11</span> : <span class="kr">forall</span> (<span class="nv">b</span> : nat) (<span class="nv">x</span> : atom),
      AtomSet.In x (freeset term (tvar (Bd b))) &lt;-&gt; <span class="kt">False</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> : nat) (<span class="nv">x</span> : atom),
x ‚àà@ freeset term (tvar (Bd b)) &lt;-&gt; <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkba"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> : nat) (<span class="nv">x</span> : atom),
x ‚àà@ freeset term (tvar (Bd b)) &lt;-&gt; <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkbb"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àà@ freeset term (tvar (Bd b)) &lt;-&gt; <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkbc"><span class="nb">rewrite</span> &lt;- free_iff_freeset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àà free term (tvar (Bd b)) &lt;-&gt; <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> term_free11.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkbd"><span class="kn">Lemma</span> <span class="nf">term_in_freeset12</span> : <span class="kr">forall</span> (<span class="nv">y</span> : atom) (<span class="nv">x</span> : atom),
      AtomSet.In x (freeset term (tvar (Fr y))) &lt;-&gt; x = y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">x</span> : atom,
x ‚àà@ freeset term (tvar (Fr y)) &lt;-&gt; x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkbe"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">x</span> : atom,
x ‚àà@ freeset term (tvar (Fr y)) &lt;-&gt; x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkbf"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àà@ freeset term (tvar (Fr y)) &lt;-&gt; x = y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc0"><span class="nb">rewrite</span> &lt;- free_iff_freeset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àà free term (tvar (Fr y)) &lt;-&gt; x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> term_free12.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc1"><span class="kn">Lemma</span> <span class="nf">term_in_freeset2</span> : <span class="kr">forall</span> (<span class="nv">x</span> : atom) (<span class="nv">t</span> : term LN) (<span class="nv">X</span> : typ),
      AtomSet.In x (freeset term (lam X t)) &lt;-&gt; AtomSet.In x (freeset term t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : atom) (<span class="nv">t</span> : term LN) (<span class="nv">X</span> : typ),
x ‚àà@ freeset term ((<span class="kr">Œª</span>) X t) &lt;-&gt; x ‚àà@ freeset term t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : atom) (<span class="nv">t</span> : term LN) (<span class="nv">X</span> : typ),
x ‚àà@ freeset term ((<span class="kr">Œª</span>) X t) &lt;-&gt; x ‚àà@ freeset term t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc3"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àà@ freeset term ((<span class="kr">Œª</span>) X t) &lt;-&gt; x ‚àà@ freeset term t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc4"><span class="nb">rewrite</span> &lt;- <span class="mi">2</span>(free_iff_freeset).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àà free term ((<span class="kr">Œª</span>) X t) &lt;-&gt; x ‚àà free term t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> term_free2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc5"><span class="kn">Lemma</span> <span class="nf">term_in_freeset3</span> : <span class="kr">forall</span> (<span class="nv">x</span> : atom) (<span class="nv">t1</span> <span class="nv">t2</span> : term LN),
      AtomSet.In x (freeset term (app t1 t2)) &lt;-&gt; AtomSet.In x (freeset term t1) \/ AtomSet.In x (freeset term t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : atom) (<span class="nv">t1</span> <span class="nv">t2</span> : term LN),
x ‚àà@ freeset term ([t1 ]@[ t2]) &lt;-&gt;
x ‚àà@ freeset term t1 \/ x ‚àà@ freeset term t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : atom) (<span class="nv">t1</span> <span class="nv">t2</span> : term LN),
x ‚àà@ freeset term ([t1 ]@[ t2]) &lt;-&gt;
x ‚àà@ freeset term t1 \/ x ‚àà@ freeset term t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc7"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àà@ freeset term ([t1 ]@[ t2]) &lt;-&gt;
x ‚àà@ freeset term t1 \/ x ‚àà@ freeset term t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc8"><span class="nb">rewrite</span> &lt;- <span class="mi">3</span>(free_iff_freeset).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àà free term ([t1 ]@[ t2]) &lt;-&gt;
x ‚àà free term t1 \/ x ‚àà free term t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> term_free3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc9"><span class="kn">Lemma</span> <span class="nf">term_freeset11</span> : <span class="kr">forall</span> (<span class="nv">b</span> : nat) (<span class="nv">x</span> : atom),
      freeset term (tvar (Bd b)) [=] ‚àÖ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : nat,
atom -&gt; freeset term (tvar (Bd b)) [=] ‚àÖ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkca"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : nat,
atom -&gt; freeset term (tvar (Bd b)) [=] ‚àÖ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkcb"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">freeset term (tvar (Bd b)) [=] ‚àÖ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkcc"><span class="kn">Lemma</span> <span class="nf">term_freeset12</span> : <span class="kr">forall</span> (<span class="nv">y</span> : atom),
      freeset term (tvar (Fr y)) [=] {{ y }}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : atom, freeset term (tvar (Fr y)) [=] {{y}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkcd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : atom, freeset term (tvar (Fr y)) [=] {{y}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkce"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">freeset term (tvar (Fr y)) [=] {{y}}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkcf"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AtomSet.add y ‚àÖ [=] {{y}}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd0"><span class="kn">Lemma</span> <span class="nf">term_freeset2</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">X</span> : typ),
      freeset term (lam X t) [=] freeset term t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">X</span> : typ),
freeset term ((<span class="kr">Œª</span>) X t) [=] freeset term t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">X</span> : typ),
freeset term ((<span class="kr">Œª</span>) X t) [=] freeset term t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd2"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">freeset term ((<span class="kr">Œª</span>) X t) [=] freeset term t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd3"><span class="nb">unfold</span> AtomSet.Equal; <span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àà@ freeset term ((<span class="kr">Œª</span>) X t) &lt;-&gt; x ‚àà@ freeset term t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd4"><span class="nb">rewrite</span> term_in_freeset2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àà@ freeset term t &lt;-&gt; x ‚àà@ freeset term t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd5"><span class="kn">Lemma</span> <span class="nf">term_freeset3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term LN),
      freeset term (app t1 t2) [=] freeset term t1 ‚à™ freeset term t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term LN,
freeset term ([t1 ]@[ t2])
[=] freeset term t1 ‚à™ freeset term t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term LN,
freeset term ([t1 ]@[ t2])
[=] freeset term t1 ‚à™ freeset term t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd7"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">freeset term ([t1 ]@[ t2])
[=] freeset term t1 ‚à™ freeset term t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd8"><span class="nb">unfold</span> AtomSet.Equal; <span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àà@ freeset term ([t1 ]@[ t2]) &lt;-&gt;
x ‚àà@ (freeset term t1 ‚à™ freeset term t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd9"><span class="nb">rewrite</span> term_in_freeset3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àà@ freeset term t1 \/ x ‚àà@ freeset term t2 &lt;-&gt;
x ‚àà@ (freeset term t1 ‚à™ freeset term t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">term_free_rewrite</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Rewriting lemmas for &lt;&lt;foldMapd&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">term_foldMapd_rewrite</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">M</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : nat * A -&gt; M) `{Monoid M}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkda"><span class="kn">Lemma</span> <span class="nf">term_foldMapd1</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      foldMapd term f (tvar a) = f (∆µ, a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, foldMapd term f (tvar a) = f (∆µ, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkdb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, foldMapd term f (tvar a) = f (∆µ, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkdc"><span class="kn">Lemma</span> <span class="nf">term_foldMapd2</span> : <span class="kr">forall</span> <span class="nv">X</span> (<span class="nv">t</span> : term A),
      foldMapd term f (<span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">t</span>) = foldMapd term (preincr <span class="mi">1</span> f) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term A),
foldMapd term f ((<span class="kr">Œª</span>) X t) =
foldMapd term (preincr <span class="mi">1</span> f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkdd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term A),
foldMapd term f ((<span class="kr">Œª</span>) X t) =
foldMapd term (preincr <span class="mi">1</span> f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkde"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMapd term f ((<span class="kr">Œª</span>) X t) =
foldMapd term (preincr <span class="mi">1</span> f) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkdf"><span class="nb">cbv</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">op unit0
  ((<span class="kr">fix</span> binddt_term
      (G : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
      (H : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, (A -&gt; B) -&gt; G A -&gt; G B)
      (H0 : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, A -&gt; G A)
      (H1 : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, G A * G B -&gt; G (A * B))
      (v1 v2 : <span class="kt">Type</span>) (f : nat * v1 -&gt; G (term v2))
      (t : term v1) {<span class="kr">struct</span> t} : G (term v2) :=
      <span class="kr">match</span> t <span class="kr">with</span>
      | tvar v =&gt; f (<span class="mi">0</span>, v)
      | (<span class="kr">Œª</span>) œÑ body =&gt;
          H ((term v2 -&gt; term v2) * term v2) (term v2)
            (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
            (H1 (term v2 -&gt; term v2) (term v2)
               (H0 (term v2 -&gt; term v2) ((<span class="kr">Œª</span>) œÑ),
                binddt_term G H H0 H1 v1 v2
                  (<span class="kr">fun</span> <span class="nv">a</span> : nat * v1 =&gt;
                   f
                     (<span class="kr">let</span> &#39;(w1, a0) := a <span class="kr">in</span> (S w1, a0)))
                  body))
      | [t1 ]@[ t2] =&gt;
          H ((term v2 -&gt; term v2) * term v2) (term v2)
            (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
            (H1 (term v2 -&gt; term v2) (term v2)
               (H
                  ((term v2 -&gt; term v2 -&gt; term v2) *
                   term v2) (term v2 -&gt; term v2)
                  (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
                  (H1 (term v2 -&gt; term v2 -&gt; term v2)
                     (term v2)
                     (H0
                        (term v2 -&gt; term v2 -&gt; term v2)
                        (app (v:=v2)),
                      binddt_term G H H0 H1 v1 v2 f t1)),
                binddt_term G H H0 H1 v1 v2 f t2))
      <span class="kr">end</span>) (<span class="kr">fun</span> <span class="nv">_</span> : <span class="kt">Type</span> =&gt; M)
     (<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X -&gt; Y) (<span class="nv">t</span> : M) =&gt; t)
     (<span class="kr">fun</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X) =&gt; unit0)
     (<span class="kr">fun</span> (<span class="nv">_</span> <span class="nv">_</span> : <span class="kt">Type</span>) &#39;(x, y) =&gt; op x y) A <span class="kt">False</span>
     (<span class="kr">fun</span> <span class="nv">a</span> : nat * A =&gt;
      f (<span class="kr">let</span> &#39;(w1, a0) := a <span class="kr">in</span> (S w1, a0))) t) =
(<span class="kr">fix</span> binddt_term
   (G : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
   (H : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, (A -&gt; B) -&gt; G A -&gt; G B)
   (H0 : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, A -&gt; G A)
   (H1 : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, G A * G B -&gt; G (A * B))
   (v1 v2 : <span class="kt">Type</span>) (f : nat * v1 -&gt; G (term v2))
   (t : term v1) {<span class="kr">struct</span> t} : G (term v2) :=
   <span class="kr">match</span> t <span class="kr">with</span>
   | tvar v =&gt; f (<span class="mi">0</span>, v)
   | (<span class="kr">Œª</span>) œÑ body =&gt;
       H ((term v2 -&gt; term v2) * term v2) (term v2)
         (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
         (H1 (term v2 -&gt; term v2) (term v2)
            (H0 (term v2 -&gt; term v2) ((<span class="kr">Œª</span>) œÑ),
             binddt_term G H H0 H1 v1 v2
               (<span class="kr">fun</span> <span class="nv">a</span> : nat * v1 =&gt;
                f (<span class="kr">let</span> &#39;(w1, a0) := a <span class="kr">in</span> (S w1, a0)))
               body))
   | [t1 ]@[ t2] =&gt;
       H ((term v2 -&gt; term v2) * term v2) (term v2)
         (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
         (H1 (term v2 -&gt; term v2) (term v2)
            (H
               ((term v2 -&gt; term v2 -&gt; term v2) *
                term v2) (term v2 -&gt; term v2)
               (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
               (H1 (term v2 -&gt; term v2 -&gt; term v2)
                  (term v2)
                  (H0 (term v2 -&gt; term v2 -&gt; term v2)
                     (app (v:=v2)),
                   binddt_term G H H0 H1 v1 v2 f t1)),
             binddt_term G H H0 H1 v1 v2 f t2))
   <span class="kr">end</span>) (<span class="kr">fun</span> <span class="nv">_</span> : <span class="kt">Type</span> =&gt; M)
  (<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X -&gt; Y) (<span class="nv">t</span> : M) =&gt; t)
  (<span class="kr">fun</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X) =&gt; unit0)
  (<span class="kr">fun</span> (<span class="nv">_</span> <span class="nv">_</span> : <span class="kt">Type</span>) &#39;(x, y) =&gt; op x y) A <span class="kt">False</span>
  (<span class="kr">fun</span> <span class="nv">a</span> : nat * A =&gt;
   f (<span class="kr">let</span> &#39;(w1, a0) := a <span class="kr">in</span> (S w1, a0))) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke0"><span class="nb">change</span> (op unit0 <span class="nl">?f</span>) <span class="kr">with</span> (∆µ ‚óè f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∆µ
‚óè (<span class="kr">fix</span> binddt_term
     (G : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
     (H : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, (A -&gt; B) -&gt; G A -&gt; G B)
     (H0 : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, A -&gt; G A)
     (H1 : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, G A * G B -&gt; G (A * B))
     (v1 v2 : <span class="kt">Type</span>) (f : nat * v1 -&gt; G (term v2))
     (t : term v1) {<span class="kr">struct</span> t} : G (term v2) :=
     <span class="kr">match</span> t <span class="kr">with</span>
     | tvar v =&gt; f (<span class="mi">0</span>, v)
     | (<span class="kr">Œª</span>) œÑ body =&gt;
         H ((term v2 -&gt; term v2) * term v2) (term v2)
           (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
           (H1 (term v2 -&gt; term v2) (term v2)
              (H0 (term v2 -&gt; term v2) ((<span class="kr">Œª</span>) œÑ),
               binddt_term G H H0 H1 v1 v2
                 (<span class="kr">fun</span> <span class="nv">a</span> : nat * v1 =&gt;
                  f (<span class="kr">let</span> &#39;(w1, a0) := a <span class="kr">in</span> (S w1, a0)))
                 body))
     | [t1 ]@[ t2] =&gt;
         H ((term v2 -&gt; term v2) * term v2) (term v2)
           (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
           (H1 (term v2 -&gt; term v2) (term v2)
              (H
                 ((term v2 -&gt; term v2 -&gt; term v2) *
                  term v2) (term v2 -&gt; term v2)
                 (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
                 (H1 (term v2 -&gt; term v2 -&gt; term v2)
                    (term v2)
                    (H0
                       (term v2 -&gt; term v2 -&gt; term v2)
                       (app (v:=v2)),
                     binddt_term G H H0 H1 v1 v2 f t1)),
               binddt_term G H H0 H1 v1 v2 f t2))
     <span class="kr">end</span>) (<span class="kr">fun</span> <span class="nv">_</span> : <span class="kt">Type</span> =&gt; M)
    (<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X -&gt; Y) (<span class="nv">t</span> : M) =&gt; t)
    (<span class="kr">fun</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X) =&gt; unit0)
    (<span class="kr">fun</span> (<span class="nv">_</span> <span class="nv">_</span> : <span class="kt">Type</span>) &#39;(x, y) =&gt; op x y) A <span class="kt">False</span>
    (<span class="kr">fun</span> <span class="nv">a</span> : nat * A =&gt;
     f (<span class="kr">let</span> &#39;(w1, a0) := a <span class="kr">in</span> (S w1, a0))) t =
(<span class="kr">fix</span> binddt_term
   (G : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
   (H : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, (A -&gt; B) -&gt; G A -&gt; G B)
   (H0 : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, A -&gt; G A)
   (H1 : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, G A * G B -&gt; G (A * B))
   (v1 v2 : <span class="kt">Type</span>) (f : nat * v1 -&gt; G (term v2))
   (t : term v1) {<span class="kr">struct</span> t} : G (term v2) :=
   <span class="kr">match</span> t <span class="kr">with</span>
   | tvar v =&gt; f (<span class="mi">0</span>, v)
   | (<span class="kr">Œª</span>) œÑ body =&gt;
       H ((term v2 -&gt; term v2) * term v2) (term v2)
         (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
         (H1 (term v2 -&gt; term v2) (term v2)
            (H0 (term v2 -&gt; term v2) ((<span class="kr">Œª</span>) œÑ),
             binddt_term G H H0 H1 v1 v2
               (<span class="kr">fun</span> <span class="nv">a</span> : nat * v1 =&gt;
                f (<span class="kr">let</span> &#39;(w1, a0) := a <span class="kr">in</span> (S w1, a0)))
               body))
   | [t1 ]@[ t2] =&gt;
       H ((term v2 -&gt; term v2) * term v2) (term v2)
         (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
         (H1 (term v2 -&gt; term v2) (term v2)
            (H
               ((term v2 -&gt; term v2 -&gt; term v2) *
                term v2) (term v2 -&gt; term v2)
               (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
               (H1 (term v2 -&gt; term v2 -&gt; term v2)
                  (term v2)
                  (H0 (term v2 -&gt; term v2 -&gt; term v2)
                     (app (v:=v2)),
                   binddt_term G H H0 H1 v1 v2 f t1)),
             binddt_term G H H0 H1 v1 v2 f t2))
   <span class="kr">end</span>) (<span class="kr">fun</span> <span class="nv">_</span> : <span class="kt">Type</span> =&gt; M)
  (<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X -&gt; Y) (<span class="nv">t</span> : M) =&gt; t)
  (<span class="kr">fun</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X) =&gt; unit0)
  (<span class="kr">fun</span> (<span class="nv">_</span> <span class="nv">_</span> : <span class="kt">Type</span>) &#39;(x, y) =&gt; op x y) A <span class="kt">False</span>
  (<span class="kr">fun</span> <span class="nv">a</span> : nat * A =&gt;
   f (<span class="kr">let</span> &#39;(w1, a0) := a <span class="kr">in</span> (S w1, a0))) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> simpl_monoid.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke1"><span class="kn">Lemma</span> <span class="nf">term_foldMapd3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A),
      foldMapd term f ([t1]@[t2]) = foldMapd term f t1 ‚óè foldMapd term f t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
foldMapd term f ([t1 ]@[ t2]) =
foldMapd term f t1 ‚óè foldMapd term f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
foldMapd term f ([t1 ]@[ t2]) =
foldMapd term f t1 ‚óè foldMapd term f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke3"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMapd term f ([t1 ]@[ t2]) =
foldMapd term f t1 ‚óè foldMapd term f t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke4"><span class="nb">cbv</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">op
  (op unit0
     ((<span class="kr">fix</span> binddt_term
         (G : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
         (H : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>,
              (A -&gt; B) -&gt; G A -&gt; G B)
         (H0 : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, A -&gt; G A)
         (H1 : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>,
               G A * G B -&gt; G (A * B)) (v1 v2 : <span class="kt">Type</span>)
         (f : nat * v1 -&gt; G (term v2)) (t : term v1)
         {<span class="kr">struct</span> t} : G (term v2) :=
         <span class="kr">match</span> t <span class="kr">with</span>
         | tvar v =&gt; f (<span class="mi">0</span>, v)
         | (<span class="kr">Œª</span>) œÑ body =&gt;
             H ((term v2 -&gt; term v2) * term v2)
               (term v2) (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
               (H1 (term v2 -&gt; term v2) (term v2)
                  (H0 (term v2 -&gt; term v2) ((<span class="kr">Œª</span>) œÑ),
                   binddt_term G H H0 H1 v1 v2
                     (<span class="kr">fun</span> <span class="nv">a</span> : nat * v1 =&gt;
                      f
                        (<span class="kr">let</span>
                         &#39;(w1, a0) := a <span class="kr">in</span> (S w1, a0)))
                     body))
         | [t1 ]@[ t2] =&gt;
             H ((term v2 -&gt; term v2) * term v2)
               (term v2) (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
               (H1 (term v2 -&gt; term v2) (term v2)
                  (H
                     ((term v2 -&gt; term v2 -&gt; term v2) *
                      term v2) (term v2 -&gt; term v2)
                     (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
                     (H1
                        (term v2 -&gt; term v2 -&gt; term v2)
                        (term v2)
                        (H0
                           (term v2 -&gt;
                            term v2 -&gt; term v2)
                           (app (v:=v2)),
                         binddt_term G H H0 H1 v1 v2 f
                           t1)),
                   binddt_term G H H0 H1 v1 v2 f t2))
         <span class="kr">end</span>) (<span class="kr">fun</span> <span class="nv">_</span> : <span class="kt">Type</span> =&gt; M)
        (<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X -&gt; Y) (<span class="nv">t</span> : M) =&gt; t)
        (<span class="kr">fun</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X) =&gt; unit0)
        (<span class="kr">fun</span> (<span class="nv">_</span> <span class="nv">_</span> : <span class="kt">Type</span>) &#39;(x, y) =&gt; op x y) A <span class="kt">False</span>
        (<span class="kr">fun</span> <span class="nv">a</span> : nat * A =&gt; f a) t1))
  ((<span class="kr">fix</span> binddt_term
      (G : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
      (H : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, (A -&gt; B) -&gt; G A -&gt; G B)
      (H0 : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, A -&gt; G A)
      (H1 : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, G A * G B -&gt; G (A * B))
      (v1 v2 : <span class="kt">Type</span>) (f : nat * v1 -&gt; G (term v2))
      (t : term v1) {<span class="kr">struct</span> t} : G (term v2) :=
      <span class="kr">match</span> t <span class="kr">with</span>
      | tvar v =&gt; f (<span class="mi">0</span>, v)
      | (<span class="kr">Œª</span>) œÑ body =&gt;
          H ((term v2 -&gt; term v2) * term v2) (term v2)
            (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
            (H1 (term v2 -&gt; term v2) (term v2)
               (H0 (term v2 -&gt; term v2) ((<span class="kr">Œª</span>) œÑ),
                binddt_term G H H0 H1 v1 v2
                  (<span class="kr">fun</span> <span class="nv">a</span> : nat * v1 =&gt;
                   f
                     (<span class="kr">let</span> &#39;(w1, a0) := a <span class="kr">in</span> (S w1, a0)))
                  body))
      | [t1 ]@[ t2] =&gt;
          H ((term v2 -&gt; term v2) * term v2) (term v2)
            (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
            (H1 (term v2 -&gt; term v2) (term v2)
               (H
                  ((term v2 -&gt; term v2 -&gt; term v2) *
                   term v2) (term v2 -&gt; term v2)
                  (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
                  (H1 (term v2 -&gt; term v2 -&gt; term v2)
                     (term v2)
                     (H0
                        (term v2 -&gt; term v2 -&gt; term v2)
                        (app (v:=v2)),
                      binddt_term G H H0 H1 v1 v2 f t1)),
                binddt_term G H H0 H1 v1 v2 f t2))
      <span class="kr">end</span>) (<span class="kr">fun</span> <span class="nv">_</span> : <span class="kt">Type</span> =&gt; M)
     (<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X -&gt; Y) (<span class="nv">t</span> : M) =&gt; t)
     (<span class="kr">fun</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X) =&gt; unit0)
     (<span class="kr">fun</span> (<span class="nv">_</span> <span class="nv">_</span> : <span class="kt">Type</span>) &#39;(x, y) =&gt; op x y) A <span class="kt">False</span>
     (<span class="kr">fun</span> <span class="nv">a</span> : nat * A =&gt; f a) t2) =
op
  ((<span class="kr">fix</span> binddt_term
      (G : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
      (H : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, (A -&gt; B) -&gt; G A -&gt; G B)
      (H0 : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, A -&gt; G A)
      (H1 : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, G A * G B -&gt; G (A * B))
      (v1 v2 : <span class="kt">Type</span>) (f : nat * v1 -&gt; G (term v2))
      (t : term v1) {<span class="kr">struct</span> t} : G (term v2) :=
      <span class="kr">match</span> t <span class="kr">with</span>
      | tvar v =&gt; f (<span class="mi">0</span>, v)
      | (<span class="kr">Œª</span>) œÑ body =&gt;
          H ((term v2 -&gt; term v2) * term v2) (term v2)
            (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
            (H1 (term v2 -&gt; term v2) (term v2)
               (H0 (term v2 -&gt; term v2) ((<span class="kr">Œª</span>) œÑ),
                binddt_term G H H0 H1 v1 v2
                  (<span class="kr">fun</span> <span class="nv">a</span> : nat * v1 =&gt;
                   f
                     (<span class="kr">let</span> &#39;(w1, a0) := a <span class="kr">in</span> (S w1, a0)))
                  body))
      | [t1 ]@[ t2] =&gt;
          H ((term v2 -&gt; term v2) * term v2) (term v2)
            (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
            (H1 (term v2 -&gt; term v2) (term v2)
               (H
                  ((term v2 -&gt; term v2 -&gt; term v2) *
                   term v2) (term v2 -&gt; term v2)
                  (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
                  (H1 (term v2 -&gt; term v2 -&gt; term v2)
                     (term v2)
                     (H0
                        (term v2 -&gt; term v2 -&gt; term v2)
                        (app (v:=v2)),
                      binddt_term G H H0 H1 v1 v2 f t1)),
                binddt_term G H H0 H1 v1 v2 f t2))
      <span class="kr">end</span>) (<span class="kr">fun</span> <span class="nv">_</span> : <span class="kt">Type</span> =&gt; M)
     (<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X -&gt; Y) (<span class="nv">t</span> : M) =&gt; t)
     (<span class="kr">fun</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X) =&gt; unit0)
     (<span class="kr">fun</span> (<span class="nv">_</span> <span class="nv">_</span> : <span class="kt">Type</span>) &#39;(x, y) =&gt; op x y) A <span class="kt">False</span>
     (<span class="kr">fun</span> <span class="nv">a</span> : nat * A =&gt; f a) t1)
  ((<span class="kr">fix</span> binddt_term
      (G : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
      (H : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, (A -&gt; B) -&gt; G A -&gt; G B)
      (H0 : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, A -&gt; G A)
      (H1 : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, G A * G B -&gt; G (A * B))
      (v1 v2 : <span class="kt">Type</span>) (f : nat * v1 -&gt; G (term v2))
      (t : term v1) {<span class="kr">struct</span> t} : G (term v2) :=
      <span class="kr">match</span> t <span class="kr">with</span>
      | tvar v =&gt; f (<span class="mi">0</span>, v)
      | (<span class="kr">Œª</span>) œÑ body =&gt;
          H ((term v2 -&gt; term v2) * term v2) (term v2)
            (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
            (H1 (term v2 -&gt; term v2) (term v2)
               (H0 (term v2 -&gt; term v2) ((<span class="kr">Œª</span>) œÑ),
                binddt_term G H H0 H1 v1 v2
                  (<span class="kr">fun</span> <span class="nv">a</span> : nat * v1 =&gt;
                   f
                     (<span class="kr">let</span> &#39;(w1, a0) := a <span class="kr">in</span> (S w1, a0)))
                  body))
      | [t1 ]@[ t2] =&gt;
          H ((term v2 -&gt; term v2) * term v2) (term v2)
            (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
            (H1 (term v2 -&gt; term v2) (term v2)
               (H
                  ((term v2 -&gt; term v2 -&gt; term v2) *
                   term v2) (term v2 -&gt; term v2)
                  (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
                  (H1 (term v2 -&gt; term v2 -&gt; term v2)
                     (term v2)
                     (H0
                        (term v2 -&gt; term v2 -&gt; term v2)
                        (app (v:=v2)),
                      binddt_term G H H0 H1 v1 v2 f t1)),
                binddt_term G H H0 H1 v1 v2 f t2))
      <span class="kr">end</span>) (<span class="kr">fun</span> <span class="nv">_</span> : <span class="kt">Type</span> =&gt; M)
     (<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X -&gt; Y) (<span class="nv">t</span> : M) =&gt; t)
     (<span class="kr">fun</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X) =&gt; unit0)
     (<span class="kr">fun</span> (<span class="nv">_</span> <span class="nv">_</span> : <span class="kt">Type</span>) &#39;(x, y) =&gt; op x y) A <span class="kt">False</span>
     (<span class="kr">fun</span> <span class="nv">a</span> : nat * A =&gt; f a) t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke5"><span class="nb">change</span> (op unit0 <span class="nl">?f</span>) <span class="kr">with</span> (∆µ ‚óè f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">op
  (∆µ
   ‚óè (<span class="kr">fix</span> binddt_term
        (G : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
        (H : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, (A -&gt; B) -&gt; G A -&gt; G B)
        (H0 : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, A -&gt; G A)
        (H1 : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>,
              G A * G B -&gt; G (A * B)) (v1 v2 : <span class="kt">Type</span>)
        (f : nat * v1 -&gt; G (term v2)) (t : term v1)
        {<span class="kr">struct</span> t} : G (term v2) :=
        <span class="kr">match</span> t <span class="kr">with</span>
        | tvar v =&gt; f (<span class="mi">0</span>, v)
        | (<span class="kr">Œª</span>) œÑ body =&gt;
            H ((term v2 -&gt; term v2) * term v2)
              (term v2) (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
              (H1 (term v2 -&gt; term v2) (term v2)
                 (H0 (term v2 -&gt; term v2) ((<span class="kr">Œª</span>) œÑ),
                  binddt_term G H H0 H1 v1 v2
                    (<span class="kr">fun</span> <span class="nv">a</span> : nat * v1 =&gt;
                     f
                       (<span class="kr">let</span>
                        &#39;(w1, a0) := a <span class="kr">in</span> (S w1, a0)))
                    body))
        | [t1 ]@[ t2] =&gt;
            H ((term v2 -&gt; term v2) * term v2)
              (term v2) (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
              (H1 (term v2 -&gt; term v2) (term v2)
                 (H
                    ((term v2 -&gt; term v2 -&gt; term v2) *
                     term v2) (term v2 -&gt; term v2)
                    (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
                    (H1
                       (term v2 -&gt; term v2 -&gt; term v2)
                       (term v2)
                       (H0
                          (term v2 -&gt;
                           term v2 -&gt; term v2)
                          (app (v:=v2)),
                        binddt_term G H H0 H1 v1 v2 f
                          t1)),
                  binddt_term G H H0 H1 v1 v2 f t2))
        <span class="kr">end</span>) (<span class="kr">fun</span> <span class="nv">_</span> : <span class="kt">Type</span> =&gt; M)
       (<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X -&gt; Y) (<span class="nv">t</span> : M) =&gt; t)
       (<span class="kr">fun</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X) =&gt; unit0)
       (<span class="kr">fun</span> (<span class="nv">_</span> <span class="nv">_</span> : <span class="kt">Type</span>) &#39;(x, y) =&gt; op x y) A <span class="kt">False</span>
       (<span class="kr">fun</span> <span class="nv">a</span> : nat * A =&gt; f a) t1)
  ((<span class="kr">fix</span> binddt_term
      (G : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
      (H : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, (A -&gt; B) -&gt; G A -&gt; G B)
      (H0 : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, A -&gt; G A)
      (H1 : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, G A * G B -&gt; G (A * B))
      (v1 v2 : <span class="kt">Type</span>) (f : nat * v1 -&gt; G (term v2))
      (t : term v1) {<span class="kr">struct</span> t} : G (term v2) :=
      <span class="kr">match</span> t <span class="kr">with</span>
      | tvar v =&gt; f (<span class="mi">0</span>, v)
      | (<span class="kr">Œª</span>) œÑ body =&gt;
          H ((term v2 -&gt; term v2) * term v2) (term v2)
            (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
            (H1 (term v2 -&gt; term v2) (term v2)
               (H0 (term v2 -&gt; term v2) ((<span class="kr">Œª</span>) œÑ),
                binddt_term G H H0 H1 v1 v2
                  (<span class="kr">fun</span> <span class="nv">a</span> : nat * v1 =&gt;
                   f
                     (<span class="kr">let</span> &#39;(w1, a0) := a <span class="kr">in</span> (S w1, a0)))
                  body))
      | [t1 ]@[ t2] =&gt;
          H ((term v2 -&gt; term v2) * term v2) (term v2)
            (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
            (H1 (term v2 -&gt; term v2) (term v2)
               (H
                  ((term v2 -&gt; term v2 -&gt; term v2) *
                   term v2) (term v2 -&gt; term v2)
                  (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
                  (H1 (term v2 -&gt; term v2 -&gt; term v2)
                     (term v2)
                     (H0
                        (term v2 -&gt; term v2 -&gt; term v2)
                        (app (v:=v2)),
                      binddt_term G H H0 H1 v1 v2 f t1)),
                binddt_term G H H0 H1 v1 v2 f t2))
      <span class="kr">end</span>) (<span class="kr">fun</span> <span class="nv">_</span> : <span class="kt">Type</span> =&gt; M)
     (<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X -&gt; Y) (<span class="nv">t</span> : M) =&gt; t)
     (<span class="kr">fun</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X) =&gt; unit0)
     (<span class="kr">fun</span> (<span class="nv">_</span> <span class="nv">_</span> : <span class="kt">Type</span>) &#39;(x, y) =&gt; op x y) A <span class="kt">False</span>
     (<span class="kr">fun</span> <span class="nv">a</span> : nat * A =&gt; f a) t2) =
op
  ((<span class="kr">fix</span> binddt_term
      (G : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
      (H : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, (A -&gt; B) -&gt; G A -&gt; G B)
      (H0 : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, A -&gt; G A)
      (H1 : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, G A * G B -&gt; G (A * B))
      (v1 v2 : <span class="kt">Type</span>) (f : nat * v1 -&gt; G (term v2))
      (t : term v1) {<span class="kr">struct</span> t} : G (term v2) :=
      <span class="kr">match</span> t <span class="kr">with</span>
      | tvar v =&gt; f (<span class="mi">0</span>, v)
      | (<span class="kr">Œª</span>) œÑ body =&gt;
          H ((term v2 -&gt; term v2) * term v2) (term v2)
            (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
            (H1 (term v2 -&gt; term v2) (term v2)
               (H0 (term v2 -&gt; term v2) ((<span class="kr">Œª</span>) œÑ),
                binddt_term G H H0 H1 v1 v2
                  (<span class="kr">fun</span> <span class="nv">a</span> : nat * v1 =&gt;
                   f
                     (<span class="kr">let</span> &#39;(w1, a0) := a <span class="kr">in</span> (S w1, a0)))
                  body))
      | [t1 ]@[ t2] =&gt;
          H ((term v2 -&gt; term v2) * term v2) (term v2)
            (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
            (H1 (term v2 -&gt; term v2) (term v2)
               (H
                  ((term v2 -&gt; term v2 -&gt; term v2) *
                   term v2) (term v2 -&gt; term v2)
                  (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
                  (H1 (term v2 -&gt; term v2 -&gt; term v2)
                     (term v2)
                     (H0
                        (term v2 -&gt; term v2 -&gt; term v2)
                        (app (v:=v2)),
                      binddt_term G H H0 H1 v1 v2 f t1)),
                binddt_term G H H0 H1 v1 v2 f t2))
      <span class="kr">end</span>) (<span class="kr">fun</span> <span class="nv">_</span> : <span class="kt">Type</span> =&gt; M)
     (<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X -&gt; Y) (<span class="nv">t</span> : M) =&gt; t)
     (<span class="kr">fun</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X) =&gt; unit0)
     (<span class="kr">fun</span> (<span class="nv">_</span> <span class="nv">_</span> : <span class="kt">Type</span>) &#39;(x, y) =&gt; op x y) A <span class="kt">False</span>
     (<span class="kr">fun</span> <span class="nv">a</span> : nat * A =&gt; f a) t1)
  ((<span class="kr">fix</span> binddt_term
      (G : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
      (H : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, (A -&gt; B) -&gt; G A -&gt; G B)
      (H0 : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, A -&gt; G A)
      (H1 : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, G A * G B -&gt; G (A * B))
      (v1 v2 : <span class="kt">Type</span>) (f : nat * v1 -&gt; G (term v2))
      (t : term v1) {<span class="kr">struct</span> t} : G (term v2) :=
      <span class="kr">match</span> t <span class="kr">with</span>
      | tvar v =&gt; f (<span class="mi">0</span>, v)
      | (<span class="kr">Œª</span>) œÑ body =&gt;
          H ((term v2 -&gt; term v2) * term v2) (term v2)
            (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
            (H1 (term v2 -&gt; term v2) (term v2)
               (H0 (term v2 -&gt; term v2) ((<span class="kr">Œª</span>) œÑ),
                binddt_term G H H0 H1 v1 v2
                  (<span class="kr">fun</span> <span class="nv">a</span> : nat * v1 =&gt;
                   f
                     (<span class="kr">let</span> &#39;(w1, a0) := a <span class="kr">in</span> (S w1, a0)))
                  body))
      | [t1 ]@[ t2] =&gt;
          H ((term v2 -&gt; term v2) * term v2) (term v2)
            (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
            (H1 (term v2 -&gt; term v2) (term v2)
               (H
                  ((term v2 -&gt; term v2 -&gt; term v2) *
                   term v2) (term v2 -&gt; term v2)
                  (<span class="kr">fun</span> &#39;(f0, a) =&gt; f0 a)
                  (H1 (term v2 -&gt; term v2 -&gt; term v2)
                     (term v2)
                     (H0
                        (term v2 -&gt; term v2 -&gt; term v2)
                        (app (v:=v2)),
                      binddt_term G H H0 H1 v1 v2 f t1)),
                binddt_term G H H0 H1 v1 v2 f t2))
      <span class="kr">end</span>) (<span class="kr">fun</span> <span class="nv">_</span> : <span class="kt">Type</span> =&gt; M)
     (<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X -&gt; Y) (<span class="nv">t</span> : M) =&gt; t)
     (<span class="kr">fun</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">_</span> : X) =&gt; unit0)
     (<span class="kr">fun</span> (<span class="nv">_</span> <span class="nv">_</span> : <span class="kt">Type</span>) &#39;(x, y) =&gt; op x y) A <span class="kt">False</span>
     (<span class="kr">fun</span> <span class="nv">a</span> : nat * A =&gt; f a) t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> simpl_monoid.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">term_foldMapd_rewrite</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Import</span> Data.<span class="kt">Prop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">test</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">A</span> : <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke6"><span class="kn">Check</span> @Monoid_Morphism (A -&gt; <span class="kt">Prop</span>) <span class="kt">Prop</span> (@Monoid_op_set A) Monoid_unit_set
    Monoid_op_or Monoid_unit_false.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Monoid_Morphism
     : ((A -&gt; <span class="kt">Prop</span>) -&gt; <span class="kt">Prop</span>) -&gt; <span class="kt">Prop</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke7">#[export] <span class="kn">Instance</span> <span class="nf">MonMor_evalAt</span> :
    <span class="kr">forall</span> (<span class="nv">a</span> : A), @Monoid_Morphism (A -&gt; <span class="kt">Prop</span>) <span class="kt">Prop</span> (@Monoid_op_set A) Monoid_unit_set
                 Monoid_op_or Monoid_unit_false (evalAt a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, Monoid_Morphism (evalAt a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, Monoid_Morphism (evalAt a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke9"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Monoid_Morphism (evalAt a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkea"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Monoid (A -&gt; <span class="kt">Prop</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chkeb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="syntax-v-chkeb"><hr></label><div class="goal-conclusion">Monoid <span class="kt">Prop</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chkec" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="syntax-v-chkec"><hr></label><div class="goal-conclusion">evalAt a ∆µ = ∆µ</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chked" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="syntax-v-chked"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : A -&gt; <span class="kt">Prop</span>,
evalAt a (a1 ‚óè a2) = evalAt a a1 ‚óè evalAt a a2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkee">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Monoid (A -&gt; <span class="kt">Prop</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkef">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Monoid <span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evalAt a ∆µ = ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : A -&gt; <span class="kt">Prop</span>,
evalAt a (a1 ‚óè a2) = evalAt a a1 ‚óè evalAt a a2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">test</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Rewriting lemmas for &lt;&lt;‚ààd&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">term_ind_rewrite</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf2"><span class="kn">Lemma</span> <span class="nf">term_ind1</span> : <span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> : LN) (<span class="nv">n</span> : nat),
      (n, l1) ‚ààd (tvar l2) &lt;-&gt; n = ∆µ /\ l1 = l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> : LN) (<span class="nv">n</span> : nat),
(n, l1) ‚ààd tvar l2 &lt;-&gt; n = ∆µ /\ l1 = l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> : LN) (<span class="nv">n</span> : nat),
(n, l1) ‚ààd tvar l2 &lt;-&gt; n = ∆µ /\ l1 = l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf4">introv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(n, l1) ‚ààd tvar l2 &lt;-&gt; n = ∆µ /\ l1 = l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf5">unfold_ops @Tosetd_Kleisli.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))
  (tvar l2) (n, l1) &lt;-&gt; n = ∆µ /\ l1 = l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf6"><span class="nb">rewrite</span> term_foldMapd1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>) (∆µ, l2) (n, l1) &lt;-&gt;
n = ∆µ /\ l1 = l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf7"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>) (∆µ, l2) (n, l1) -&gt;
n = ∆µ /\ l1 = l2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chkf8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="syntax-v-chkf8"><hr></label><div class="goal-conclusion">n = ∆µ /\ l1 = l2 -&gt;
ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>) (∆µ, l2) (n, l1)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>) (∆µ, l2) (n, l1) -&gt;
n = ∆µ /\ l1 = l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">inversion</span> <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkfa">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = ∆µ /\ l1 = l2 -&gt;
ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>) (∆µ, l2) (n, l1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkfb"><span class="nb">inversion</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n = ∆µ /\ l1 = l2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n = ∆µ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>l1 = l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>) (∆µ, l2) (n, l1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">subst</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkfc"><span class="kn">Lemma</span> <span class="nf">term_ind2</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">l</span> : LN) (<span class="nv">n</span> : nat) (<span class="nv">X</span> : typ),
      (n, l) ‚ààd t = (S n, l) ‚ààd (<span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">t</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">l</span> : LN) (<span class="nv">n</span> : nat) (<span class="nv">X</span> : typ),
(n, l) ‚ààd t = (S n, l) ‚ààd (<span class="kr">Œª</span>) X t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkfd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">l</span> : LN) (<span class="nv">n</span> : nat) (<span class="nv">X</span> : typ),
(n, l) ‚ààd t = (S n, l) ‚ààd (<span class="kr">Œª</span>) X t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkfe">introv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(n, l) ‚ààd t = (S n, l) ‚ààd (<span class="kr">Œª</span>) X t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkff">unfold_ops @Tosetd_Kleisli.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t
  (n, l) =
foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))
  ((<span class="kr">Œª</span>) X t) (S n, l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk100"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t
  (n, l) =
(pure (const (nat * LN -&gt; <span class="kt">Prop</span>)) ((<span class="kr">Œª</span>) X)
 ‚óè binddt term (const (nat * LN -&gt; <span class="kt">Prop</span>))
     (preincr <span class="mi">1</span>
        (fmap (const (nat * LN -&gt; <span class="kt">Prop</span>)) (ret term)
         ‚àò ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))) t)
  (S n, l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk101">unfold_ops @Pure_const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t
  (n, l) =
(∆µ
 ‚óè binddt term (const (nat * LN -&gt; <span class="kt">Prop</span>))
     (preincr <span class="mi">1</span>
        (fmap (const (nat * LN -&gt; <span class="kt">Prop</span>)) (ret term)
         ‚àò ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))) t)
  (S n, l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk102">simpl_monoid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t
  (n, l) =
binddt term (const (nat * LN -&gt; <span class="kt">Prop</span>))
  (preincr <span class="mi">1</span>
     (fmap (const (nat * LN -&gt; <span class="kt">Prop</span>)) (ret term)
      ‚àò ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))) t (S n, l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk103">change_right (foldMapd term (preincr <span class="mi">1</span> (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))) t (S n, l)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t
  (n, l) =
foldMapd term
  (preincr <span class="mi">1</span> (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))) t
  (S n, l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk104"><span class="nb">change</span> (foldMapd term <span class="nl">?f</span> <span class="nl">?t</span> <span class="nl">?a</span>) <span class="kr">with</span> ((evalAt a ‚àò foldMapd term f) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(evalAt (n, l)
 ‚àò foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))) t =
(evalAt (S n, l)
 ‚àò foldMapd term
     (preincr <span class="mi">1</span> (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)))) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk105"><span class="nb">rewrite</span> (foldMapd_morphism term).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMapd term
  (evalAt (n, l) ‚àò ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t =
(evalAt (S n, l)
 ‚àò foldMapd term
     (preincr <span class="mi">1</span> (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)))) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk106"><span class="nb">rewrite</span> (foldMapd_morphism term).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMapd term
  (evalAt (n, l) ‚àò ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t =
foldMapd term
  (evalAt (S n, l)
   ‚àò preincr <span class="mi">1</span> (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk107">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evalAt (n, l) ‚àò ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>) =
evalAt (S n, l)
‚àò preincr <span class="mi">1</span> (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk108">ext [na la].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>na</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>la</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(evalAt (n, l) ‚àò ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))
  (na, la) =
(evalAt (S n, l)
 ‚àò preincr <span class="mi">1</span> (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)))
  (na, la)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk109"><span class="nb">cbv</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>na</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>la</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((na, la) = (n, l)) = ((S na, la) = (S n, l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">propext; <span class="nb">inversion</span> <span class="mi">1</span>; <span class="bp">now</span> <span class="nb">subst</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk10a"><span class="kn">Lemma</span> <span class="nf">term_ind2&#39;</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">l</span> : LN) (<span class="nv">n</span> : nat) (<span class="nv">X</span> : typ),
      (n, l) ‚ààd (<span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">t</span>) = ((n - <span class="mi">1</span>, l) ‚ààd t /\ n &lt;&gt; <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">l</span> : LN) (<span class="nv">n</span> : nat) (<span class="nv">X</span> : typ),
(n, l) ‚ààd (<span class="kr">Œª</span>) X t = ((n - <span class="mi">1</span>, l) ‚ààd t /\ n &lt;&gt; <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk10b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">l</span> : LN) (<span class="nv">n</span> : nat) (<span class="nv">X</span> : typ),
(n, l) ‚ààd (<span class="kr">Œª</span>) X t = ((n - <span class="mi">1</span>, l) ‚ààd t /\ n &lt;&gt; <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk10c">introv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(n, l) ‚ààd (<span class="kr">Œª</span>) X t = ((n - <span class="mi">1</span>, l) ‚ààd t /\ n &lt;&gt; <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk10d">unfold_ops @Tosetd_Kleisli.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))
  ((<span class="kr">Œª</span>) X t) (n, l) =
(foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t
   (n - <span class="mi">1</span>, l) /\ n &lt;&gt; <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk10e"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pure (const (nat * LN -&gt; <span class="kt">Prop</span>)) ((<span class="kr">Œª</span>) X)
 ‚óè binddt term (const (nat * LN -&gt; <span class="kt">Prop</span>))
     (preincr <span class="mi">1</span>
        (fmap (const (nat * LN -&gt; <span class="kt">Prop</span>)) (ret term)
         ‚àò ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))) t) (n, l) =
(foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t
   (n - <span class="mi">1</span>, l) /\ n &lt;&gt; <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk10f">unfold_ops @Pure_const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(∆µ
 ‚óè binddt term (const (nat * LN -&gt; <span class="kt">Prop</span>))
     (preincr <span class="mi">1</span>
        (fmap (const (nat * LN -&gt; <span class="kt">Prop</span>)) (ret term)
         ‚àò ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))) t) (n, l) =
(foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t
   (n - <span class="mi">1</span>, l) /\ n &lt;&gt; <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk110">simpl_monoid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">binddt term (const (nat * LN -&gt; <span class="kt">Prop</span>))
  (preincr <span class="mi">1</span>
     (fmap (const (nat * LN -&gt; <span class="kt">Prop</span>)) (ret term)
      ‚àò ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))) t (n, l) =
(foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t
   (n - <span class="mi">1</span>, l) /\ n &lt;&gt; <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk111">change_left (foldMapd term (preincr <span class="mi">1</span> (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))) t (n, l)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMapd term
  (preincr <span class="mi">1</span> (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))) t
  (n, l) =
(foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t
   (n - <span class="mi">1</span>, l) /\ n &lt;&gt; <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk112"><span class="nb">change</span> (foldMapd term <span class="nl">?f</span> <span class="nl">?t</span> <span class="nl">?a</span>) <span class="kr">with</span> ((evalAt a ‚àò foldMapd term f) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(evalAt (n, l)
 ‚àò foldMapd term
     (preincr <span class="mi">1</span> (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)))) t =
((evalAt (n - <span class="mi">1</span>, l)
  ‚àò foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))) t /\
 n &lt;&gt; <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk113"><span class="nb">rewrite</span> (foldMapd_morphism term).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMapd term
  (evalAt (n, l)
   ‚àò preincr <span class="mi">1</span> (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))) t =
((evalAt (n - <span class="mi">1</span>, l)
  ‚àò foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))) t /\
 n &lt;&gt; <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk114"><span class="nb">rewrite</span> (foldMapd_morphism term).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMapd term
  (evalAt (n, l)
   ‚àò preincr <span class="mi">1</span> (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))) t =
(foldMapd term
   (evalAt (n - <span class="mi">1</span>, l)
    ‚àò ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t /\ n &lt;&gt; <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk115">propext.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMapd term
  (evalAt (n, l)
   ‚àò preincr <span class="mi">1</span> (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))) t -&gt;
foldMapd term
  (evalAt (n - <span class="mi">1</span>, l) ‚àò ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))
  t /\ n &lt;&gt; <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk116" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk116"><hr></label><div class="goal-conclusion">foldMapd term
  (evalAt (n - <span class="mi">1</span>, l) ‚àò ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))
  t /\ n &lt;&gt; <span class="mi">0</span> -&gt;
foldMapd term
  (evalAt (n, l)
   ‚àò preincr <span class="mi">1</span> (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))) t</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk117">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMapd term
  (evalAt (n, l)
   ‚àò preincr <span class="mi">1</span> (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))) t -&gt;
foldMapd term
  (evalAt (n - <span class="mi">1</span>, l) ‚àò ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))
  t /\ n &lt;&gt; <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk118"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>foldMapd term
  (evalAt (n, l)
   ‚àò preincr <span class="mi">1</span> (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)))
  t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMapd term
  (evalAt (n - <span class="mi">1</span>, l) ‚àò ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))
  t /\ n &lt;&gt; <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk119"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>foldMapd term
  (evalAt (n, l)
   ‚àò preincr <span class="mi">1</span> (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)))
  t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMapd term
  (evalAt (n - <span class="mi">1</span>, l) ‚àò ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))
  t</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk11a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>foldMapd term
  (evalAt (n, l)
   ‚àò preincr <span class="mi">1</span> (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)))
  t</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk11a"><hr></label><div class="goal-conclusion">n &lt;&gt; <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk11b"><span class="nb">admit</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>foldMapd term
  (evalAt (n, l)
   ‚àò preincr <span class="mi">1</span> (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)))
  t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;&gt; <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">admit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk11c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMapd term
  (evalAt (n - <span class="mi">1</span>, l) ‚àò ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))
  t /\ n &lt;&gt; <span class="mi">0</span> -&gt;
foldMapd term
  (evalAt (n, l)
   ‚àò preincr <span class="mi">1</span> (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">admit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk11d"><span class="kn">Lemma</span> <span class="nf">term_ind3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term LN) (<span class="nv">n</span> : nat) (<span class="nv">l</span> : LN),
      (n, l) ‚ààd ([t1]@[t2]) &lt;-&gt; (n, l) ‚ààd t1 \/ (n, l) ‚ààd t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term LN) (<span class="nv">n</span> : nat) (<span class="nv">l</span> : LN),
(n, l) ‚ààd ([t1 ]@[ t2]) &lt;-&gt;
(n, l) ‚ààd t1 \/ (n, l) ‚ààd t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk11e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term LN) (<span class="nv">n</span> : nat) (<span class="nv">l</span> : LN),
(n, l) ‚ààd ([t1 ]@[ t2]) &lt;-&gt;
(n, l) ‚ààd t1 \/ (n, l) ‚ààd t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk11f">introv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(n, l) ‚ààd ([t1 ]@[ t2]) &lt;-&gt;
(n, l) ‚ààd t1 \/ (n, l) ‚ààd t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk120">unfold_ops @Tosetd_Kleisli.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>))
  ([t1 ]@[ t2]) (n, l) &lt;-&gt;
foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t1
  (n, l) \/
foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t2
  (n, l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk121"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((pure (const (nat * LN -&gt; <span class="kt">Prop</span>)) (app (v:=<span class="kt">False</span>))
  ‚óè foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t1)
 ‚óè foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t2)
  (n, l) &lt;-&gt;
foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t1
  (n, l) \/
foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t2
  (n, l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk122">unfold_ops @Pure_const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((∆µ
  ‚óè foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t1)
 ‚óè foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t2)
  (n, l) &lt;-&gt;
foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t1
  (n, l) \/
foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t2
  (n, l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk123">simpl_monoid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t1
 ‚óè foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t2)
  (n, l) &lt;-&gt;
foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t1
  (n, l) \/
foldMapd term (ret (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A -&gt; <span class="kt">Prop</span>)) t2
  (n, l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">term_ind_rewrite</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Rewriting lemmas for &lt;&lt;subst&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="sd">(** ** Rewriting lemmas for &lt;&lt;locally_closed&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk124"><span class="kn">Theorem</span> <span class="nf">term_lc_gap11</span> : <span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">m</span> : nat),
    locally_closed_gap term m (tvar (Bd n)) &lt;-&gt; n &lt; m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat,
locally_closed_gap term m (tvar (Bd n)) &lt;-&gt; n &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk125"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat,
locally_closed_gap term m (tvar (Bd n)) &lt;-&gt; n &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk126"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">locally_closed_gap term m (tvar (Bd n)) &lt;-&gt; n &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk127"><span class="nb">unfold</span> locally_closed_gap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
 (w, l) ‚ààd tvar (Bd n) -&gt; is_bound_or_free m (w, l)) &lt;-&gt;
n &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk128"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
 (w, l) ‚ààd tvar (Bd n) -&gt; is_bound_or_free m (w, l)) -&gt;
n &lt; m</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk129" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk129"><hr></label><div class="goal-conclusion">n &lt; m -&gt;
<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
(w, l) ‚ààd tvar (Bd n) -&gt; is_bound_or_free m (w, l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk12a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
 (w, l) ‚ààd tvar (Bd n) -&gt; is_bound_or_free m (w, l)) -&gt;
n &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk12b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
(w, l) ‚ààd tvar (Bd n) -&gt; is_bound_or_free m (w, l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk12c"><span class="nb">specialize</span> (H <span class="mi">0</span> (Bd n)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span>, Bd n) ‚ààd tvar (Bd n) -&gt;
is_bound_or_free m (<span class="mi">0</span>, Bd n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk12d"><span class="nb">rewrite</span> term_ind1 <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> = ∆µ /\ Bd n = Bd n -&gt;
is_bound_or_free m (<span class="mi">0</span>, Bd n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk12e"><span class="nb">specialize</span> (H (<span class="kp">ltac</span>:(<span class="nb">intuition</span>))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_bound_or_free m (<span class="mi">0</span>, Bd n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk12f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; m -&gt;
<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
(w, l) ‚ààd tvar (Bd n) -&gt; is_bound_or_free m (w, l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk130"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; m</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(w, l) ‚ààd tvar (Bd n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_bound_or_free m (w, l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk131"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; m</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(w, l) ‚ààd tvar (Bd n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> l <span class="kr">with</span>
| Fr _ =&gt; <span class="kt">True</span>
| Bd n =&gt; n &lt; w ‚óè m
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk132"><span class="nb">rewrite</span> term_ind1 <span class="kr">in</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; m</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>w = ∆µ /\ l = Bd n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> l <span class="kr">with</span>
| Fr _ =&gt; <span class="kt">True</span>
| Bd n =&gt; n &lt; w ‚óè m
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk133"><span class="nb">destruct</span> H0; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; ∆µ ‚óè m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> simpl_monoid.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk134"><span class="kn">Theorem</span> <span class="nf">term_lc_gap12</span> : <span class="kr">forall</span> (<span class="nv">x</span> : atom) (<span class="nv">m</span> : nat),
    locally_closed_gap term m (tvar (Fr x)) &lt;-&gt; <span class="kt">True</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : atom) (<span class="nv">m</span> : nat),
locally_closed_gap term m (tvar (Fr x)) &lt;-&gt; <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk135"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : atom) (<span class="nv">m</span> : nat),
locally_closed_gap term m (tvar (Fr x)) &lt;-&gt; <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk136"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">locally_closed_gap term m (tvar (Fr x)) &lt;-&gt; <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk137"><span class="nb">unfold</span> locally_closed, locally_closed_gap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
 (w, l) ‚ààd tvar (Fr x) -&gt; is_bound_or_free m (w, l)) &lt;-&gt;
<span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk138"><span class="nb">setoid_rewrite</span> term_ind1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
 w = ∆µ /\ l = Fr x -&gt; is_bound_or_free m (w, l)) &lt;-&gt;
<span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk139"><span class="nb">intuition</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kt">True</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>w = ∆µ</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>l = Fr x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_bound_or_free m (w, l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">subst</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk13a"><span class="kn">Theorem</span> <span class="nf">term_lc_gap2</span> : <span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term LN) (<span class="nv">m</span> : nat),
    locally_closed_gap term m (lam X t) &lt;-&gt; locally_closed_gap term (S m) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term LN) (<span class="nv">m</span> : nat),
locally_closed_gap term m ((<span class="kr">Œª</span>) X t) &lt;-&gt;
locally_closed_gap term (S m) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk13b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term LN) (<span class="nv">m</span> : nat),
locally_closed_gap term m ((<span class="kr">Œª</span>) X t) &lt;-&gt;
locally_closed_gap term (S m) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk13c"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">locally_closed_gap term m ((<span class="kr">Œª</span>) X t) &lt;-&gt;
locally_closed_gap term (S m) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk13d"><span class="nb">unfold</span> locally_closed, locally_closed_gap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
 (w, l) ‚ààd (<span class="kr">Œª</span>) X t -&gt; is_bound_or_free m (w, l)) &lt;-&gt;
(<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
 (w, l) ‚ààd t -&gt; is_bound_or_free (S m) (w, l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk13e"><span class="nb">setoid_rewrite</span> term_ind2&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
 (w - <span class="mi">1</span>, l) ‚ààd t /\ w &lt;&gt; <span class="mi">0</span> -&gt;
 is_bound_or_free m (w, l)) &lt;-&gt;
(<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
 (w, l) ‚ààd t -&gt; is_bound_or_free (S m) (w, l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk13f"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
 (w - <span class="mi">1</span>, l) ‚ààd t /\ w &lt;&gt; <span class="mi">0</span> -&gt;
 is_bound_or_free m (w, l)) -&gt;
<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
(w, l) ‚ààd t -&gt; is_bound_or_free (S m) (w, l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk140" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk140"><hr></label><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
 (w, l) ‚ààd t -&gt; is_bound_or_free (S m) (w, l)) -&gt;
<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
(w - <span class="mi">1</span>, l) ‚ààd t /\ w &lt;&gt; <span class="mi">0</span> -&gt; is_bound_or_free m (w, l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk141">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
 (w - <span class="mi">1</span>, l) ‚ààd t /\ w &lt;&gt; <span class="mi">0</span> -&gt;
 is_bound_or_free m (w, l)) -&gt;
<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
(w, l) ‚ààd t -&gt; is_bound_or_free (S m) (w, l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk142">introv premise hypothesis.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>premise</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
(w - <span class="mi">1</span>, l) ‚ààd t /\ w &lt;&gt; <span class="mi">0</span> -&gt;
is_bound_or_free m (w, l)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>hypothesis</var><span class="hyp-type"><b>: </b><span>(w, l) ‚ààd t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_bound_or_free (S m) (w, l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk143"><span class="nb">destruct</span> l; [<span class="bp">easy</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>premise</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
(w - <span class="mi">1</span>, l) ‚ààd t /\ w &lt;&gt; <span class="mi">0</span> -&gt;
is_bound_or_free m (w, l)</span></span></span><br><span><var>w, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hypothesis</var><span class="hyp-type"><b>: </b><span>(w, Bd n) ‚ààd t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_bound_or_free (S m) (w, Bd n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk144"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>premise</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
(w - <span class="mi">1</span>, l) ‚ààd t /\ w &lt;&gt; <span class="mi">0</span> -&gt;
is_bound_or_free m (w, l)</span></span></span><br><span><var>w, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hypothesis</var><span class="hyp-type"><b>: </b><span>(w, Bd n) ‚ààd t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; w ‚óè S m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk145"><span class="nb">specialize</span> (premise (S w) (Bd n)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>m, w, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>premise</var><span class="hyp-type"><b>: </b><span>(S w - <span class="mi">1</span>, Bd n) ‚ààd t /\ S w &lt;&gt; <span class="mi">0</span> -&gt;
is_bound_or_free m (S w, Bd n)</span></span></span><br><span><var>hypothesis</var><span class="hyp-type"><b>: </b><span>(w, Bd n) ‚ààd t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; w ‚óè S m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk146"><span class="nb">cbn</span> <span class="kr">in</span> premise.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>m, w, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>premise</var><span class="hyp-type"><b>: </b><span>(w - <span class="mi">0</span>, Bd n) ‚ààd t /\ S w &lt;&gt; <span class="mi">0</span> -&gt;
n &lt; S (w ‚óè m)</span></span></span><br><span><var>hypothesis</var><span class="hyp-type"><b>: </b><span>(w, Bd n) ‚ààd t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; w ‚óè S m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk147"><span class="nb">replace</span> (w - <span class="mi">0</span>) <span class="kr">with</span> w <span class="kr">in</span> premise <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>m, w, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>premise</var><span class="hyp-type"><b>: </b><span>(w, Bd n) ‚ààd t /\ S w &lt;&gt; <span class="mi">0</span> -&gt; n &lt; S (w ‚óè m)</span></span></span><br><span><var>hypothesis</var><span class="hyp-type"><b>: </b><span>(w, Bd n) ‚ààd t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; w ‚óè S m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk148"><span class="nb">assert</span> (H : S w &lt;&gt; <span class="mi">0</span>) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>m, w, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>premise</var><span class="hyp-type"><b>: </b><span>(w, Bd n) ‚ààd t /\ S w &lt;&gt; <span class="mi">0</span> -&gt; n &lt; S (w ‚óè m)</span></span></span><br><span><var>hypothesis</var><span class="hyp-type"><b>: </b><span>(w, Bd n) ‚ààd t</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>S w &lt;&gt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; w ‚óè S m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk149"><span class="nb">specialize</span> (premise (conj hypothesis H)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>m, w, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>premise</var><span class="hyp-type"><b>: </b><span>n &lt; S (w ‚óè m)</span></span></span><br><span><var>hypothesis</var><span class="hyp-type"><b>: </b><span>(w, Bd n) ‚ààd t</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>S w &lt;&gt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; w ‚óè S m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">unfold_lia.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk14a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
 (w, l) ‚ààd t -&gt; is_bound_or_free (S m) (w, l)) -&gt;
<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
(w - <span class="mi">1</span>, l) ‚ààd t /\ w &lt;&gt; <span class="mi">0</span> -&gt; is_bound_or_free m (w, l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk14b">introv premise [hypothesis neq0].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>premise</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
(w, l) ‚ààd t -&gt; is_bound_or_free (S m) (w, l)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>hypothesis</var><span class="hyp-type"><b>: </b><span>(w - <span class="mi">1</span>, l) ‚ààd t</span></span></span><br><span><var>neq0</var><span class="hyp-type"><b>: </b><span>w &lt;&gt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_bound_or_free m (w, l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk14c"><span class="nb">destruct</span> l; [<span class="bp">easy</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>premise</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
(w, l) ‚ààd t -&gt; is_bound_or_free (S m) (w, l)</span></span></span><br><span><var>w, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hypothesis</var><span class="hyp-type"><b>: </b><span>(w - <span class="mi">1</span>, Bd n) ‚ààd t</span></span></span><br><span><var>neq0</var><span class="hyp-type"><b>: </b><span>w &lt;&gt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_bound_or_free m (w, Bd n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk14d"><span class="nb">specialize</span>(premise (w - <span class="mi">1</span>) (Bd n) hypothesis).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>m, w, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>premise</var><span class="hyp-type"><b>: </b><span>is_bound_or_free (S m) (w - <span class="mi">1</span>, Bd n)</span></span></span><br><span><var>hypothesis</var><span class="hyp-type"><b>: </b><span>(w - <span class="mi">1</span>, Bd n) ‚ààd t</span></span></span><br><span><var>neq0</var><span class="hyp-type"><b>: </b><span>w &lt;&gt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_bound_or_free m (w, Bd n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk14e"><span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>m, w, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>premise</var><span class="hyp-type"><b>: </b><span>n &lt; w - <span class="mi">1</span> ‚óè S m</span></span></span><br><span><var>hypothesis</var><span class="hyp-type"><b>: </b><span>(w - <span class="mi">1</span>, Bd n) ‚ààd t</span></span></span><br><span><var>neq0</var><span class="hyp-type"><b>: </b><span>w &lt;&gt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; w ‚óè m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">unfold_lia.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk14f"><span class="kn">Theorem</span> <span class="nf">term_lc_gap3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term LN) (<span class="nv">m</span> : nat),
    locally_closed_gap term m ([t1]@[t2]) &lt;-&gt; locally_closed_gap term m t1 /\ locally_closed_gap term m t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term LN) (<span class="nv">m</span> : nat),
locally_closed_gap term m ([t1 ]@[ t2]) &lt;-&gt;
locally_closed_gap term m t1 /\
locally_closed_gap term m t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk150"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term LN) (<span class="nv">m</span> : nat),
locally_closed_gap term m ([t1 ]@[ t2]) &lt;-&gt;
locally_closed_gap term m t1 /\
locally_closed_gap term m t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk151"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">locally_closed_gap term m ([t1 ]@[ t2]) &lt;-&gt;
locally_closed_gap term m t1 /\
locally_closed_gap term m t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk152"><span class="nb">unfold</span> locally_closed, locally_closed_gap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
 (w, l) ‚ààd ([t1 ]@[ t2]) -&gt; is_bound_or_free m (w, l)) &lt;-&gt;
(<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
 (w, l) ‚ààd t1 -&gt; is_bound_or_free m (w, l)) /\
(<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
 (w, l) ‚ààd t2 -&gt; is_bound_or_free m (w, l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk153"><span class="nb">setoid_rewrite</span> term_ind3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
 (w, l) ‚ààd t1 \/ (w, l) ‚ààd t2 -&gt;
 is_bound_or_free m (w, l)) &lt;-&gt;
(<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
 (w, l) ‚ààd t1 -&gt; is_bound_or_free m (w, l)) /\
(<span class="kr">forall</span> (<span class="nv">w</span> : nat) (<span class="nv">l</span> : LN),
 (w, l) ‚ààd t2 -&gt; is_bound_or_free m (w, l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk154"><span class="kn">Theorem</span> <span class="nf">term_lc11</span> : <span class="kr">forall</span> (<span class="nv">n</span> : nat),
    locally_closed term (tvar (Bd n)) &lt;-&gt; <span class="kt">False</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
locally_closed term (tvar (Bd n)) &lt;-&gt; <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk155"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
locally_closed term (tvar (Bd n)) &lt;-&gt; <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk156"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">locally_closed term (tvar (Bd n)) &lt;-&gt; <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk157"><span class="nb">unfold</span> locally_closed.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">locally_closed_gap term <span class="mi">0</span> (tvar (Bd n)) &lt;-&gt; <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> (<span class="nb">rewrite</span> term_lc_gap11).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk158"><span class="kn">Theorem</span> <span class="nf">term_lc12</span> : <span class="kr">forall</span> (<span class="nv">x</span> : atom),
    locally_closed term (tvar (Fr x)) &lt;-&gt; <span class="kt">True</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : atom,
locally_closed term (tvar (Fr x)) &lt;-&gt; <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk159"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : atom,
locally_closed term (tvar (Fr x)) &lt;-&gt; <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk15a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">locally_closed term (tvar (Fr x)) &lt;-&gt; <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk15b"><span class="nb">unfold</span> locally_closed.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">locally_closed_gap term <span class="mi">0</span> (tvar (Fr x)) &lt;-&gt; <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> (<span class="nb">rewrite</span> term_lc_gap12).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk15c"><span class="kn">Theorem</span> <span class="nf">term_lc2</span> : <span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term LN),
    locally_closed term (lam X t) &lt;-&gt; locally_closed_gap term <span class="mi">1</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term LN),
locally_closed term ((<span class="kr">Œª</span>) X t) &lt;-&gt;
locally_closed_gap term <span class="mi">1</span> t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk15d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term LN),
locally_closed term ((<span class="kr">Œª</span>) X t) &lt;-&gt;
locally_closed_gap term <span class="mi">1</span> t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk15e"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">locally_closed term ((<span class="kr">Œª</span>) X t) &lt;-&gt;
locally_closed_gap term <span class="mi">1</span> t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk15f"><span class="nb">unfold</span> locally_closed.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">locally_closed_gap term <span class="mi">0</span> ((<span class="kr">Œª</span>) X t) &lt;-&gt;
locally_closed_gap term <span class="mi">1</span> t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> (<span class="nb">rewrite</span> term_lc_gap2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk160"><span class="kn">Theorem</span> <span class="nf">term_lc3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term LN),
    locally_closed term ([t1]@[t2]) &lt;-&gt; locally_closed term t1 /\ locally_closed term t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term LN,
locally_closed term ([t1 ]@[ t2]) &lt;-&gt;
locally_closed term t1 /\ locally_closed term t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk161"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term LN,
locally_closed term ([t1 ]@[ t2]) &lt;-&gt;
locally_closed term t1 /\ locally_closed term t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk162"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">locally_closed term ([t1 ]@[ t2]) &lt;-&gt;
locally_closed term t1 /\ locally_closed term t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk163"><span class="nb">unfold</span> locally_closed.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">locally_closed_gap term <span class="mi">0</span> ([t1 ]@[ t2]) &lt;-&gt;
locally_closed_gap term <span class="mi">0</span> t1 /\
locally_closed_gap term <span class="mi">0</span> t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">setoid_rewrite</span> term_lc_gap3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
</div>
</div>
</div></body>
</html>
