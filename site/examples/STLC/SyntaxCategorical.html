<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>Formalizing STLC with Tealeaves</title>
<link rel="stylesheet" href="../alectryon.css" type="text/css" />
<link rel="stylesheet" href="../docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="../pygments.css" type="text/css" />
<script type="text/javascript" src="../alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="formalizing-stlc-with-tealeaves">
<h1 class="title">Formalizing STLC with Tealeaves</h1>
<h2 class="subtitle" id="algebraic-presentation">Algebraic presentation</h2>

<p>This file gives a tutorial on proving the decorated traversable monad
laws the for the syntax of the simply-typed lambda calculus (STLC).</p>
<div class="contents topic" id="table-of-contents">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#imports-and-setup" id="toc-entry-1">Imports and setup</a></li>
<li><a class="reference internal" href="#language-definition" id="toc-entry-2">Language Definition</a></li>
<li><a class="reference internal" href="#functor-instances" id="toc-entry-3">Functor instances</a><ul>
<li><a class="reference internal" href="#plain-functor-instance" id="toc-entry-4">Plain Functor instance</a></li>
<li><a class="reference internal" href="#decorated-functor-instance" id="toc-entry-5">Decorated Functor instance</a></li>
<li><a class="reference internal" href="#traversable-functor-instance" id="toc-entry-6">Traversable Functor instance</a></li>
<li><a class="reference internal" href="#decorated-traversable-functor-instance" id="toc-entry-7">Decorated-Traversable Functor instance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#monad-instances" id="toc-entry-8">Monad instances</a><ul>
<li><a class="reference internal" href="#plain-monad-instance" id="toc-entry-9">Plain Monad instance</a></li>
<li><a class="reference internal" href="#decorated-monad-instance" id="toc-entry-10">Decorated Monad instance</a></li>
<li><a class="reference internal" href="#traversable-monad-instance" id="toc-entry-11">Traversable Monad instance</a></li>
<li><a class="reference internal" href="#decorated-traversable-monad-instance" id="toc-entry-12">Decorated-Traversable Monad instance</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="imports-and-setup">
<h1><a class="toc-backref" href="#toc-entry-1">Imports and setup</a></h1>
<p>Since we are using the algebraic typeclass hierarchy, we import modules under
the namespaces <tt class="docutils literal">Classes.Algebraic</tt> and <tt class="docutils literal">Theory.Algebraic.</tt></p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Export</span>
  Classes.DT.Monad
  Classes.Monoid
  Classes.Listable.Functor
  Data.Natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Traversable.Functor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> List.ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Strength.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Monoid.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable All Variables</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Set Implicit Arguments</span>.</span></span></pre></div>
<div class="section" id="language-definition">
<h1><a class="toc-backref" href="#toc-entry-2">Language Definition</a></h1>
<p>The first step with Tealeaves is to define the syntax of the
language. We take a type <tt class="docutils literal">base_typ</tt> of types we consider primitive
(a/k/a atomic). The set of simple types is built up by forming arrows
between types, starting with base types. The syntax of STLC is defined
with three constructors as usual.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">base_typ</span> : <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">typ</span> :=
| base : base_typ -&gt; typ
| arr : typ -&gt; typ -&gt; typ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">base</span> : base_typ &gt;-&gt; typ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* we give more informative names to [Lam]&#39;s arguments</span>
<span class="c"> than Coq would infer otherwise *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">term</span> (<span class="nv">A</span> : <span class="kt">Type</span>) :=
| Var : A -&gt; term A
| Lam : <span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term A), term A
| Ap : term A -&gt; term A -&gt; term A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Notations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;Œª&#39; X ‚ãÖ body&quot;</span> :=
    (Lam X body) (<span class="kn">at level</span> <span class="mi">45</span>) : tealeaves_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ t1 ] [ t2 ]&quot;</span> :=
    (Ap t1 t2) (<span class="kn">at level</span> <span class="mi">40</span>) : tealeaves_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A ‚üπ B&quot;</span> :=
    (arr A B) (<span class="kn">at level</span> <span class="mi">40</span>) : tealeaves_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Notations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Notations.</span></span></pre><p>For convenience, we define an extremely rudimentary Ltac tactic that
will solve the most trivial inductive steps automatically. Namely,
they will attempt to solve a goal in one step by rewriting with the
hypotheses in context (up to two times), then calling <tt class="docutils literal">reflexivity</tt>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">basic</span> t :=
  <span class="nb">induction</span> t;
  [ <span class="bp">reflexivity</span> |
    <span class="nb">simpl</span>; <span class="kr">match goal with</span> H : _ |- _ =&gt; <span class="nb">rewrite</span> H <span class="kr">end</span>; <span class="bp">reflexivity</span> |
    <span class="nb">simpl</span>; <span class="kp">do</span> <span class="mi">2</span> <span class="kr">match goal with</span> H : _ |- _ =&gt; <span class="nb">rewrite</span> H <span class="kr">end</span>; <span class="bp">reflexivity</span> ].</span></span></pre></div>
<div class="section" id="functor-instances">
<h1><a class="toc-backref" href="#toc-entry-3">Functor instances</a></h1>
<div class="section" id="plain-functor-instance">
<h2><a class="toc-backref" href="#toc-entry-4">Plain Functor instance</a></h2>
<p>Note that our datatype <tt class="docutils literal">term</tt> is parameterized by a single type
variable. The first thing we must show is that <tt class="docutils literal">term</tt> is actually
<em>functor</em> in this type argument.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">fmap_term</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">t</span> : term A) : term B :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | Var a =&gt; Var (f a)
  | Lam X t =&gt; Lam X (fmap_term f t)
  | Ap t1 t2 =&gt; Ap (fmap_term f t1) (fmap_term f t2)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Fmap_term</span> : Fmap term := @fmap_term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk0"><span class="kn">Theorem</span> <span class="nf">fmap_id</span> : <span class="kr">forall</span> <span class="nv">A</span>, fmap term id = @id (term A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, fmap term id = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, fmap term id = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk2"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap term id = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk3">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap term id t = id t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk4"><span class="nb">unfold</span> transparent tcs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap_term id t = id t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">basic t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk5"><span class="kn">Theorem</span> <span class="nf">fmap_fmap</span> : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C),
    fmap term g ‚àò fmap term f = fmap term (g ‚àò f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C),
fmap term g ‚àò fmap term f = fmap term (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C),
fmap term g ‚àò fmap term f = fmap term (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk7"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap term g ‚àò fmap term f = fmap term (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk8">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap term g ‚àò fmap term f) t = fmap term (g ‚àò f) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk9"><span class="nb">unfold</span> transparent tcs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap_term g ‚àò fmap_term f) t = fmap_term (g ‚àò f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chka"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap_term g (fmap_term f t) = fmap_term (g ‚óã f) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">basic t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Functor_term</span> : Functor term :=
  {| fun_fmap_id := @fmap_id;
     fun_fmap_fmap := @fmap_fmap;
  |}.</span></span></pre><div class="section" id="rewriting-rules-for-fmap">
<h3>Rewriting rules for <tt class="docutils literal">fmap</tt></h3>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">fmap_term_rewrite</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{f : A -&gt; B}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkb"><span class="kn">Lemma</span> <span class="nf">fmap_term_ap</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A),
      fmap term f (@Ap A t1 t2) = @Ap B (fmap term f t1) (fmap term f t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
fmap term f ([t1][t2]) =
[fmap term f t1][fmap term f t2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
fmap term f ([t1][t2]) =
[fmap term f t1][fmap term f t2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">fmap_term_rewrite</span>.</span></span></pre></div>
</div>
<div class="section" id="decorated-functor-instance">
<h2><a class="toc-backref" href="#toc-entry-5">Decorated Functor instance</a></h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">dec_term</span> {<span class="nv">A</span>} (<span class="nv">t</span> : term A) : term (nat * A) :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | Var a =&gt; Var (∆µ, a)
  | Lam œÑ t =&gt; Lam œÑ (shift term (<span class="mi">1</span>, dec_term t))
  | Ap t1 t2 =&gt; Ap (dec_term t1) (dec_term t2)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Decorate_term</span> : Decorate nat term := @dec_term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkd"><span class="kn">Theorem</span> <span class="nf">dec_natural</span> : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">f</span> : A -&gt; B),
    fmap term (fmap (prod nat) f) ‚àò dec term = dec term ‚àò fmap term f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
fmap term (fmap (prod nat) f) ‚àò dec term =
dec term ‚àò fmap term f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chke"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
fmap term (fmap (prod nat) f) ‚àò dec term =
dec term ‚àò fmap term f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkf"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap term (fmap (prod nat) f) ‚àò dec term =
dec term ‚àò fmap term f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk10"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap term (fmap (prod nat) f) ‚óã dec term =
dec term ‚óã fmap term f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk11">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap term (fmap (prod nat) f) (dec term t) =
dec term (fmap term f t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk12"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap term (fmap (prod nat) f) (dec term (Var a)) =
dec term (fmap term f (Var a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk13" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>fmap term (fmap (prod nat) f) (dec term t) = dec term (fmap term f t)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk13"><hr></label><div class="goal-conclusion">fmap term (fmap (prod nat) f) (dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
dec term (fmap term f (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk14" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>fmap term (fmap (prod nat) f) (dec term t1) =
dec term (fmap term f t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>fmap term (fmap (prod nat) f) (dec term t2) =
dec term (fmap term f t2)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk14"><hr></label><div class="goal-conclusion">fmap term (fmap (prod nat) f) (dec term ([t1][t2])) =
dec term (fmap term f ([t1][t2]))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk15">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap term (fmap (prod nat) f) (dec term (Var a)) =
dec term (fmap term f (Var a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">cbn</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk16">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>fmap term (fmap (prod nat) f) (dec term t) =
dec term (fmap term f t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap term (fmap (prod nat) f) (dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
dec term (fmap term f (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk17"><span class="nb">cbn</span> -[shift].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>fmap term (fmap (prod nat) f) (dec term t) =
dec term (fmap term f t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">Œª</span> <span class="nv">X</span>
‚ãÖ fmap term (fmap (prod nat) f)
    (shift term (<span class="mi">1</span>, dec term t)) =
<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ shift term (<span class="mi">1</span>, dec term (fmap term f t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk18">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>fmap term (fmap (prod nat) f) (dec term t) =
dec term (fmap term f t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap term (fmap (prod nat) f)
  (shift term (<span class="mi">1</span>, dec term t)) =
shift term (<span class="mi">1</span>, dec term (fmap term f t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> dec_helper_1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk19">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>fmap term (fmap (prod nat) f) (dec term t1) =
dec term (fmap term f t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>fmap term (fmap (prod nat) f) (dec term t2) =
dec term (fmap term f t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap term (fmap (prod nat) f) (dec term ([t1][t2])) =
dec term (fmap term f ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk1a"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>fmap term (fmap (prod nat) f) (dec term t1) =
dec term (fmap term f t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>fmap term (fmap (prod nat) f) (dec term t2) =
dec term (fmap term f t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[fmap term (fmap (prod nat) f) (dec term t1)]
[fmap term (fmap (prod nat) f) (dec term t2)] =
[dec term (fmap term f t1)][dec term (fmap term f t2)]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> fequal.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk1b">#[export] <span class="kn">Instance</span>: Natural (@dec nat term _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@dec nat term Decorate_term)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@dec nat term Decorate_term)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk1d"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor term</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor (term ‚óã prod nat)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
fmap (term ‚óã prod nat) f ‚àò dec term =
dec term ‚àò fmap term f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk1e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk1f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor (term ‚óã prod nat)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Functor_compose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk20">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
fmap (term ‚óã prod nat) f ‚àò dec term =
dec term ‚àò fmap term f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> dec_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk21"><span class="kn">Theorem</span> <span class="nf">dec_extract</span> : <span class="kr">forall</span> <span class="nv">A</span>,
    fmap term (extract (prod nat)) ‚àò dec term = @id (term A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
fmap term (extract (prod nat)) ‚àò dec term = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk22"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
fmap term (extract (prod nat)) ‚àò dec term = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk23"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap term (extract (prod nat)) ‚àò dec term = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk24"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap term (extract (prod nat)) ‚óã dec term = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk25">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap term (extract (prod nat)) (dec term t) = id t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk26"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap term (extract (prod nat)) (dec term (Var a)) =
id (Var a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk27" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>fmap term (extract (prod nat)) (dec term t) = id t</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk27"><hr></label><div class="goal-conclusion">fmap term (extract (prod nat)) (dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
id (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk28" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>fmap term (extract (prod nat)) (dec term t1) =
id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>fmap term (extract (prod nat)) (dec term t2) =
id t2</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk28"><hr></label><div class="goal-conclusion">fmap term (extract (prod nat)) (dec term ([t1][t2])) =
id ([t1][t2])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk29">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap term (extract (prod nat)) (dec term (Var a)) =
id (Var a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk2a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>fmap term (extract (prod nat)) (dec term t) =
id t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap term (extract (prod nat)) (dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
id (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk2b"><span class="nb">cbn</span> -[shift].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>fmap term (extract (prod nat)) (dec term t) =
id t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">Œª</span> <span class="nv">X</span>
‚ãÖ fmap term (extract (prod nat))
    (shift term (<span class="mi">1</span>, dec term t)) = 
id (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> dec_helper_2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk2c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>fmap term (extract (prod nat)) (dec term t1) =
id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>fmap term (extract (prod nat)) (dec term t2) =
id t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap term (extract (prod nat)) (dec term ([t1][t2])) =
id ([t1][t2])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk2d"><span class="nb">unfold</span> id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>fmap term (extract (prod nat)) (dec term t1) =
id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>fmap term (extract (prod nat)) (dec term t2) =
id t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap term (extract (prod nat)) (dec term ([t1][t2])) =
[t1][t2]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk2e"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>fmap term (extract (prod nat)) (dec term t1) =
id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>fmap term (extract (prod nat)) (dec term t2) =
id t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[fmap term (extract (prod nat)) (dec term t1)]
[fmap term (extract (prod nat)) (dec term t2)] =
[t1][t2]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> fequal.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk2f"><span class="kn">Theorem</span> <span class="nf">dec_dec</span> : <span class="kr">forall</span> <span class="nv">A</span>,
    dec term ‚àò dec term = fmap term (cojoin (prod nat)) ‚àò dec term (A := A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dec term ‚àò dec term =
fmap term (cojoin (prod nat)) ‚àò dec term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk30"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dec term ‚àò dec term =
fmap term (cojoin (prod nat)) ‚àò dec term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk31"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term ‚àò dec term =
fmap term (cojoin (prod nat)) ‚àò dec term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk32"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term ‚óã dec term =
fmap term (cojoin (prod nat)) ‚óã dec term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk33">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term (dec term t) =
fmap term (cojoin (prod nat)) (dec term t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk34"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term (dec term (Var a)) =
fmap term (cojoin (prod nat)) (dec term (Var a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk35" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dec term (dec term t) = fmap term (cojoin (prod nat)) (dec term t)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk35"><hr></label><div class="goal-conclusion">dec term (dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
fmap term (cojoin (prod nat)) (dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk36" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dec term (dec term t1) =
fmap term (cojoin (prod nat)) (dec term t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dec term (dec term t2) =
fmap term (cojoin (prod nat)) (dec term t2)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk36"><hr></label><div class="goal-conclusion">dec term (dec term ([t1][t2])) =
fmap term (cojoin (prod nat)) (dec term ([t1][t2]))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk37">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term (dec term (Var a)) =
fmap term (cojoin (prod nat)) (dec term (Var a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk38">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dec term (dec term t) =
fmap term (cojoin (prod nat)) (dec term t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term (dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
fmap term (cojoin (prod nat)) (dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk39"><span class="nb">cbn</span> -[shift].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dec term (dec term t) =
fmap term (cojoin (prod nat)) (dec term t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">Œª</span> <span class="nv">X</span>
‚ãÖ shift term
    (<span class="mi">1</span>, dec term (shift term (<span class="mi">1</span>, dec term t))) =
<span class="kr">Œª</span> <span class="nv">X</span>
‚ãÖ fmap term (cojoin (prod nat))
    (shift term (<span class="mi">1</span>, dec term t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk3a">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dec term (dec term t) =
fmap term (cojoin (prod nat)) (dec term t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shift term (<span class="mi">1</span>, dec term (shift term (<span class="mi">1</span>, dec term t))) =
fmap term (cojoin (prod nat))
  (shift term (<span class="mi">1</span>, dec term t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> dec_helper_3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk3b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dec term (dec term t1) =
fmap term (cojoin (prod nat)) (dec term t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dec term (dec term t2) =
fmap term (cojoin (prod nat)) (dec term t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term (dec term ([t1][t2])) =
fmap term (cojoin (prod nat)) (dec term ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk3c"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dec term (dec term t1) =
fmap term (cojoin (prod nat)) (dec term t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dec term (dec term t2) =
fmap term (cojoin (prod nat)) (dec term t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[dec term (dec term t1)][dec term (dec term t2)] =
[fmap term (cojoin (prod nat)) (dec term t1)]
[fmap term (cojoin (prod nat)) (dec term t2)]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">fequal; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk3d">#[export] <span class="kn">Instance</span> <span class="nf">DecoratedFunctor_term</span> : DecoratedFunctor nat term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedFunctor nat term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk3e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedFunctor nat term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk3f"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor term</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@dec nat term Decorate_term)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dec term ‚àò dec term =
fmap term (cojoin (prod nat)) ‚àò dec term</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
fmap term (extract (prod nat)) ‚àò dec term = id</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk40">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk41">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@dec nat term Decorate_term)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk42">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dec term ‚àò dec term =
fmap term (cojoin (prod nat)) ‚àò dec term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> dec_dec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk43">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
fmap term (extract (prod nat)) ‚àò dec term = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> dec_extract.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="section" id="rewriting-rules-for-dec">
<h3>Rewriting rules for <tt class="docutils literal">dec</tt></h3>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">dec_term_rewrite</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{f : A -&gt; B}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk44"><span class="kn">Lemma</span> <span class="nf">dec_term1</span> : <span class="kr">forall</span> (<span class="nv">x</span> : A),
      dec term (Var x) = Var (<span class="mi">0</span>, x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, dec term (Var x) = Var (<span class="mi">0</span>, x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk45"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, dec term (Var x) = Var (<span class="mi">0</span>, x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk46"><span class="kn">Lemma</span> <span class="nf">dec_term21</span> : <span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term A),
      dec term (Lam X t) = shift term (<span class="mi">1</span>, Lam X (dec term t)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term A),
dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) = shift term (<span class="mi">1</span>, <span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ dec term t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk47"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term A),
dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) = shift term (<span class="mi">1</span>, <span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ dec term t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk48"><span class="kn">Lemma</span> <span class="nf">dec_term22</span> : <span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term A),
      dec term (Lam X t) = Lam X (shift term (<span class="mi">1</span>, dec term t)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term A),
dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) = <span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ shift term (<span class="mi">1</span>, dec term t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk49"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term A),
dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) = <span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ shift term (<span class="mi">1</span>, dec term t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk4a"><span class="kn">Lemma</span> <span class="nf">dec_term3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A),
      dec term (Ap t1 t2) = Ap (dec term t1) (dec term t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
dec term ([t1][t2]) = [dec term t1][dec term t2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk4b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
dec term ([t1][t2]) = [dec term t1][dec term t2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">dec_term_rewrite</span>.</span></span></pre></div>
</div>
<div class="section" id="traversable-functor-instance">
<h2><a class="toc-backref" href="#toc-entry-6">Traversable Functor instance</a></h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Applicative.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">dist_term</span> `{Fmap F} `{Pure F} `{Mult F} {A : <span class="kt">Type</span>}
         (t : term (F A)) : F (term A) :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | Var a =&gt; fmap F (@Var A) a
  | Lam X t =&gt; fmap F (Lam X) (dist_term t)
  | Ap t1 t2 =&gt; (pure F (@Ap A))
                 &lt;‚ãÜ&gt; dist_term t1
                 &lt;‚ãÜ&gt; dist_term t2
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span>: Dist term := @dist_term.</span></span></pre><div class="section" id="rewriting-rules-for-dist">
<h3>Rewriting rules for <tt class="docutils literal">dist</tt></h3>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">term_dist_rewrite</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Applicative G}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> (<span class="nv">A</span> : <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk4c"><span class="kn">Lemma</span> <span class="nf">dist_term_var_1</span> : <span class="kr">forall</span> (<span class="nv">x</span> : G A),
    dist term G (@Var (G A) x) = pure G (@Var A) &lt;‚ãÜ&gt; x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G A,
Œ¥ term G (Var x) = pure G (Var (A:=A)) &lt;‚ãÜ&gt; x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk4d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G A,
Œ¥ term G (Var x) = pure G (Var (A:=A)) &lt;‚ãÜ&gt; x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk4e"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (Var x) = pure G (Var (A:=A)) &lt;‚ãÜ&gt; x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk4f"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Var (A:=A)) x = pure G (Var (A:=A)) &lt;‚ãÜ&gt; x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> fmap_to_ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk50"><span class="kn">Lemma</span> <span class="nf">dist_term_var_2</span> : <span class="kr">forall</span> (<span class="nv">x</span> : G A),
    dist term G (@Var (G A) x) = fmap G (@Var A) x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G A,
Œ¥ term G (Var x) = fmap G (Var (A:=A)) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk51"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G A,
Œ¥ term G (Var x) = fmap G (Var (A:=A)) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk52"><span class="kn">Lemma</span> <span class="nf">dist_term_lam_1</span> : <span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term (G A)),
      dist term G (Lam X t) = pure G (Lam X) &lt;‚ãÜ&gt; (dist term G t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term (G A)),
Œ¥ term G (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) = pure G (Lam X) &lt;‚ãÜ&gt; Œ¥ term G t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk53"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term (G A)),
Œ¥ term G (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) = pure G (Lam X) &lt;‚ãÜ&gt; Œ¥ term G t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk54"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) = pure G (Lam X) &lt;‚ãÜ&gt; Œ¥ term G t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk55"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Lam X) (Œ¥ term G t) =
pure G (Lam X) &lt;‚ãÜ&gt; Œ¥ term G t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> fmap_to_ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk56"><span class="kn">Lemma</span> <span class="nf">dist_term_lam_2</span> : <span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term (G A)),
      dist term G (Lam X t) = fmap G (Lam X) (dist term G t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term (G A)),
Œ¥ term G (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) = fmap G (Lam X) (Œ¥ term G t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk57"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term (G A)),
Œ¥ term G (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) = fmap G (Lam X) (Œ¥ term G t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk58"><span class="kn">Lemma</span> <span class="nf">dist_term_ap_1</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term (G A)),
      dist term G (Ap t1 t2) =
      (pure G (@Ap A))
        &lt;‚ãÜ&gt; dist term G t1
        &lt;‚ãÜ&gt; dist term G t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term (G A),
Œ¥ term G ([t1][t2]) =
pure G (Ap (A:=A)) &lt;‚ãÜ&gt; Œ¥ term G t1 &lt;‚ãÜ&gt; Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk59"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term (G A),
Œ¥ term G ([t1][t2]) =
pure G (Ap (A:=A)) &lt;‚ãÜ&gt; Œ¥ term G t1 &lt;‚ãÜ&gt; Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk5a"><span class="kn">Lemma</span> <span class="nf">dist_term_ap_2</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term (G A)),
      dist term G (Ap t1 t2) =
      (fmap G (@Ap A) (dist term G t1)
            &lt;‚ãÜ&gt; dist term G t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term (G A),
Œ¥ term G ([t1][t2]) =
fmap G (Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt; Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk5b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term (G A),
Œ¥ term G ([t1][t2]) =
fmap G (Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt; Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk5c"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G ([t1][t2]) =
fmap G (Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt; Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk5d"><span class="nb">rewrite</span> dist_term_ap_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure G (Ap (A:=A)) &lt;‚ãÜ&gt; Œ¥ term G t1 &lt;‚ãÜ&gt; Œ¥ term G t2 =
fmap G (Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt; Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> fmap_to_ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">term_dist_rewrite</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">dist_term_properties</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Applicative G}.</span></span></pre></div>
<div class="section" id="naturality-of-dist">
<h3>Naturality of <tt class="docutils literal">dist</tt></h3>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk5e"><span class="kn">Lemma</span> <span class="nf">dist_natural_term</span> : <span class="kr">forall</span> `(f : A -&gt; B),
      fmap (G ‚àò term) f ‚àò dist term G =
      dist term G ‚àò fmap (term ‚àò G) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
fmap (G ‚àò term) f ‚àò Œ¥ term G =
Œ¥ term G ‚àò fmap (term ‚àò G) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk5f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
fmap (G ‚àò term) f ‚àò Œ¥ term G =
Œ¥ term G ‚àò fmap (term ‚àò G) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk60"><span class="nb">intros</span>; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (G ‚àò term) f ‚àò Œ¥ term G =
Œ¥ term G ‚àò fmap (term ‚àò G) f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk61">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap (G ‚àò term) f ‚àò Œ¥ term G) t =
(Œ¥ term G ‚àò fmap (term ‚àò G) f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk62">unfold_ops @Fmap_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap G (fmap term f) ‚àò Œ¥ term G) t =
(Œ¥ term G ‚àò fmap term (fmap G f)) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk63"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (fmap term f) (Œ¥ term G t) =
Œ¥ term G (fmap term (fmap G f) t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk64"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (fmap term f) (Œ¥ term G (Var a)) =
Œ¥ term G (fmap term (fmap G f) (Var a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk65" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t) = Œ¥ term G (fmap term (fmap G f) t)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk65"><hr></label><div class="goal-conclusion">fmap G (fmap term f) (Œ¥ term G (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
Œ¥ term G (fmap term (fmap G f) (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk66" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t1) =
Œ¥ term G (fmap term (fmap G f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t2) =
Œ¥ term G (fmap term (fmap G f) t2)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk66"><hr></label><div class="goal-conclusion">fmap G (fmap term f) (Œ¥ term G ([t1][t2])) =
Œ¥ term G (fmap term (fmap G f) ([t1][t2]))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk67">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (fmap term f) (Œ¥ term G (Var a)) =
Œ¥ term G (fmap term (fmap G f) (Var a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk68"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (fmap term f) (fmap G (Var (A:=A)) a) =
fmap G (Var (A:=B)) (fmap G f a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk69">compose near a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap G (fmap term f) ‚àò fmap G (Var (A:=A))) a =
(fmap G (Var (A:=B)) ‚àò fmap G f) a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> <span class="mi">2</span>(fun_fmap_fmap G).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk6a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t) =
Œ¥ term G (fmap term (fmap G f) t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (fmap term f) (Œ¥ term G (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
Œ¥ term G (fmap term (fmap G f) (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk6b"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t) =
Œ¥ term G (fmap term (fmap G f) t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (fmap term f) (fmap G (Lam X) (Œ¥ term G t)) =
fmap G (Lam X) (Œ¥ term G (fmap term (fmap G f) t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk6c"><span class="nb">rewrite</span> &lt;- IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t) =
Œ¥ term G (fmap term (fmap G f) t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (fmap term f) (fmap G (Lam X) (Œ¥ term G t)) =
fmap G (Lam X) (fmap G (fmap term f) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk6d">compose near (dist term G t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t) =
Œ¥ term G (fmap term (fmap G f) t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap G (fmap term f) ‚àò fmap G (Lam X)) (Œ¥ term G t) =
(fmap G (Lam X) ‚àò fmap G (fmap term f)) (Œ¥ term G t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> <span class="mi">2</span>(fun_fmap_fmap G).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk6e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t1) =
Œ¥ term G (fmap term (fmap G f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t2) =
Œ¥ term G (fmap term (fmap G f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (fmap term f) (Œ¥ term G ([t1][t2])) =
Œ¥ term G (fmap term (fmap G f) ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk6f"><span class="nb">rewrite</span> (dist_term_ap_2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t1) =
Œ¥ term G (fmap term (fmap G f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t2) =
Œ¥ term G (fmap term (fmap G f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (fmap term f)
  (fmap G (Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt; Œ¥ term G t2) =
Œ¥ term G (fmap term (fmap G f) ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk70"><span class="nb">rewrite</span> (fmap_term_ap).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t1) =
Œ¥ term G (fmap term (fmap G f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t2) =
Œ¥ term G (fmap term (fmap G f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (fmap term f)
  (fmap G (Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt; Œ¥ term G t2) =
Œ¥ term G
  ([fmap term (fmap G f) t1][fmap term (fmap G f) t2])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk71"><span class="nb">rewrite</span> (dist_term_ap_2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t1) =
Œ¥ term G (fmap term (fmap G f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t2) =
Œ¥ term G (fmap term (fmap G f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (fmap term f)
  (fmap G (Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt; Œ¥ term G t2) =
fmap G (Ap (A:=B))
  (Œ¥ term G (fmap term (fmap G f) t1)) &lt;‚ãÜ&gt;
Œ¥ term G (fmap term (fmap G f) t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk72"><span class="nb">rewrite</span> &lt;- IHt1, &lt;- IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t1) =
Œ¥ term G (fmap term (fmap G f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t2) =
Œ¥ term G (fmap term (fmap G f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (fmap term f)
  (fmap G (Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt; Œ¥ term G t2) =
fmap G (Ap (A:=B))
  (fmap G (fmap term f) (Œ¥ term G t1)) &lt;‚ãÜ&gt;
fmap G (fmap term f) (Œ¥ term G t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk73"><span class="nb">rewrite</span> &lt;- ap_fmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t1) =
Œ¥ term G (fmap term (fmap G f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t2) =
Œ¥ term G (fmap term (fmap G f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (fmap term f)
  (fmap G (Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt; Œ¥ term G t2) =
fmap G (precompose (fmap term f))
  (fmap G (Ap (A:=B))
     (fmap G (fmap term f) (Œ¥ term G t1))) &lt;‚ãÜ&gt;
Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk74"><span class="nb">rewrite</span> fmap_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t1) =
Œ¥ term G (fmap term (fmap G f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t2) =
Œ¥ term G (fmap term (fmap G f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (compose (fmap term f))
  (fmap G (Ap (A:=A)) (Œ¥ term G t1)) &lt;‚ãÜ&gt; 
Œ¥ term G t2 =
fmap G (precompose (fmap term f))
  (fmap G (Ap (A:=B))
     (fmap G (fmap term f) (Œ¥ term G t1))) &lt;‚ãÜ&gt;
Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk75">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t1) =
Œ¥ term G (fmap term (fmap G f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t2) =
Œ¥ term G (fmap term (fmap G f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (compose (fmap term f))
  (fmap G (Ap (A:=A)) (Œ¥ term G t1)) =
fmap G (precompose (fmap term f))
  (fmap G (Ap (A:=B))
     (fmap G (fmap term f) (Œ¥ term G t1)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk76">compose near (dist term G t1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t1) =
Œ¥ term G (fmap term (fmap G f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t2) =
Œ¥ term G (fmap term (fmap G f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap G (compose (fmap term f)) ‚àò fmap G (Ap (A:=A)))
  (Œ¥ term G t1) =
fmap G (precompose (fmap term f))
  ((fmap G (Ap (A:=B)) ‚àò fmap G (fmap term f))
     (Œ¥ term G t1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk77"><span class="nb">rewrite</span> (fun_fmap_fmap G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t1) =
Œ¥ term G (fmap term (fmap G f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t2) =
Œ¥ term G (fmap term (fmap G f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (compose (fmap term f) ‚àò Ap (A:=A))
  (Œ¥ term G t1) =
fmap G (precompose (fmap term f))
  ((fmap G (Ap (A:=B)) ‚àò fmap G (fmap term f))
     (Œ¥ term G t1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk78"><span class="nb">rewrite</span> (fun_fmap_fmap G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t1) =
Œ¥ term G (fmap term (fmap G f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t2) =
Œ¥ term G (fmap term (fmap G f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (compose (fmap term f) ‚àò Ap (A:=A))
  (Œ¥ term G t1) =
fmap G (precompose (fmap term f))
  (fmap G (Ap (A:=B) ‚àò fmap term f) (Œ¥ term G t1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk79">compose near (dist term G t1) on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t1) =
Œ¥ term G (fmap term (fmap G f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t2) =
Œ¥ term G (fmap term (fmap G f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (compose (fmap term f) ‚àò Ap (A:=A))
  (Œ¥ term G t1) =
(fmap G (precompose (fmap term f))
 ‚àò fmap G (Ap (A:=B) ‚àò fmap term f)) 
  (Œ¥ term G t1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk7a"><span class="nb">rewrite</span> (fun_fmap_fmap G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t1) =
Œ¥ term G (fmap term (fmap G f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>fmap G (fmap term f) (Œ¥ term G t2) =
Œ¥ term G (fmap term (fmap G f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (compose (fmap term f) ‚àò Ap (A:=A))
  (Œ¥ term G t1) =
fmap G
  (precompose (fmap term f)
   ‚àò (Ap (A:=B) ‚àò fmap term f)) 
  (Œ¥ term G t1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk7b">#[export] <span class="kn">Instance</span> <span class="nf">dist_Natural_term</span> :
      Natural (@dist term _ _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@dist term Dist_instance_0 G H H0 H1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk7c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@dist term Dist_instance_0 G H H0 H1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk7d"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@dist term Dist_instance_0 G H H0 H1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk7e"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor (term ‚óã G)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk7f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk7f"><hr></label><div class="goal-conclusion">Functor (G ‚óã term)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk80" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk80"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
fmap (G ‚óã term) f ‚àò Œ¥ term G =
Œ¥ term G ‚àò fmap (term ‚óã G) f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk81">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor (term ‚óã G)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk82">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor (G ‚óã term)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk83">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
fmap (G ‚óã term) f ‚àò Œ¥ term G =
Œ¥ term G ‚àò fmap (term ‚óã G) f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk84"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (G ‚óã term) f ‚àò Œ¥ term G =
Œ¥ term G ‚àò fmap (term ‚óã G) f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> dist_natural_term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="traversal-laws">
<h3>Traversal laws</h3>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk85"><span class="kn">Lemma</span> <span class="nf">dist_unit_term</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>),
      dist term (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) = @id (term A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, Œ¥ term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk86"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, Œ¥ term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk87"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk88">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t = id t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk89"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (Var a) = id (Var a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk8a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t = id t</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk8a"><hr></label><div class="goal-conclusion">Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) = id (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk8b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t1 = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t2 = id t2</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk8b"><hr></label><div class="goal-conclusion">Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) ([t1][t2]) = id ([t1][t2])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk8c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (Var a) = id (Var a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk8d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t = id t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) = id (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk8e"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t = id t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (Lam X)
  (Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t) = id (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk8f"><span class="nb">rewrite</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t = id t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (Lam X) (id t) = id (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk90">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t1 = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t2 = id t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) ([t1][t2]) = id ([t1][t2])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk91"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t1 = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t2 = id t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (Ap (A:=A))
  (Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t1)
  (Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t2) = id ([t1][t2])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk92"><span class="nb">rewrite</span> IHt1, IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t1 = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t2 = id t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (Ap (A:=A)) (id t1) (id t2) =
id ([t1][t2])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Set Keyed Unification</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk93"><span class="kn">Lemma</span> <span class="nf">dist_linear_term</span> : <span class="kr">forall</span> `{Applicative G1} `{Applicative G2} (A : <span class="kt">Type</span>),
      dist term (G1 ‚àò G2) =
      fmap G1 (dist term G2) ‚àò dist term G1 (A := G2 A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H3</span> : Fmap G1)
  (<span class="nv">H4</span> : Pure G1) (<span class="nv">H5</span> : Mult G1),
Applicative G1 -&gt;
<span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H7</span> : Fmap G2)
  (<span class="nv">H8</span> : Pure G2) (<span class="nv">H9</span> : Mult G2),
Applicative G2 -&gt;
<span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
Œ¥ term (G1 ‚àò G2) = fmap G1 (Œ¥ term G2) ‚àò Œ¥ term G1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk94"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H3</span> : Fmap G1)
  (<span class="nv">H4</span> : Pure G1) (<span class="nv">H5</span> : Mult G1),
Applicative G1 -&gt;
<span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H7</span> : Fmap G2)
  (<span class="nv">H8</span> : Pure G2) (<span class="nv">H9</span> : Mult G2),
Applicative G2 -&gt;
<span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
Œ¥ term (G1 ‚àò G2) = fmap G1 (Œ¥ term G2) ‚àò Œ¥ term G1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk95"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (G1 ‚àò G2) = fmap G1 (Œ¥ term G2) ‚àò Œ¥ term G1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk96"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (G1 ‚óã G2) = fmap G1 (Œ¥ term G2) ‚óã Œ¥ term G1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk97">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (G1 ‚óã G2) t = fmap G1 (Œ¥ term G2) (Œ¥ term G1 t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk98"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G1 (G2 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (G1 ‚óã G2) (Var a) =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 (Var a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk99" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t = fmap G1 (Œ¥ term G2) (Œ¥ term G1 t)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk99"><hr></label><div class="goal-conclusion">Œ¥ term (G1 ‚óã G2) (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk9a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk9a"><hr></label><div class="goal-conclusion">Œ¥ term (G1 ‚óã G2) ([t1][t2]) =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 ([t1][t2]))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk9b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G1 (G2 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (G1 ‚óã G2) (Var a) =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 (Var a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk9c"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G1 (G2 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (G1 ‚óã G2) (Var (A:=A)) a =
fmap G1 (Œ¥ term G2) (fmap G1 (Var (A:=G2 A)) a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk9d">compose near a on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G1 (G2 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (G1 ‚óã G2) (Var (A:=A)) a =
(fmap G1 (Œ¥ term G2) ‚àò fmap G1 (Var (A:=G2 A))) a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> (fun_fmap_fmap G1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk9e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t = fmap G1 (Œ¥ term G2) (Œ¥ term G1 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (G1 ‚óã G2) (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk9f"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t = fmap G1 (Œ¥ term G2) (Œ¥ term G1 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (G1 ‚óã G2) (Lam X) (Œ¥ term (G1 ‚óã G2) t) =
fmap G1 (Œ¥ term G2) (fmap G1 (Lam X) (Œ¥ term G1 t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chka0"><span class="nb">rewrite</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t = fmap G1 (Œ¥ term G2) (Œ¥ term G1 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (G1 ‚óã G2) (Lam X)
  (fmap G1 (Œ¥ term G2) (Œ¥ term G1 t)) =
fmap G1 (Œ¥ term G2) (fmap G1 (Lam X) (Œ¥ term G1 t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chka1">compose near (dist term G1 t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t = fmap G1 (Œ¥ term G2) (Œ¥ term G1 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap (G1 ‚óã G2) (Lam X) ‚àò fmap G1 (Œ¥ term G2))
  (Œ¥ term G1 t) =
(fmap G1 (Œ¥ term G2) ‚àò fmap G1 (Lam X)) (Œ¥ term G1 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chka2"><span class="nb">change</span> (fmap (G1 ‚óã G2) (Lam X)) <span class="kr">with</span> (fmap G1 (fmap G2 (@Lam A X))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t = fmap G1 (Œ¥ term G2) (Œ¥ term G1 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap G1 (fmap G2 (Lam X)) ‚àò fmap G1 (Œ¥ term G2))
  (Œ¥ term G1 t) =
(fmap G1 (Œ¥ term G2) ‚àò fmap G1 (Lam X)) (Œ¥ term G1 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chka3"><span class="nb">rewrite</span> (fun_fmap_fmap G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t = fmap G1 (Œ¥ term G2) (Œ¥ term G1 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G1 (fmap G2 (Lam X) ‚àò Œ¥ term G2) (Œ¥ term G1 t) =
(fmap G1 (Œ¥ term G2) ‚àò fmap G1 (Lam X)) (Œ¥ term G1 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> (fun_fmap_fmap G1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chka4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (G1 ‚óã G2) ([t1][t2]) =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chka5"><span class="nb">rewrite</span> dist_term_ap_2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (G1 ‚óã G2) ([t1][t2]) =
fmap G1 (Œ¥ term G2)
  (fmap G1 (Ap (A:=G2 A)) (Œ¥ term G1 t1) &lt;‚ãÜ&gt;
   Œ¥ term G1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chka6"><span class="nb">rewrite</span> (dist_term_ap_2 (G := G1 ‚óã G2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (G1 ‚óã G2) (Ap (A:=A)) (Œ¥ term (G1 ‚óã G2) t1) &lt;‚ãÜ&gt;
Œ¥ term (G1 ‚óã G2) t2 =
fmap G1 (Œ¥ term G2)
  (fmap G1 (Ap (A:=G2 A)) (Œ¥ term G1 t1) &lt;‚ãÜ&gt;
   Œ¥ term G1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chka7"><span class="nb">rewrite</span> fmap_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (G1 ‚óã G2) (Ap (A:=A)) (Œ¥ term (G1 ‚óã G2) t1) &lt;‚ãÜ&gt;
Œ¥ term (G1 ‚óã G2) t2 =
fmap G1 (compose (Œ¥ term G2))
  (fmap G1 (Ap (A:=G2 A)) (Œ¥ term G1 t1)) &lt;‚ãÜ&gt;
Œ¥ term G1 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chka8">compose near ((dist term G1 t1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (G1 ‚óã G2) (Ap (A:=A)) (Œ¥ term (G1 ‚óã G2) t1) &lt;‚ãÜ&gt;
Œ¥ term (G1 ‚óã G2) t2 =
(fmap G1 (compose (Œ¥ term G2))
 ‚àò fmap G1 (Ap (A:=G2 A))) (Œ¥ term G1 t1) &lt;‚ãÜ&gt;
Œ¥ term G1 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chka9"><span class="nb">rewrite</span> (fun_fmap_fmap G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (G1 ‚óã G2) (Ap (A:=A)) (Œ¥ term (G1 ‚óã G2) t1) &lt;‚ãÜ&gt;
Œ¥ term (G1 ‚óã G2) t2 =
fmap G1 (compose (Œ¥ term G2) ‚àò Ap (A:=G2 A))
  (Œ¥ term G1 t1) &lt;‚ãÜ&gt; Œ¥ term G1 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkaa"><span class="nb">rewrite</span> (ap_compose2 G2 G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G1 (ap G2)
  (fmap (G1 ‚óã G2) (Ap (A:=A)) (Œ¥ term (G1 ‚óã G2) t1)) &lt;‚ãÜ&gt;
Œ¥ term (G1 ‚óã G2) t2 =
fmap G1 (compose (Œ¥ term G2) ‚àò Ap (A:=G2 A))
  (Œ¥ term G1 t1) &lt;‚ãÜ&gt; Œ¥ term G1 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkab"><span class="nb">rewrite</span> IHt1, IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G1 (ap G2)
  (fmap (G1 ‚óã G2) (Ap (A:=A))
     (fmap G1 (Œ¥ term G2) (Œ¥ term G1 t1))) &lt;‚ãÜ&gt;
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t2) =
fmap G1 (compose (Œ¥ term G2) ‚àò Ap (A:=G2 A))
  (Œ¥ term G1 t1) &lt;‚ãÜ&gt; Œ¥ term G1 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkac"><span class="nb">rewrite</span> &lt;- ap_fmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G1 (precompose (Œ¥ term G2))
  (fmap G1 (ap G2)
     (fmap (G1 ‚óã G2) (Ap (A:=A))
        (fmap G1 (Œ¥ term G2) (Œ¥ term G1 t1)))) &lt;‚ãÜ&gt;
Œ¥ term G1 t2 =
fmap G1 (compose (Œ¥ term G2) ‚àò Ap (A:=G2 A))
  (Œ¥ term G1 t1) &lt;‚ãÜ&gt; Œ¥ term G1 t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkad">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G1 (precompose (Œ¥ term G2))
  (fmap G1 (ap G2)
     (fmap (G1 ‚óã G2) (Ap (A:=A))
        (fmap G1 (Œ¥ term G2) (Œ¥ term G1 t1)))) =
fmap G1 (compose (Œ¥ term G2) ‚àò Ap (A:=G2 A))
  (Œ¥ term G1 t1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkae"><span class="kp">repeat</span> (compose near (dist term G1 t1) on <span class="nb">left</span>;
              <span class="nb">rewrite</span> (fun_fmap_fmap G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G1
  (precompose (Œ¥ term G2)
   ‚àò (ap G2 ‚àò (fmap G2 (Ap (A:=A)) ‚àò Œ¥ term G2)))
  (Œ¥ term G1 t1) =
fmap G1 (compose (Œ¥ term G2) ‚àò Ap (A:=G2 A))
  (Œ¥ term G1 t1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkaf">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">precompose (Œ¥ term G2)
‚àò (ap G2 ‚àò (fmap G2 (Ap (A:=A)) ‚àò Œ¥ term G2)) =
compose (Œ¥ term G2) ‚àò Ap (A:=G2 A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkb0">ext s1 s2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>term (G2 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(precompose (Œ¥ term G2)
 ‚àò (ap G2 ‚àò (fmap G2 (Ap (A:=A)) ‚àò Œ¥ term G2))) s1 s2 =
(compose (Œ¥ term G2) ‚àò Ap (A:=G2 A)) s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkb1"><span class="nb">unfold</span> compose; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>term (G2 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">precompose (Œ¥ term G2)
  (ap G2 (fmap G2 (Ap (A:=A)) (Œ¥ term G2 s1))) s2 =
pure G2 (Ap (A:=A)) &lt;‚ãÜ&gt; Œ¥ term G2 s1 &lt;‚ãÜ&gt; Œ¥ term G2 s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkb2"><span class="nb">unfold</span> precompose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
fmap G1 (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>term (G2 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G2 (Ap (A:=A)) (Œ¥ term G2 s1) &lt;‚ãÜ&gt; Œ¥ term G2 s2 =
pure G2 (Ap (A:=A)) &lt;‚ãÜ&gt; Œ¥ term G2 s1 &lt;‚ãÜ&gt; Œ¥ term G2 s2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> (fmap_to_ap).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Unset Keyed Unification</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkb3"><span class="kn">Lemma</span> <span class="nf">dist_morph_term</span> : <span class="kr">forall</span> `{ApplicativeMorphism G1 G2 œï} A,
      dist term G2 ‚àò fmap term (œï A) = œï (term A) ‚àò dist term G1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H3</span> : Fmap G1)
  (<span class="nv">H4</span> : Pure G1) (<span class="nv">H5</span> : Mult G1) (<span class="nv">H6</span> : Fmap G2)
  (<span class="nv">H7</span> : Pure G2) (<span class="nv">H8</span> : Mult G2)
  (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 œï -&gt;
<span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
Œ¥ term G2 ‚àò fmap term (œï A) = œï (term A) ‚àò Œ¥ term G1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkb4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H3</span> : Fmap G1)
  (<span class="nv">H4</span> : Pure G1) (<span class="nv">H5</span> : Mult G1) (<span class="nv">H6</span> : Fmap G2)
  (<span class="nv">H7</span> : Pure G2) (<span class="nv">H8</span> : Mult G2)
  (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 œï -&gt;
<span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
Œ¥ term G2 ‚àò fmap term (œï A) = œï (term A) ‚àò Œ¥ term G1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkb5"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G2 ‚àò fmap term (œï A) = œï (term A) ‚àò Œ¥ term G1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkb6">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Œ¥ term G2 ‚àò fmap term (œï A)) t =
(œï (term A) ‚àò Œ¥ term G1) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkb7"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G2 (fmap term (œï A) t) =
œï (term A) (Œ¥ term G1 t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkb8"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G2 (fmap term (œï A) (Var a)) =
œï (term A) (Œ¥ term G1 (Var a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chkb9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t) = œï (term A) (Œ¥ term G1 t)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chkb9"><hr></label><div class="goal-conclusion">Œ¥ term G2 (fmap term (œï A) (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
œï (term A) (Œ¥ term G1 (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chkba" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t1) =
œï (term A) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t2) =
œï (term A) (Œ¥ term G1 t2)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chkba"><hr></label><div class="goal-conclusion">Œ¥ term G2 (fmap term (œï A) ([t1][t2])) =
œï (term A) (Œ¥ term G1 ([t1][t2]))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkbb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G2 (fmap term (œï A) (Var a)) =
œï (term A) (Œ¥ term G1 (Var a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkbc"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G2 (Var (A:=A)) (œï A a) =
œï (term A) (fmap G1 (Var (A:=A)) a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> &lt;- (appmor_natural G1 G2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkbd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t) = œï (term A) (Œ¥ term G1 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G2 (fmap term (œï A) (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
œï (term A) (Œ¥ term G1 (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkbe"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t) = œï (term A) (Œ¥ term G1 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G2 (Lam X) (Œ¥ term G2 (fmap term (œï A) t)) =
œï (term A) (fmap G1 (Lam X) (Œ¥ term G1 t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkbf"><span class="nb">rewrite</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t) = œï (term A) (Œ¥ term G1 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G2 (Lam X) (œï (term A) (Œ¥ term G1 t)) =
œï (term A) (fmap G1 (Lam X) (Œ¥ term G1 t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> (appmor_natural G1 G2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkc0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t1) =
œï (term A) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t2) =
œï (term A) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G2 (fmap term (œï A) ([t1][t2])) =
œï (term A) (Œ¥ term G1 ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkc1"><span class="nb">rewrite</span> fmap_term_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t1) =
œï (term A) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t2) =
œï (term A) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G2 ([fmap term (œï A) t1][fmap term (œï A) t2]) =
œï (term A) (Œ¥ term G1 ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkc2"><span class="nb">inversion</span> H9.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t1) =
œï (term A) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t2) =
œï (term A) (Œ¥ term G1 t2)</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (fmap G1 f x) = fmap G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure G1 a) = pure G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G2 ([fmap term (œï A) t1][fmap term (œï A) t2]) =
œï (term A) (Œ¥ term G1 ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkc3"><span class="nb">rewrite</span> dist_term_ap_2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t1) =
œï (term A) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t2) =
œï (term A) (Œ¥ term G1 t2)</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (fmap G1 f x) = fmap G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure G1 a) = pure G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G2 (Ap (A:=A)) (Œ¥ term G2 (fmap term (œï A) t1)) &lt;‚ãÜ&gt;
Œ¥ term G2 (fmap term (œï A) t2) =
œï (term A) (Œ¥ term G1 ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkc4"><span class="nb">rewrite</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t1) =
œï (term A) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t2) =
œï (term A) (Œ¥ term G1 t2)</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (fmap G1 f x) = fmap G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure G1 a) = pure G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G2 (Ap (A:=A)) (œï (term A) (Œ¥ term G1 t1)) &lt;‚ãÜ&gt;
Œ¥ term G2 (fmap term (œï A) t2) =
œï (term A) (Œ¥ term G1 ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkc5"><span class="nb">rewrite</span> IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t1) =
œï (term A) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t2) =
œï (term A) (Œ¥ term G1 t2)</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (fmap G1 f x) = fmap G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure G1 a) = pure G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G2 (Ap (A:=A)) (œï (term A) (Œ¥ term G1 t1)) &lt;‚ãÜ&gt;
œï (term A) (Œ¥ term G1 t2) =
œï (term A) (Œ¥ term G1 ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkc6"><span class="nb">rewrite</span> dist_term_ap_2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t1) =
œï (term A) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t2) =
œï (term A) (Œ¥ term G1 t2)</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (fmap G1 f x) = fmap G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure G1 a) = pure G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G2 (Ap (A:=A)) (œï (term A) (Œ¥ term G1 t1)) &lt;‚ãÜ&gt;
œï (term A) (Œ¥ term G1 t2) =
œï (term A)
  (fmap G1 (Ap (A:=A)) (Œ¥ term G1 t1) &lt;‚ãÜ&gt; Œ¥ term G1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkc7"><span class="nb">rewrite</span> (ap_morphism_1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t1) =
œï (term A) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t2) =
œï (term A) (Œ¥ term G1 t2)</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (fmap G1 f x) = fmap G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure G1 a) = pure G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G2 (Ap (A:=A)) (œï (term A) (Œ¥ term G1 t1)) &lt;‚ãÜ&gt;
œï (term A) (Œ¥ term G1 t2) =
œï (term A -&gt; term A)
  (fmap G1 (Ap (A:=A)) (Œ¥ term G1 t1)) &lt;‚ãÜ&gt;
œï (term A) (Œ¥ term G1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkc8">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Fmap G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Fmap G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t1) =
œï (term A) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (fmap term (œï A) t2) =
œï (term A) (Œ¥ term G1 t2)</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (fmap G1 f x) = fmap G2 f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure G1 a) = pure G2 a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G2 (Ap (A:=A)) (œï (term A) (Œ¥ term G1 t1)) =
œï (term A -&gt; term A)
  (fmap G1 (Ap (A:=A)) (Œ¥ term G1 t1))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> &lt;- (appmor_natural).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">dist_term_properties</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">TraversableFunctor_term</span> : TraversableFunctor term :=
  {| dist_natural := @dist_Natural_term;
     dist_morph := @dist_morph_term;
     dist_linear := @dist_linear_term;
     dist_unit := @dist_unit_term;
  |}.</span></span></pre></div>
</div>
<div class="section" id="decorated-traversable-functor-instance">
<h2><a class="toc-backref" href="#toc-entry-7">Decorated-Traversable Functor instance</a></h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkc9"><span class="kn">Lemma</span> <span class="nf">dtfun_compat_term1</span> : <span class="kr">forall</span> `{Applicative G} (X : typ) {A},
    fmap G (dec term ‚àò Lam X) ‚àò Œ¥ term G (A := A) =
    fmap G (curry (shift term) <span class="mi">1</span> ‚àò Lam X) ‚àò fmap G (dec term) ‚àò Œ¥ term G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap G) (<span class="nv">H0</span> : Pure G)
  (<span class="nv">H1</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">A</span> : <span class="kt">Type</span>),
fmap G (dec term ‚àò Lam X) ‚àò Œ¥ term G =
fmap G (curry (shift term) <span class="mi">1</span> ‚àò Lam X)
‚àò fmap G (dec term) ‚àò Œ¥ term G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkca"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap G) (<span class="nv">H0</span> : Pure G)
  (<span class="nv">H1</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">A</span> : <span class="kt">Type</span>),
fmap G (dec term ‚àò Lam X) ‚àò Œ¥ term G =
fmap G (curry (shift term) <span class="mi">1</span> ‚àò Lam X)
‚àò fmap G (dec term) ‚àò Œ¥ term G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkcb"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (dec term ‚àò Lam X) ‚àò Œ¥ term G =
fmap G (curry (shift term) <span class="mi">1</span> ‚àò Lam X)
‚àò fmap G (dec term) ‚àò Œ¥ term G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkcc"><span class="nb">rewrite</span> (fun_fmap_fmap G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (dec term ‚àò Lam X) ‚àò Œ¥ term G =
fmap G (curry (shift term) <span class="mi">1</span> ‚àò Lam X ‚àò dec term)
‚àò Œ¥ term G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkcd"><span class="kn">Theorem</span> <span class="nf">dtfun_compat_term</span> :
        `(<span class="kr">forall</span> `{Applicative G} {A : <span class="kt">Type</span>},
             dist term G ‚àò fmap term (strength G) ‚àò dec term (A := G A) =
             fmap G (dec term) ‚àò dist term G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap G) (<span class="nv">H0</span> : Pure G)
  (<span class="nv">H1</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
Œ¥ term G ‚àò fmap term (œÉ G) ‚àò dec term =
fmap G (dec term) ‚àò Œ¥ term G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkce"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Fmap G) (<span class="nv">H0</span> : Pure G)
  (<span class="nv">H1</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
Œ¥ term G ‚àò fmap term (œÉ G) ‚àò dec term =
fmap G (dec term) ‚àò Œ¥ term G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkcf"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G ‚àò fmap term (œÉ G) ‚àò dec term =
fmap G (dec term) ‚àò Œ¥ term G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkd0">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Œ¥ term G ‚àò fmap term (œÉ G) ‚àò dec term) t =
(fmap G (dec term) ‚àò Œ¥ term G) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkd1"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (fmap term (œÉ G) (dec term t)) =
fmap G (dec term) (Œ¥ term G t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkd2"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (fmap term (œÉ G) (dec term (Var a))) =
fmap G (dec term) (Œ¥ term G (Var a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chkd3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t)) = fmap G (dec term) (Œ¥ term G t)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chkd3"><hr></label><div class="goal-conclusion">Œ¥ term G (fmap term (œÉ G) (dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))) =
fmap G (dec term) (Œ¥ term G (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chkd4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t1)) =
fmap G (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t2)) =
fmap G (dec term) (Œ¥ term G t2)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chkd4"><hr></label><div class="goal-conclusion">Œ¥ term G (fmap term (œÉ G) (dec term ([t1][t2]))) =
fmap G (dec term) (Œ¥ term G ([t1][t2]))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkd5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (fmap term (œÉ G) (dec term (Var a))) =
fmap G (dec term) (Œ¥ term G (Var a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkd6"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Var (A:=nat * A)) (fmap G (pair ∆µ) a) =
fmap G (dec term) (fmap G (Var (A:=A)) a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkd7">compose near a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap G (Var (A:=nat * A)) ‚àò fmap G (pair ∆µ)) a =
(fmap G (dec term) ‚àò fmap G (Var (A:=A))) a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> <span class="mi">2</span>(fun_fmap_fmap G).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkd8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t)) =
fmap G (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (fmap term (œÉ G) (dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))) =
fmap G (dec term) (Œ¥ term G (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkd9"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t)) =
fmap G (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Lam X)
  (Œ¥ term G
     (fmap term (œÉ G)
        (fmap term (join (prod nat))
           (fmap term (pair <span class="mi">1</span>) (dec term t))))) =
fmap G (dec term) (fmap G (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkda"><span class="kp">do</span> <span class="mi">2</span> (compose near (dec term t) on <span class="nb">left</span>;
               <span class="nb">rewrite</span> (fun_fmap_fmap term)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t)) =
fmap G (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Lam X)
  (Œ¥ term G
     (fmap term (œÉ G ‚àò (join (prod nat) ‚àò pair <span class="mi">1</span>))
        (dec term t))) =
fmap G (dec term) (fmap G (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkdb">reassociate &lt;-.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t)) =
fmap G (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Lam X)
  (Œ¥ term G
     (fmap term (œÉ G ‚àò join (prod nat) ‚àò pair <span class="mi">1</span>)
        (dec term t))) =
fmap G (dec term) (fmap G (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkdc"><span class="nb">rewrite</span> (strength_shift1 nat G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t)) =
fmap G (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Lam X)
  (Œ¥ term G
     (fmap term
        (fmap G (join (prod nat) ‚àò pair <span class="mi">1</span>) ‚àò œÉ G)
        (dec term t))) =
fmap G (dec term) (fmap G (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkdd"><span class="nb">rewrite</span> &lt;- (fun_fmap_fmap term); <span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t)) =
fmap G (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Lam X)
  (Œ¥ term G
     (fmap term (fmap G (join (prod nat) ‚óã pair <span class="mi">1</span>))
        (fmap term (œÉ G) (dec term t)))) =
fmap G (dec term) (fmap G (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkde"><span class="nb">change</span> (fmap term (fmap G <span class="nl">?f</span>)) <span class="kr">with</span> (fmap (term ‚àò G) f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t)) =
fmap G (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Lam X)
  (Œ¥ term G
     (fmap (term ‚àò G) (join (prod nat) ‚óã pair <span class="mi">1</span>)
        (fmap term (œÉ G) (dec term t)))) =
fmap G (dec term) (fmap G (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkdf">compose near ((fmap term (œÉ G) (dec term t))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t)) =
fmap G (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Lam X)
  ((Œ¥ term G
    ‚àò fmap (term ‚àò G) (join (prod nat) ‚óã pair <span class="mi">1</span>))
     (fmap term (œÉ G) (dec term t))) =
fmap G (dec term) (fmap G (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chke0">unfold_compose_in_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t)) =
fmap G (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Lam X)
  ((Œ¥ term G
    ‚àò fmap (term ‚àò G) (join (prod nat) ‚óã pair <span class="mi">1</span>))
     (fmap term (œÉ G) (dec term t))) =
fmap G (dec term) (fmap G (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chke1"><span class="nb">rewrite</span> &lt;- (natural (œï := @dist term _ G _ _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t)) =
fmap G (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Lam X)
  ((fmap (G ‚óã term) (join (prod nat) ‚óã pair <span class="mi">1</span>)
    ‚àò Œ¥ term G) (fmap term (œÉ G) (dec term t))) =
fmap G (dec term) (fmap G (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chke2"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t)) =
fmap G (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Lam X)
  (fmap (G ‚óã term) (join (prod nat) ‚óã pair <span class="mi">1</span>)
     (Œ¥ term G (fmap term (œÉ G) (dec term t)))) =
fmap G (dec term) (fmap G (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chke3"><span class="nb">rewrite</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t)) =
fmap G (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Lam X)
  (fmap (G ‚óã term) (join (prod nat) ‚óã pair <span class="mi">1</span>)
     (fmap G (dec term) (Œ¥ term G t))) =
fmap G (dec term) (fmap G (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chke4">compose near (Œ¥ term G t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t)) =
fmap G (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Lam X)
  ((fmap (G ‚óã term) (join (prod nat) ‚óã pair <span class="mi">1</span>)
    ‚àò fmap G (dec term)) 
     (Œ¥ term G t)) =
(fmap G (dec term) ‚àò fmap G (Lam X)) (Œ¥ term G t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chke5"><span class="nb">rewrite</span> (fun_fmap_fmap G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t)) =
fmap G (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Lam X)
  ((fmap (G ‚óã term) (join (prod nat) ‚óã pair <span class="mi">1</span>)
    ‚àò fmap G (dec term)) 
     (Œ¥ term G t)) =
fmap G (dec term ‚àò Lam X) (Œ¥ term G t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chke6">compose near (Œ¥ term G t) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t)) =
fmap G (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap G (Lam X)
 ‚àò (fmap (G ‚óã term) (join (prod nat) ‚óã pair <span class="mi">1</span>)
    ‚àò fmap G (dec term))) 
  (Œ¥ term G t) =
fmap G (dec term ‚àò Lam X) (Œ¥ term G t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chke7">unfold_ops @Fmap_compose; <span class="nb">rewrite</span> <span class="mi">2</span>(fun_fmap_fmap G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t)) =
fmap G (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G
  (Lam X
   ‚àò (fmap term (join (prod nat) ‚óã pair <span class="mi">1</span>) ‚àò dec term))
  (Œ¥ term G t) =
fmap G (dec term ‚àò Lam X) (Œ¥ term G t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chke8">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t)) =
fmap G (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Lam X
‚àò (fmap term (join (prod nat) ‚óã pair <span class="mi">1</span>) ‚àò dec term) =
dec term ‚àò Lam X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chke9">ext t&#39;; <span class="nb">unfold</span> compose; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t)) =
fmap G (dec term) (Œ¥ term G t)</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">Œª</span> <span class="nv">X</span>
‚ãÖ fmap term (join (prod nat) ‚óã pair <span class="mi">1</span>) (dec term t&#39;) =
<span class="kr">Œª</span> <span class="nv">X</span>
‚ãÖ fmap term (join (prod nat))
    (fmap term (pair <span class="mi">1</span>) (dec term t&#39;))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">compose near (dec term t&#39;) on <span class="nb">right</span>; <span class="bp">now</span> <span class="nb">rewrite</span> (fun_fmap_fmap term).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkea">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t1)) =
fmap G (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t2)) =
fmap G (dec term) (Œ¥ term G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (fmap term (œÉ G) (dec term ([t1][t2]))) =
fmap G (dec term) (Œ¥ term G ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkeb"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t1)) =
fmap G (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t2)) =
fmap G (dec term) (Œ¥ term G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure G (Ap (A:=nat * A)) &lt;‚ãÜ&gt;
Œ¥ term G (fmap term (œÉ G) (dec term t1)) &lt;‚ãÜ&gt;
Œ¥ term G (fmap term (œÉ G) (dec term t2)) =
fmap G (dec term)
  (pure G (Ap (A:=A)) &lt;‚ãÜ&gt; Œ¥ term G t1 &lt;‚ãÜ&gt; Œ¥ term G t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkec"><span class="nb">rewrite</span> IHt1, IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t1)) =
fmap G (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t2)) =
fmap G (dec term) (Œ¥ term G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure G (Ap (A:=nat * A)) &lt;‚ãÜ&gt;
fmap G (dec term) (Œ¥ term G t1) &lt;‚ãÜ&gt;
fmap G (dec term) (Œ¥ term G t2) =
fmap G (dec term)
  (pure G (Ap (A:=A)) &lt;‚ãÜ&gt; Œ¥ term G t1 &lt;‚ãÜ&gt; Œ¥ term G t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chked"><span class="nb">rewrite</span> fmap_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t1)) =
fmap G (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t2)) =
fmap G (dec term) (Œ¥ term G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure G (Ap (A:=nat * A)) &lt;‚ãÜ&gt;
fmap G (dec term) (Œ¥ term G t1) &lt;‚ãÜ&gt;
fmap G (dec term) (Œ¥ term G t2) =
fmap G (compose (dec term))
  (pure G (Ap (A:=A)) &lt;‚ãÜ&gt; Œ¥ term G t1) &lt;‚ãÜ&gt; 
Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkee"><span class="nb">rewrite</span> fmap_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t1)) =
fmap G (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t2)) =
fmap G (dec term) (Œ¥ term G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure G (Ap (A:=nat * A)) &lt;‚ãÜ&gt;
fmap G (dec term) (Œ¥ term G t1) &lt;‚ãÜ&gt;
fmap G (dec term) (Œ¥ term G t2) =
fmap G (compose (compose (dec term)))
  (pure G (Ap (A:=A))) &lt;‚ãÜ&gt; 
Œ¥ term G t1 &lt;‚ãÜ&gt; Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkef"><span class="nb">rewrite</span> pure_ap_fmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t1)) =
fmap G (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t2)) =
fmap G (dec term) (Œ¥ term G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Ap (A:=nat * A) ‚àò dec term) (Œ¥ term G t1) &lt;‚ãÜ&gt;
fmap G (dec term) (Œ¥ term G t2) =
fmap G (compose (compose (dec term)))
  (pure G (Ap (A:=A))) &lt;‚ãÜ&gt; 
Œ¥ term G t1 &lt;‚ãÜ&gt; Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkf0"><span class="nb">rewrite</span> &lt;- ap_fmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t1)) =
fmap G (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t2)) =
fmap G (dec term) (Œ¥ term G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (precompose (dec term))
  (fmap G (Ap (A:=nat * A) ‚àò dec term) (Œ¥ term G t1)) &lt;‚ãÜ&gt;
Œ¥ term G t2 =
fmap G (compose (compose (dec term)))
  (pure G (Ap (A:=A))) &lt;‚ãÜ&gt; 
Œ¥ term G t1 &lt;‚ãÜ&gt; Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkf1"><span class="nb">rewrite</span> (app_pure_natural G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t1)) =
fmap G (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t2)) =
fmap G (dec term) (Œ¥ term G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (precompose (dec term))
  (fmap G (Ap (A:=nat * A) ‚àò dec term) (Œ¥ term G t1)) &lt;‚ãÜ&gt;
Œ¥ term G t2 =
pure G (compose (dec term) ‚àò Ap (A:=A)) &lt;‚ãÜ&gt;
Œ¥ term G t1 &lt;‚ãÜ&gt; Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkf2"><span class="nb">rewrite</span> &lt;- (fmap_to_ap).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t1)) =
fmap G (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t2)) =
fmap G (dec term) (Œ¥ term G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (precompose (dec term))
  (fmap G (Ap (A:=nat * A) ‚àò dec term) (Œ¥ term G t1)) &lt;‚ãÜ&gt;
Œ¥ term G t2 =
fmap G (compose (dec term) ‚àò Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt;
Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkf3">compose near (Œ¥ term G t1) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t1)) =
fmap G (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t2)) =
fmap G (dec term) (Œ¥ term G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap G (precompose (dec term))
 ‚àò fmap G (Ap (A:=nat * A) ‚àò dec term)) 
  (Œ¥ term G t1) &lt;‚ãÜ&gt; Œ¥ term G t2 =
fmap G (compose (dec term) ‚àò Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt;
Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkf4"><span class="nb">rewrite</span> (fun_fmap_fmap G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t1)) =
fmap G (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (fmap term (œÉ G) (dec term t2)) =
fmap G (dec term) (Œ¥ term G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G
  (precompose (dec term)
   ‚àò (Ap (A:=nat * A) ‚àò dec term)) 
  (Œ¥ term G t1) &lt;‚ãÜ&gt; Œ¥ term G t2 =
fmap G (compose (dec term) ‚àò Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt;
Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> : DecoratedTraversableFunctor nat term :=
  {| dtfun_compat := @dtfun_compat_term |}.</span></span></pre></div>
</div>
<div class="section" id="monad-instances">
<h1><a class="toc-backref" href="#toc-entry-8">Monad instances</a></h1>
<div class="section" id="plain-monad-instance">
<h2><a class="toc-backref" href="#toc-entry-9">Plain Monad instance</a></h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">join_term</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">t</span> : term (term A)) : term A :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | Var t&#39; =&gt; t&#39;
  | Lam X t =&gt; Lam X (join_term t)
  | Ap t1 t2 =&gt; Ap (join_term t1) (join_term t2)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Ret_term</span> : Return term := @Var.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Join_term</span> : Join term := @join_term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkf5"><span class="kn">Theorem</span> <span class="nf">ret_natural</span> : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">f</span> : A -&gt; B),
    fmap term f ‚àò ret term = ret term ‚àò f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
fmap term f ‚àò ret term = ret term ‚àò f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkf6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
fmap term f ‚àò ret term = ret term ‚àò f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkf7"><span class="kn">Theorem</span> <span class="nf">join_natural</span> : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">f</span> : A -&gt; B),
    fmap term f ‚àò join term = join term ‚àò fmap term (fmap term f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
fmap term f ‚àò join term =
join term ‚àò fmap term (fmap term f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkf8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
fmap term f ‚àò join term =
join term ‚àò fmap term (fmap term f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkf9"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap term f ‚àò join term =
join term ‚àò fmap term (fmap term f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkfa">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>(term ‚àò term) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap term f ‚àò join term) t =
(join term ‚àò fmap term (fmap term f)) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkfb"><span class="nb">unfold</span> transparent tcs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>(term ‚àò term) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap_term f ‚àò join_term) t =
(join_term ‚àò fmap_term (fmap_term f)) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkfc"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>(term ‚àò term) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap_term f (join_term t) =
join_term (fmap_term (fmap_term f) t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">basic t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkfd">#[export] <span class="kn">Instance</span>: Natural (@ret term _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@ret term Ret_term)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkfe"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@ret term Ret_term)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkff"><span class="nb">constructor</span>; <span class="kp">try</span> <span class="nb">typeclasses eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
fmap term f ‚àò ret term =
ret term ‚àò fmap (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ret_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk100">#[export] <span class="kn">Instance</span>: Natural (@join term _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@join term Join_term)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk101"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@join term Join_term)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk102"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor (term ‚àò term)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor term</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
fmap term f ‚àò join term =
join term ‚àò fmap (term ‚àò term) f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk103">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor (term ‚àò term)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk104">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk105">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
fmap term f ‚àò join term =
join term ‚àò fmap (term ‚àò term) f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> join_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk106"><span class="kn">Theorem</span> <span class="nf">join_ret</span> : <span class="kr">forall</span> <span class="nv">A</span>,
    join term ‚àò ret term = @id (term A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, join term ‚àò ret term = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk107"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, join term ‚àò ret term = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk108"><span class="kn">Theorem</span> <span class="nf">join_fmap_ret</span> : <span class="kr">forall</span> <span class="nv">A</span>,
    join term ‚àò fmap term (ret term) = @id (term A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, join term ‚àò fmap term (ret term) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk109"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, join term ‚àò fmap term (ret term) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk10a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join term ‚àò fmap term (ret term) = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk10b"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join term ‚óã fmap term (ret term) = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk10c"><span class="nb">unfold</span> transparent tcs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term ‚óã fmap_term (Var (A:=A)) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk10d">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term (fmap_term (Var (A:=A)) t) = id t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">basic t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk10e"><span class="kn">Theorem</span> <span class="nf">join_join</span> : <span class="kr">forall</span> <span class="nv">A</span>,
    join term ‚àò join term = join term (A := A) ‚àò fmap term (join term).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
join term ‚àò join term =
join term ‚àò fmap term (join term)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk10f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
join term ‚àò join term =
join term ‚àò fmap term (join term)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk110"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join term ‚àò join term =
join term ‚àò fmap term (join term)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk111"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join term ‚óã join term =
join term ‚óã fmap term (join term)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk112"><span class="nb">unfold</span> transparent tcs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term ‚óã join_term =
join_term ‚óã fmap_term join_term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk113">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term (term A))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term (join_term t) =
join_term (fmap_term join_term t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">basic t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Monad_term</span> : Monad term :=
  {| mon_join_ret := join_ret;
     mon_join_fmap_ret := join_fmap_ret;
     mon_join_join := join_join |}.</span></span></pre></div>
<div class="section" id="decorated-monad-instance">
<h2><a class="toc-backref" href="#toc-entry-10">Decorated Monad instance</a></h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk114"><span class="kn">Theorem</span> <span class="nf">dec_ret</span> : <span class="kr">forall</span> <span class="nv">A</span>,
    dec term ‚àò ret term (A := A) = ret term ‚àò pair ∆µ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dec term ‚àò ret term = ret term ‚àò pair ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk115"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dec term ‚àò ret term = ret term ‚àò pair ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk116"><span class="kn">Theorem</span> <span class="nf">dec_join</span> : <span class="kr">forall</span> <span class="nv">A</span>,
    dec term ‚àò join term (A := A) =
    join term ‚àò fmap term (shift term) ‚àò dec term ‚àò fmap term (dec term).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dec term ‚àò join term =
join term ‚àò fmap term (shift term) ‚àò dec term
‚àò fmap term (dec term)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk117"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dec term ‚àò join term =
join term ‚àò fmap term (shift term) ‚àò dec term
‚àò fmap term (dec term)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk118"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term ‚àò join term =
join term ‚àò fmap term (shift term) ‚àò dec term
‚àò fmap term (dec term)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk119"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term ‚óã join term =
(<span class="kr">fun</span> <span class="nv">a</span> : term (term A) =&gt;
 join term
   (fmap term (shift term)
      (dec term (fmap term (dec term) a))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk11a">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term (join term t) =
join term
  (fmap term (shift term)
     (dec term (fmap term (dec term) t)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk11b"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term (join term (Var a)) =
join term
  (fmap term (shift term)
     (dec term (fmap term (dec term) (Var a))))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk11c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dec term (join term t) =
join term (fmap term (shift term) (dec term (fmap term (dec term) t)))</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk11c"><hr></label><div class="goal-conclusion">dec term (join term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
join term
  (fmap term (shift term)
     (dec term (fmap term (dec term) (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))))</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk11d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dec term (join term t1) =
join term
  (fmap term (shift term)
     (dec term (fmap term (dec term) t1)))</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dec term (join term t2) =
join term
  (fmap term (shift term)
     (dec term (fmap term (dec term) t2)))</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk11d"><hr></label><div class="goal-conclusion">dec term (join term ([t1][t2])) =
join term
  (fmap term (shift term)
     (dec term (fmap term (dec term) ([t1][t2]))))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk11e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term (join term (Var a)) =
join term
  (fmap term (shift term)
     (dec term (fmap term (dec term) (Var a))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk11f"><span class="nb">cbn</span> -[shift].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term a = shift term (∆µ, dec term a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> (shift_zero term).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk120">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dec term (join term t) =
join term
  (fmap term (shift term)
     (dec term (fmap term (dec term) t)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term (join term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
join term
  (fmap term (shift term)
     (dec term (fmap term (dec term) (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk121"><span class="nb">cbn</span> -[shift].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dec term (join term t) =
join term
  (fmap term (shift term)
     (dec term (fmap term (dec term) t)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ shift term (<span class="mi">1</span>, dec term (join term t)) =
<span class="kr">Œª</span> <span class="nv">X</span>
‚ãÖ join term
    (fmap term (shift term)
       (shift term
          (<span class="mi">1</span>, dec term (fmap term (dec term) t))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk122">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dec term (join term t) =
join term
  (fmap term (shift term)
     (dec term (fmap term (dec term) t)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shift term (<span class="mi">1</span>, dec term (join term t)) =
join term
  (fmap term (shift term)
     (shift term
        (<span class="mi">1</span>, dec term (fmap term (dec term) t))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> (dec_helper_4).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk123">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dec term (join term t1) =
join term
  (fmap term (shift term)
     (dec term (fmap term (dec term) t1)))</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dec term (join term t2) =
join term
  (fmap term (shift term)
     (dec term (fmap term (dec term) t2)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term (join term ([t1][t2])) =
join term
  (fmap term (shift term)
     (dec term (fmap term (dec term) ([t1][t2]))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk124"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dec term (join term t1) =
join term
  (fmap term (shift term)
     (dec term (fmap term (dec term) t1)))</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dec term (join term t2) =
join term
  (fmap term (shift term)
     (dec term (fmap term (dec term) t2)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[dec term (join term t1)][dec term (join term t2)] =
[join term
   (fmap term (shift term)
      (dec term (fmap term (dec term) t1)))]
[join term
   (fmap term (shift term)
      (dec term (fmap term (dec term) t2)))]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">fequal; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk125">#[export] <span class="kn">Instance</span> <span class="nf">DecoratedMonad_term</span> : DecoratedMonad nat term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedMonad nat term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk126"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedMonad nat term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk127"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedFunctor nat term</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Monad term</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Monoid nat</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dec term ‚àò ret term = ret term ‚àò pair ∆µ</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dec term ‚àò join term =
join term ‚àò fmap term (shift term) ‚àò dec term
‚àò fmap term (dec term)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk128">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedFunctor nat term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk129">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Monad term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk12a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Monoid nat</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk12b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dec term ‚àò ret term = ret term ‚àò pair ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> dec_ret.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk12c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dec term ‚àò join term =
join term ‚àò fmap term (shift term) ‚àò dec term
‚àò fmap term (dec term)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> dec_join.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="traversable-monad-instance">
<h2><a class="toc-backref" href="#toc-entry-11">Traversable Monad instance</a></h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk12d"><span class="kn">Theorem</span> <span class="nf">trvmon_ret_term</span> `{Applicative G} :
  `(dist term G ‚àò ret term (A := G A) = fmap G (ret term)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
Œ¥ term G ‚àò ret term = fmap G (ret term)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk12e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
Œ¥ term G ‚àò ret term = fmap G (ret term)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk12f"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G ‚àò ret term = fmap G (ret term)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk130">ext x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Œ¥ term G ‚àò ret term) x = fmap G (ret term) x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Set Keyed Unification</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk131"><span class="kn">Theorem</span> <span class="nf">trvmon_join_term</span> `{Applicative G} :
  `(dist term G ‚àò join term = fmap G (join term) ‚àò dist (term ‚àò term) G (A := A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
Œ¥ term G ‚àò join term =
fmap G (join term) ‚àò Œ¥ (term ‚àò term) G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk132"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
Œ¥ term G ‚àò join term =
fmap G (join term) ‚àò Œ¥ (term ‚àò term) G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk133"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G ‚àò join term =
fmap G (join term) ‚àò Œ¥ (term ‚àò term) G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk134">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>(term ‚àò term) (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Œ¥ term G ‚àò join term) t =
(fmap G (join term) ‚àò Œ¥ (term ‚àò term) G) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk135"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>(term ‚àò term) (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (join term t) =
fmap G (join term) (Œ¥ (term ‚óã term) G t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk136"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (join term (Var a)) =
fmap G (join term) (Œ¥ (term ‚óã term) G (Var a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk137" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t) = fmap G (join term) (Œ¥ (term ‚óã term) G t)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk137"><hr></label><div class="goal-conclusion">Œ¥ term G (join term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
fmap G (join term) (Œ¥ (term ‚óã term) G (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk138" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t1) =
fmap G (join term) (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t2) =
fmap G (join term) (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk138"><hr></label><div class="goal-conclusion">Œ¥ term G (join term ([t1][t2])) =
fmap G (join term) (Œ¥ (term ‚óã term) G ([t1][t2]))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk139">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (join term (Var a)) =
fmap G (join term) (Œ¥ (term ‚óã term) G (Var a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk13a"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G a =
fmap G (join term)
  (fmap G (Var (A:=term A)) (Œ¥ term G a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk13b">compose near (dist term G a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G a =
(fmap G (join term) ‚àò fmap G (Var (A:=term A)))
  (Œ¥ term G a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk13c"><span class="nb">rewrite</span> (fun_fmap_fmap G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G a =
fmap G (join term ‚àò Var (A:=term A)) (Œ¥ term G a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk13d"><span class="nb">replace</span> (join term ‚àò Var (A := term A)) <span class="kr">with</span> (@id (term A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G a = fmap G id (Œ¥ term G a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk13e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk13e"><hr></label><div class="goal-conclusion">id = join term ‚àò Var (A:=term A)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk13f"><span class="bp">now</span> <span class="nb">rewrite</span> (fun_fmap_id G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id = join term ‚àò Var (A:=term A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (join_ret).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk140">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t) =
fmap G (join term) (Œ¥ (term ‚óã term) G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (join term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
fmap G (join term) (Œ¥ (term ‚óã term) G (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk141"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t) =
fmap G (join term) (Œ¥ (term ‚óã term) G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Lam X) (Œ¥ term G (join term t)) =
fmap G (join term)
  (fmap G (Lam X) (Œ¥ term G (fmap term (Œ¥ term G) t)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk142"><span class="nb">rewrite</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t) =
fmap G (join term) (Œ¥ (term ‚óã term) G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Lam X)
  (fmap G (join term) (Œ¥ (term ‚óã term) G t)) =
fmap G (join term)
  (fmap G (Lam X) (Œ¥ term G (fmap term (Œ¥ term G) t)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk143">unfold_ops @Dist_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t) =
fmap G (join term) (Œ¥ (term ‚óã term) G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Lam X)
  (fmap G (join term)
     ((Œ¥ term G ‚àò fmap term (Œ¥ term G)) t)) =
fmap G (join term)
  (fmap G (Lam X) (Œ¥ term G (fmap term (Œ¥ term G) t)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk144"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t) =
fmap G (join term) (Œ¥ (term ‚óã term) G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Lam X)
  (fmap G (join term)
     (Œ¥ term G (fmap term (Œ¥ term G) t))) =
fmap G (join term)
  (fmap G (Lam X) (Œ¥ term G (fmap term (Œ¥ term G) t)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk145">compose near (dist term G (fmap term (dist term G) t)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t) =
fmap G (join term) (Œ¥ (term ‚óã term) G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap G (Lam X) ‚àò fmap G (join term))
  (Œ¥ term G (fmap term (Œ¥ term G) t)) =
(fmap G (join term) ‚àò fmap G (Lam X))
  (Œ¥ term G (fmap term (Œ¥ term G) t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk146"><span class="nb">rewrite</span> (fun_fmap_fmap G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t) =
fmap G (join term) (Œ¥ (term ‚óã term) G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Lam X ‚àò join term)
  (Œ¥ term G (fmap term (Œ¥ term G) t)) =
(fmap G (join term) ‚àò fmap G (Lam X))
  (Œ¥ term G (fmap term (Œ¥ term G) t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk147"><span class="nb">rewrite</span> (fun_fmap_fmap G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t) =
fmap G (join term) (Œ¥ (term ‚óã term) G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Lam X ‚àò join term)
  (Œ¥ term G (fmap term (Œ¥ term G) t)) =
fmap G (join term ‚àò Lam X)
  (Œ¥ term G (fmap term (Œ¥ term G) t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk148">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t1) =
fmap G (join term) (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t2) =
fmap G (join term) (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (join term ([t1][t2])) =
fmap G (join term) (Œ¥ (term ‚óã term) G ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk149"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t1) =
fmap G (join term) (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t2) =
fmap G (join term) (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure G (Ap (A:=A)) &lt;‚ãÜ&gt; Œ¥ term G (join term t1) &lt;‚ãÜ&gt;
Œ¥ term G (join term t2) =
fmap G (join term)
  (pure G (Ap (A:=term A)) &lt;‚ãÜ&gt;
   Œ¥ term G (fmap term (Œ¥ term G) t1) &lt;‚ãÜ&gt;
   Œ¥ term G (fmap term (Œ¥ term G) t2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk14a"><span class="nb">rewrite</span> IHt1, IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t1) =
fmap G (join term) (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t2) =
fmap G (join term) (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure G (Ap (A:=A)) &lt;‚ãÜ&gt;
fmap G (join term) (Œ¥ (term ‚óã term) G t1) &lt;‚ãÜ&gt;
fmap G (join term) (Œ¥ (term ‚óã term) G t2) =
fmap G (join term)
  (pure G (Ap (A:=term A)) &lt;‚ãÜ&gt;
   Œ¥ term G (fmap term (Œ¥ term G) t1) &lt;‚ãÜ&gt;
   Œ¥ term G (fmap term (Œ¥ term G) t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk14b">unfold_ops @Dist_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t1) =
fmap G (join term) (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t2) =
fmap G (join term) (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure G (Ap (A:=A)) &lt;‚ãÜ&gt;
fmap G (join term)
  ((Œ¥ term G ‚àò fmap term (Œ¥ term G)) t1) &lt;‚ãÜ&gt;
fmap G (join term)
  ((Œ¥ term G ‚àò fmap term (Œ¥ term G)) t2) =
fmap G (join term)
  (pure G (Ap (A:=term A)) &lt;‚ãÜ&gt;
   Œ¥ term G (fmap term (Œ¥ term G) t1) &lt;‚ãÜ&gt;
   Œ¥ term G (fmap term (Œ¥ term G) t2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk14c"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t1) =
fmap G (join term) (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t2) =
fmap G (join term) (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure G (Ap (A:=A)) &lt;‚ãÜ&gt;
fmap G (join term)
  (Œ¥ term G (fmap term (Œ¥ term G) t1)) &lt;‚ãÜ&gt;
fmap G (join term)
  (Œ¥ term G (fmap term (Œ¥ term G) t2)) =
fmap G (join term)
  (pure G (Ap (A:=term A)) &lt;‚ãÜ&gt;
   Œ¥ term G (fmap term (Œ¥ term G) t1) &lt;‚ãÜ&gt;
   Œ¥ term G (fmap term (Œ¥ term G) t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk14d"><span class="nb">rewrite</span> &lt;- fmap_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t1) =
fmap G (join term) (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t2) =
fmap G (join term) (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Ap (A:=A))
  (fmap G (join term)
     (Œ¥ term G (fmap term (Œ¥ term G) t1))) &lt;‚ãÜ&gt;
fmap G (join term)
  (Œ¥ term G (fmap term (Œ¥ term G) t2)) =
fmap G (join term)
  (pure G (Ap (A:=term A)) &lt;‚ãÜ&gt;
   Œ¥ term G (fmap term (Œ¥ term G) t1) &lt;‚ãÜ&gt;
   Œ¥ term G (fmap term (Œ¥ term G) t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk14e"><span class="nb">rewrite</span> &lt;- fmap_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t1) =
fmap G (join term) (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t2) =
fmap G (join term) (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (Ap (A:=A))
  (fmap G (join term)
     (Œ¥ term G (fmap term (Œ¥ term G) t1))) &lt;‚ãÜ&gt;
fmap G (join term)
  (Œ¥ term G (fmap term (Œ¥ term G) t2)) =
fmap G (join term)
  (fmap G (Ap (A:=term A))
     (Œ¥ term G (fmap term (Œ¥ term G) t1)) &lt;‚ãÜ&gt;
   Œ¥ term G (fmap term (Œ¥ term G) t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk14f"><span class="nb">rewrite</span> &lt;- ap_fmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t1) =
fmap G (join term) (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t2) =
fmap G (join term) (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (precompose (join term))
  (fmap G (Ap (A:=A))
     (fmap G (join term)
        (Œ¥ term G (fmap term (Œ¥ term G) t1)))) &lt;‚ãÜ&gt;
Œ¥ term G (fmap term (Œ¥ term G) t2) =
fmap G (join term)
  (fmap G (Ap (A:=term A))
     (Œ¥ term G (fmap term (Œ¥ term G) t1)) &lt;‚ãÜ&gt;
   Œ¥ term G (fmap term (Œ¥ term G) t2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk150"><span class="nb">rewrite</span> fmap_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t1) =
fmap G (join term) (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t2) =
fmap G (join term) (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (precompose (join term))
  (fmap G (Ap (A:=A))
     (fmap G (join term)
        (Œ¥ term G (fmap term (Œ¥ term G) t1)))) &lt;‚ãÜ&gt;
Œ¥ term G (fmap term (Œ¥ term G) t2) =
fmap G (compose (join term))
  (fmap G (Ap (A:=term A))
     (Œ¥ term G (fmap term (Œ¥ term G) t1))) &lt;‚ãÜ&gt;
Œ¥ term G (fmap term (Œ¥ term G) t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk151">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t1) =
fmap G (join term) (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t2) =
fmap G (join term) (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (precompose (join term))
  (fmap G (Ap (A:=A))
     (fmap G (join term)
        (Œ¥ term G (fmap term (Œ¥ term G) t1)))) =
fmap G (compose (join term))
  (fmap G (Ap (A:=term A))
     (Œ¥ term G (fmap term (Œ¥ term G) t1)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk152">compose near ((dist term G (fmap term (dist term G) t1))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t1) =
fmap G (join term) (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t2) =
fmap G (join term) (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (precompose (join term))
  ((fmap G (Ap (A:=A)) ‚àò fmap G (join term))
     (Œ¥ term G (fmap term (Œ¥ term G) t1))) =
(fmap G (compose (join term))
 ‚àò fmap G (Ap (A:=term A)))
  (Œ¥ term G (fmap term (Œ¥ term G) t1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk153"><span class="kp">repeat</span> <span class="nb">rewrite</span> (fun_fmap_fmap G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t1) =
fmap G (join term) (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t2) =
fmap G (join term) (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G (precompose (join term))
  (fmap G (Ap (A:=A) ‚àò join term)
     (Œ¥ term G (fmap term (Œ¥ term G) t1))) =
fmap G (compose (join term) ‚àò Ap (A:=term A))
  (Œ¥ term G (fmap term (Œ¥ term G) t1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk154">compose near ((dist term G (fmap term (dist term G) t1))) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t1) =
fmap G (join term) (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t2) =
fmap G (join term) (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap G (precompose (join term))
 ‚àò fmap G (Ap (A:=A) ‚àò join term))
  (Œ¥ term G (fmap term (Œ¥ term G) t1)) =
fmap G (compose (join term) ‚àò Ap (A:=term A))
  (Œ¥ term G (fmap term (Œ¥ term G) t1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk155"><span class="nb">rewrite</span> (fun_fmap_fmap G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Fmap G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t1) =
fmap G (join term) (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join term t2) =
fmap G (join term) (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap G
  (precompose (join term) ‚àò (Ap (A:=A) ‚àò join term))
  (Œ¥ term G (fmap term (Œ¥ term G) t1)) =
fmap G (compose (join term) ‚àò Ap (A:=term A))
  (Œ¥ term G (fmap term (Œ¥ term G) t1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">fequal.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Set Keyed Unification</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">TraversableMonad_term</span> : TraversableMonad term :=
  {| trvmon_ret := @trvmon_ret_term;
     trvmon_join := @trvmon_join_term;
  |}.</span></span></pre></div>
<div class="section" id="decorated-traversable-monad-instance">
<h2><a class="toc-backref" href="#toc-entry-12">Decorated-Traversable Monad instance</a></h2>
<p>Our hard work has paid off---a DTM is defined as the combination of the typeclass instances we have
given so far, so we can let Coq infer the DTM instance for us.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> : DecoratedTraversableMonad nat term := {}.</span></span></pre></div>
</div>
</div>
</div></body>
</html>
